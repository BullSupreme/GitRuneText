<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Adventure Game</title>
    <style>
        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: #1e1e1e;
            color: #d4d4d4;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background-color: #252526;
            border: 1px solid #333;
            padding: 20px;
            width: 90%;
            max-width: 800px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            position: relative;
        }

        .top-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 5px;
            z-index: 1000;
        }
        .top-controls button {
            padding: 7px 12px; 
            font-size: 0.9em;
        }
         .top-right-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
        }
        #mute-toggle-btn {
            padding: 7px 12px; 
            font-size: 0.9em;
        }


        .hud {
            background-color: #2a2a2d;
            border: 1px solid #444;
            padding: 10px;
            margin-bottom: 15px;
            margin-top: 50px;
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* Changed to 2 columns */
            gap: 8px; /* Space between grid items */
            align-items: center; /* Vertically align items in their cells */
        }
        /* .hud-column removed */
        .section {
            border: 1px solid #444;
            padding: 15px; /* Increased padding slightly to accommodate header */
            margin-bottom: 15px;
        }

        /* Old .section-title styles are now part of .section-title-header and .section-title-text */
        .section-title-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px; /* Space below header */
            border-bottom: 1px solid #555;
            padding-bottom: 8px;
        }

        .btn-back-header {
            background-color: transparent;
            border: none;
            color: #d4d4d4; /* Default text color */
            font-size: 1.6em; /* Make arrow larger */
            padding: 0 12px 0 0; /* Right padding, no left/top/bottom */
            margin: 0; /* Remove default button margins */
            cursor: pointer;
            font-weight: normal; /* Override general button bold */
            line-height: 1; /* Ensure it aligns well vertically */
            transition: color 0.2s ease, transform 0.2s ease, text-shadow 0.2s ease; /* Add transition */
        }
        .btn-back-header:hover {
            background-color: transparent; /* Keep background transparent */
            color: #fff; /* Make arrow brighter white */
            transform: scale(1.2); /* Make it grow slightly */
            text-shadow: 0 0 8px #fff; /* Add a white glow */
        }
        .section-header-actions { /* New: For buttons on the right of the section title */
            margin-left: auto; /* Pushes this container to the right */
            display: flex;
            align-items: center;
        }
        .section-header-actions button { /* Style for buttons within this container */
            padding: 5px 10px; font-size: 0.9em; margin-left: 5px;
        }
        .section-title-text { font-weight: bold; flex-grow: 1; font-size: 1.1em; }

        button {
            background-color: #0e639c;
            color: #222; 
            border: 1px solid #1c7abb;
            padding: 10px 18px; 
            margin: 5px;
            cursor: pointer;
            font-family: inherit;
            border-radius: 3px;
            font-size: 1.05em; 
            font-weight: bold; 
        }
        button:hover { background-color: #1177bb; }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
            border-color: #666;
        }
        button.red { background-color: #9c0e0e; }
        button.red:hover { background-color: #bb1111; }
        button.green { background-color: #0e9c18; }
        button.green:hover { background-color: #11bb1a; }
        button.yellow {
            background-color: #b4a61a;
        }
        button.yellow:hover {
            background-color: #d4c62a;
        }
        button.cyan { /* New class for light blue buttons */
            background-color: #4ec9b0; /* Teal/Cyan color */
            border-color: #40b39e;
        }
        button.cyan:hover { background-color: #5cd6c0; }
        .btn-buy-permits { /* New style for Buy Permits button */
            background-color: #6a0dad; /* Dark purple */
            border-color: #500784;
            color: #fff;
        }
        .btn-buy-permits:hover { background-color: #832db5; }


        #button-apply-cheat {
            background-color: #c586c0; /* A nice magenta, like your perk buttons */
            color: white;
            padding: 5px 10px; /* Reduced padding */
            margin-left: 8px; /* Add some space between the input and the button */
            border-color: #b373ac;
            font-size: 0.9em; /* Smaller font size */
        }
        #button-apply-cheat:hover {
            background-color: #d993d3; /* Lighter magenta on hover */
        }
        #cheat-input {
            width: 12ch; /* Makes it wide enough for about 12 characters of its font. Default input 'size' is 20. 12 is 40% less than 20. */
            padding: 5px 8px; /* Consistent with button's vertical padding, slightly less horizontal */
            font-size: 0.9em;  /* Consistent with button's font size */
            font-family: inherit; /* Use the monospace font from the body */
            background-color: #1c1c1c; /* Dark input background, similar to log area */
            color: #d4d4d4; /* Light text */
            border: 1px solid #555; /* Standard border for the theme */
            border-radius: 3px; /* Rounded corners like buttons */
            box-sizing: border-box; /* Ensures padding and border don't expand the specified width */
        }


        /* Styles for section footers (e.g., for Back buttons) */
        .section-footer-controls {
            display: flex;             /* New: To align items like the header */
            align-items: center;       /* New: To vertically center content */
            border-top: 1px solid #555; /* Same line style as the header */
            padding-top: 8px;          /* Space between the line and the button */
            margin-top: 15px;          /* Space between content above and the line */
        }
        .section-footer-controls button {
            margin: 0; /* Removes default button margins to align it neatly in the footer */
            padding-top: 0.262em;    /* Adjusted to match header content height */
            padding-bottom: 0.262em; /* Adjusted to match header content height */
            padding-left: 18px;      /* Keep horizontal padding consistent with other buttons */
            padding-right: 18px;     /* Keep horizontal padding consistent with other buttons */
        }
        /* Specific for main menu cheat code footer */
        .main-menu-footer-controls {
            justify-content: center; /* Center the cheat code container */
        }
        .cheat-code-container {
            display: flex;           /* Align input and button nicely */
            align-items: center;     /* Vertically center input and button */
        }
        .log-area {
            background-color: #1c1c1c;
            border: 1px dashed #555;
            padding: 10px;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
            white-space: pre-wrap;
        }

        .item, .monster-display, .skill-resource, .perk-entry {
            border: 1px solid #383838;
            padding: 8px;
            margin: 5px 0;
            background-color: #2d2d30;
            cursor: pointer; /* Existing */
            display: flex; /* New: for layout */
            justify-content: space-between; /* New: pushes count to the right */
            align-items: center; /* New: vertically aligns text and count */
        }
        .item:hover, .skill-resource:hover, .perk-entry:hover:not(.disabled-perk):not(.activated-perk) {
             background-color: #3a3d41;
        }
        .resource-inventory-count { /* New style for the count itself */
            background-color: #1c1c1c; padding: 2px 6px; border-radius: 4px; margin-left: 10px; font-weight: bold;
        }
        .monster-display .emoji { font-size: 2em; }
        .perk-entry.disabled-perk { cursor: not-allowed; background-color: #444; color: #888; }
        .perk-entry.activated-perk { cursor: default; background-color: #0e9c18; color: white; }
        .attacking-monster-list-item {
            background-color: #5e0000 !important; 
            border: 1px solid #ff4444 !important; 
            color: #fff !important;
        }
        .perk-entry .perk-cost { float: right; color: #dcdcaa;}

        /* Monster HP Bar Styles */
        #monster-display-combat {
            /* Override .monster-display styles that might conflict */
            display: block; /* Override flex from .monster-display */
            padding: 0;     /* Override padding from .monster-display */
            margin: 5px 0 15px 0; /* Vertical margin, more space below */
            background-color: #6d1f1f; /* Dark red for the empty part of the HP bar */
            cursor: default; /* It's not clickable like list items */

            /* Health bar specific styles */
            position: relative; /* For absolute positioning of fill and text */
            height: 30px;       /* Height of the health bar */
            border: 1px solid #333;
            border-radius: 5px; /* Rounded corners for the bar */
            overflow: hidden;   /* To clip the fill bar's corners */
            text-align: center; /* Center the text overlay */
            line-height: 30px;  /* Vertically center text (matches height) */
            color: white;       /* Default text color on the bar */
            font-weight: bold;
        }
        .monster-hp-bar-fill {
            position: absolute;
            top: 0; left: 0;
            height: 100%;
            background-color: #28a745; /* Green for HP */
            transition: width 0.25s ease-out; /* Smooth animation for HP loss */
            z-index: 1; /* Behind the text */
        }
        .monster-hp-bar-text {
            position: relative; /* To sit on top of the fill */
            z-index: 2;
            padding: 0 8px; /* Some horizontal padding for the text */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.6); /* For readability */
            font-size: 0.9em; /* Slightly smaller text to fit well */
        }
        #monster-display-combat .monster-hp-bar-text .emoji { /* Emoji inside the bar */
            font-size: 1em; /* Adjust to fit bar height */
            margin-right: 5px;
            vertical-align: middle; /* Better alignment with text */
        }
        .perk-entry .perk-desc { font-size: 0.9em; color: #aaa; margin-top: 3px;}
        
        .active-woodcutting-item, .active-mining-item, 
        .active-cooking-item, .active-smelting-item, .active-smithing-item {
            background-color: #004d00 !important; 
            border: 2px solid #33cc33 !important; 
            color: #fff !important;
            box-shadow: 0 0 8px #33cc33;
        }
        .active-mining-item {
            background-color: #33334d !important;
            border: 2px solid #6666cc !important;
            box-shadow: 0 0 8px #6666cc;
        }
        .active-smelting-item, .active-smithing-item {
            background-color: #502d00 !important;
            border: 2px solid #ff8c1a !important;
            box-shadow: 0 0 8px #ff8c1a;
        }
        .active-cooking-item {
            background-color: #665200 !important;
            border: 2px solid #ffcc00 !important;
            box-shadow: 0 0 8px #ffcc00;
        }

        .button-icon {
            display: inline-block; 
            transition: transform 0.2s ease-out, filter 0.2s ease-out;
            margin-right: 4px; 
        }
        button:hover .button-icon {
            transform: scale(1.3);
            filter: drop-shadow(0 0 5px #fff);
        }

        /* Color classes */
        .fore-blue { color: #569cd6; }
        .fore-green { color: #6a9955; }
        .fore-lightblack_ex { color: #999999; }
        .fore-yellow { color: #dcdcaa; }
        .fore-cyan { color: #4ec9b0; }
        .fore-red { color: #f44747; }
        .fore-lightred_ex { color: #ff7f7f; }
        .fore-magenta { color: #c586c0; }
        .fore-white { color: #d4d4d4; }
        .fore-orange { color: #ce9178; }
        .fore-dark-grey { color: #666666; }


        .hidden { display: none; }
        .inline-block { display: inline-block; }

        #equipment-display .slot { margin-bottom: 10px;}
        #equipment-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); /* Responsive grid */
            gap: 15px; /* Space between grid items */
            margin-top: 10px;
        }
        #equipment-display .slot {
            display: flex;
            flex-direction: column; /* Stack items vertically within the slot */
            align-items: center;   /* Center items horizontally */
            text-align: center;    /* Center text */
            padding: 10px;
            /* padding-bottom: 5px; */ /* Reverted to uniform padding from the rule above */
            border: 1px solid #383838;
            background-color: #2d2d30;
            border-radius: 4px;
        }
        #equipment-display .slot-name { font-weight: bold; margin-bottom: 5px; color: #a0a0a0; font-size: 0.9em; }
        #equipment-display .item-name { margin-bottom: 5px; font-size: 1.1em; min-height: 1.2em; /* Ensure space even if 'None' */ }
        #equipment-display .item-art { font-size: 2em; margin-bottom: 5px; min-height: 1.2em; /* Ensure space even if no art */ }
        #equipment-display .item-stats {
            font-size: 0.85em;
            color: #aaa;
            margin-top: 3px;
            flex-grow: 1; /* Allows this element to take up space, pushing button down */
        }
        #equipment-display .slot button {
            margin-top: auto; /* This pushes the button to the bottom of the flex container */
            width: 100%;      /* Make button full width of slot's content area */
            box-sizing: border-box; /* Include padding/border in width calculation */
            /* Override general button margins for horizontal and bottom */
            margin-left: 0;
            margin-right: 0;
            margin-bottom: 0; /* Button will be at the bottom of the slot's padding */
        }
        
        #inventory-list .item-entry {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        #inventory-list .inv-item-emoji {
            display: inline-block;
            width: 2.2em; 
            text-align: left;
            margin-right: 5px;
        }
        #inventory-list .item-name { 
            margin-right: 10px; 
        }
        #inventory-list .item-quantity { font-weight: bold; }

        #char-info-details p { margin: 5px 0; }
        .inventory-sort-controls {
            margin-bottom: 10px; display: flex; gap: 5px; flex-wrap: wrap;
        }
        .inventory-sort-button {
            padding: 5px 10px;
            font-size: 0.9em;
        }
        .inventory-sort-button.active-sort {
            background-color: #0e9c18; /* Green to indicate active */
            border-color: #0c8314;
        }
        .char-info-label { display: inline-block; width: 180px; font-weight: normal; color: #a0a0a0; }
        .char-info-value { font-weight: bold; }
        .char-info-xp { font-size: 0.9em; color: #b0b0b0; }


        .shop-item, .inv-item-equip, .cookable-item-list, .food-item-list, .smeltable-item-list, .smithable-item-list {
            cursor: pointer;
            padding: 5px;
        }
        .shop-item:hover, .inv-item-equip:hover, .cookable-item-list:hover, .food-item-list:hover, .smeltable-item-list:hover, .smithable-item-list:hover {
            background-color: #3a3d41;
        }
        .shop-item .price { color: #dcdcaa; margin-left: auto; /* Pushes price to the right in flex */ }
        .shop-item .req { font-size: 0.9em; color: #888; }

        .hud-item {
            display: flex;
            align-items: center;
        }
        .hud-icon {
            font-size: 1.2em;
            margin-right: 8px;
            display: inline-block;
            transition: transform 0.2s ease-out, filter 0.2s ease-out;
            position: relative;
            cursor: default;
        }
        .hud-icon:hover {
            transform: scale(1.3);
            filter: drop-shadow(0 0 5px #fff);
            z-index: 1001; /* Elevate the hovered icon itself */
        }
        .hud-icon .tooltip-text {
            visibility: hidden;
            width: max-content;
            max-width: 150px;
            background-color: #111;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 8px;
            position: absolute; /* Stays absolute */
            bottom: 125%; 
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8em;
            z-index: 1050; /* Increased z-index for the tooltip */
            pointer-events: none;
        }
        /* Removed: .hud-icon:hover .tooltip-text */

        /* Show tooltip when hovering the skill XP bar */
        .hud-skill-xp-bar:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        /* Show tooltip when hovering the HP bar */
        #hud-hp:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        /* Player HP Bar in HUD */
        #hud-hp { /* This is the container for the HP bar, also a .hud-item */
            position: relative;
            height: 22px; 
            background-color: #6d1f1f; /* Dark red for the empty part of the HP bar */
            border: 1px solid #333;
            border-radius: 4px;
            /* overflow: hidden; */ /* Removed to allow tooltip to show */
            display: block; /* Override .hud-item's flex if it was causing issues */
            padding: 0; /* No padding for the bar itself */
            box-sizing: border-box;
            transition: border-color 0.2s ease-out, box-shadow 0.2s ease-out, transform 0.2s ease-out; /* Added transform to transition */
            /* grid-column: span 2; */ /* Removed, HP bar will now take 1 cell width in 2-col layout */
        }
        #hud-hp:hover {
            border-color: #666; /* Lighter border on hover */
            box-shadow: 0 0 6px rgba(212, 212, 212, 0.25); /* Subtle white glow, using text color base */
            transform: scale(1.03); /* Make it grow slightly on hover */
            z-index: 1001; /* Bring hovered HP bar above top-controls */
        }
        #hud-hp.hud-hp-low { /* Style for low HP warning */
            box-shadow: 0 0 8px rgba(255, 0, 0, 0.7), 0 0 4px rgba(255,0,0,0.5) inset; /* Red glow */
            border-color: #a00; /* Darker red border for low HP */
            animation: pulse-red 1.5s infinite alternate; /* Pulsing animation */
        }
        .hud-hp-bar-fill {
            position: absolute; top: 0; left: 0;
            height: 100%;
            background-color: #28a745; /* Green for HP */
            transition: width 0.25s ease-out;
            z-index: 1;
            border-radius: 3px 0 0 3px; /* Rounded only on left if bar is not full */
        }
        .hud-hp-bar-fill.full { border-radius: 3px; }

        .hud-hp-bar-text {
            position: relative; z-index: 2;
            width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            color: white; font-size: 0.85em;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.7);
            gap: 4px; /* Space between icon and text value */
        }

        /* Skill XP Bar Styles */
        .hud-skill-xp-bar {
            position: relative;
            height: 22px; /* Match HP bar */
            border: 1px solid #333;
            border-radius: 4px;
            /* overflow: hidden; */ /* Removed to allow tooltip to show */
            box-sizing: border-box;
            background-color: #3a3a3d; /* Darker background for the empty part of XP bar */
            transition: border-color 0.2s ease-out, box-shadow 0.2s ease-out, transform 0.2s ease-out;
        }
        .hud-skill-xp-bar:hover {
            border-color: #666;
            box-shadow: 0 0 6px rgba(212, 212, 212, 0.25);
            transform: scale(1.03);
            z-index: 1001; /* Bring hovered skill bar above top-controls */
        }
         .hud-skill-xp-bar .hud-icon { /* Override default hud-icon margin if inside an XP bar */
            margin-right: 0;
        }
        .hud-xp-bar-fill {
            position: absolute; top: 0; left: 0;
            height: 100%;
            transition: width 0.25s ease-out;
            z-index: 1;
            border-radius: 3px 0 0 3px; /* Rounded only on left if bar is not full */
        }
        .hud-xp-bar-fill.full { border-radius: 3px; } /* Fully rounded when 100% */

        /* Specific fill colors for skill XP bars */
        #hud-wc .hud-xp-bar-fill { background-color: #6a9955; } /* Woodcutting Green */
        #hud-mn .hud-xp-bar-fill { background-color: #707d8b; } /* Mining - A dusty blue/grey */
        #hud-ck .hud-xp-bar-fill { background-color: #dcdcaa; } /* Cooking Yellow */
        #hud-bs .hud-xp-bar-fill { background-color: #ce9178; } /* Blacksmithing Orange */
        #hud-atk .hud-xp-bar-fill { background-color: #f44747; } /* Attack Red */

        .hud-xp-bar-text {
            position: relative; z-index: 2;
            width: 100%; height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.85em;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.7);
            padding: 0 5px;
            gap: 5px;
        }
        .hud-xp-bar-text .hud-skill-level-text {
            font-weight: bold;
        }

        /* End Skill XP Bar Styles */

        #hud-hp.hud-hp-low { /* Style for low HP warning - This was duplicated, ensure it's defined once */
            box-shadow: 0 0 8px rgba(255, 0, 0, 0.7), 0 0 4px rgba(255,0,0,0.5) inset; /* Red glow */
            border-color: #a00; /* Darker red border for low HP */
            animation: pulse-red 1.5s infinite alternate; /* Pulsing animation */
        }
        .hud-hp-bar-fill {
            position: absolute; top: 0; left: 0;
            height: 100%;
            background-color: #28a745; /* Green for HP */
            transition: width 0.25s ease-out;
            z-index: 1;
        }        
        @keyframes pulse-red { /* Pulsing animation for low HP */
            from {
                box-shadow: 0 0 8px rgba(255, 0, 0, 0.6), 0 0 3px rgba(255,0,0,0.4) inset;
            }
            to {
                box-shadow: 0 0 12px rgba(255, 0, 0, 0.9), 0 0 5px rgba(255,0,0,0.7) inset;
            }
        }


        .hud-icon:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        .main-menu-buttons-container {
            display: flex;
            gap: 5px; 
            margin-bottom: 10px; 
        }
        .main-menu-buttons-container button {
            flex: 1; 
            margin: 0; 
            padding: 10px 12px; 
            text-align: center; 
            min-width: 0; /* Allow buttons to shrink */
        }
        #main-menu-section .btn-actions { background-color: #0e9c18; border-color: #0c8314; }
        #main-menu-section .btn-char-info {
            background-color: #c1b7a0; /* Beige */
            border-color: #b0a58f;
        }
        #main-menu-section .btn-char-info:hover { background-color: #d4cbb9; }
        #main-menu-section .btn-inventory { background-color: #8b7355; border-color: #7a6244; } /* Brown */
        #main-menu-section .btn-inventory:hover { background-color: #a0886c; }
        #main-menu-section .btn-actions:hover { background-color: #11bb1a; }
        #main-menu-section .btn-shop {
            background-color: #b4a61a;
            border-color: #a09417;
        }
        #main-menu-section .btn-shop:hover { background-color: #d4c62a; }
        #main-menu-section .btn-perks { background-color: #c586c0; border-color: #b373ac; }
        #main-menu-section .btn-perks:hover { background-color: #d993d3; }

        /* Guild Button Style - similar to Buy Permits or a distinct color */
        #main-menu-section .btn-guild { background-color: #6a0dad; border-color: #500784; color: #fff; }
        #main-menu-section .btn-guild:hover { background-color: #832db5; }

        .submenu-buttons-container {
            display: flex;
            gap: 5px; 
            margin-bottom: 10px; 
        }
        .submenu-buttons-container button {
            flex: 1; 
            margin: 0; 
            padding: 10px 12px; 
            text-align: center; 
            min-width: 0; /* Allow buttons to shrink */
        }

        .btn-woodcutting { background-color: #588f46; border-color: #4a7a3a; } /* Made general */
        .btn-woodcutting:hover { background-color: #6aab55; }
        .btn-mining { background-color: #6c757d; border-color: #5a6268; } /* Made general */
        .btn-mining:hover { background-color: #808890; }
        #actions-menu-section .btn-blacksmithing { background-color: #d66f2e; border-color: #c06021; }
        #actions-menu-section .btn-blacksmithing:hover { background-color: #e8823f; }
        .btn-combat { background-color: #c9302c; border-color: #ac2925; } /* Made general */
        .btn-combat:hover { background-color: #e04440; }
        #actions-menu-section .btn-eat { background-color: #4cae4c; border-color: #459c45; }
        #actions-menu-section .btn-eat:hover { background-color: #5cb85c; }
        #actions-menu-section .btn-cook {
            background-color: #eea236;
            border-color: #d58d20;
        }
        #actions-menu-section .btn-cook:hover { background-color: #f0ad4e; }
        #actions-menu-section .btn-build-structures { background-color: #795548; border-color: #6a4a3e; }
        #actions-menu-section .btn-build-structures:hover { background-color: #8d6e63; }

        #shop-menu-section .btn-buy-tools {
            background-color: #d4af37;
            /* color: #3e300b; Inherited */
            border-color: #c09d31;
        }
        #shop-menu-section .btn-buy-tools:hover { background-color: #e6c350; }
        #shop-menu-section .btn-sell-items {
            background-color: #a7b0b9;
            /* color: #2a2d30; Inherited */
            border-color: #979fa6;
        }
        #shop-menu-section .btn-sell-items:hover { background-color: #c1c8cf; }

        #blacksmithing-menu-section .btn-smelt-bars { background-color: #e07a5f; border-color: #ca6b50; }
        #blacksmithing-menu-section .btn-smelt-bars:hover { background-color: #f28c70; }
        #blacksmithing-menu-section .btn-smith-weapons { background-color: #8d6e63; border-color: #7b5f55; }
        #blacksmithing-menu-section .btn-smith-weapons:hover { background-color: #a18278; }

        /* New Styles for Build Structures Section */
        .structure-item-card {
            display: flex;
            flex-direction: column;
            border: 1px solid #3b475c; /* Slightly darker, more distinct border */
            border-left: 5px solid #63b3ed; /* Accent color */
            padding: 15px;
            margin-bottom: 15px;
            background-color: #2a313f; /* Darker card background */
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .structure-item-card h3 { /* Name and Emoji */
            margin-top: 0;
            margin-bottom: 10px;
            color: #90cdf4; /* Lighter blue for title */
            display: flex;
            align-items: center;
            font-size: 1.2em;
        }
        .structure-item-card h3 .emoji {
            font-size: 1.6em; /* Larger emoji */
            margin-right: 12px;
        }
        .structure-item-card .built-status {
            font-size: 0.85em;
            margin-left: 10px;
            font-weight: normal;
        }
        .structure-item-card .description { /* Perk description */
            font-style: italic;
            color: #b0c4de; /* Lighter grey/blue for description */
            margin-bottom: 12px;
            font-size: 0.95em;
        }
        .structure-item-card .requirements-block { /* Cost and Prerequisite */
            background-color: #212733; /* Even darker for requirements block */
            padding: 12px;
            border-radius: 3px;
            margin-bottom: 12px;
            font-size: 0.9em;
        }
        .structure-item-card .requirements-block h4 { margin-top: 0; margin-bottom: 8px; color: #a0aec0; }
        .structure-item-card .requirements-block p { margin: 4px 0; color: #e2e8f0; }
        .structure-item-card .requirements-block .cost-item-name { color: #cbd5e0; }
        .structure-item-card .actions { /* Button or Locked Text */
            margin-top: 10px;
        }
        /* Style for built structure cards */
        .built-structure-card { border-left-color: #6a9955 !important; background-color: #2a3f2e !important; }
        .built-structure-card h3 { color: #8cc877 !important; } /* Make title green too */

        .glow-green-temp {
            background-color: #0e9c18 !important; /* Strong green */
            border-color: #33ff33 !important;
            box-shadow: 0 0 15px #33ff33, 0 0 8px #33ff33 inset !important; /* Green glow */
            color: white !important;
            transition: background-color 0.1s ease-out, box-shadow 0.1s ease-out, border-color 0.1s ease-out;
        }
        /* New Styles for Perk Tree Section */
        .perk-item-card {
            display: flex;
            flex-direction: column;
            border: 1px solid #4a3b5c; /* Perk-themed border */
            border-left: 5px solid #c586c0; /* Perk accent color (magenta) */
            padding: 15px;
            margin-bottom: 15px;
            background-color: #2d2a3f; /* Darker purple/magenta card background */
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .perk-item-card .perk-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        .perk-item-card .perk-name {
            color: #d993d3; /* Lighter magenta for title */
            font-size: 1.15em;
            font-weight: bold;
        }
        .perk-item-card .perk-cost-display {
            background-color: #1c1a25;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 0.9em;
            color: #e2e8f0;
        }
        .perk-item-card .perk-description {
            color: #b0c4de;
            margin-top: 2px;
            margin-bottom: 2px; /* Further reduced spacing below description */
            font-size: 0.95em;
        }
        .perk-item-card .perk-status-action { margin-top: 2px; } /* Further reduced spacing above action/button */
        .perk-item-card .perk-status-action { margin-bottom: 2px; }
        .perk-item-card .fore-green { margin: 2px;}
        .perk-item-card .perk-status-action .status-tet { font-style: italic; font-size: 0.9em; }
        .perk-item-card.activated-perk-card { border-left-color: #6a9955; background-color: #2a3f2e; } /* Greenish for activated */
        .perk-item-card.activated-perk-card .perk-name { color: #8cc877; }
        /* Style for the activate button within perk cards */
        .perk-item-card .perk-status-action button {
            background-color: #c586c0; /* Match .btn-perks base color */
            border: 1px solid #b373ac;   /* Match .btn-perks base border color */
            padding: 4px 5px; /* Further reduced padding to make button more compact */
            font-size: 0.9em;  /* Make font smaller */
            font-weight: bold; /* Ensure font weight is consistent */
            transition: background-color 0.2s ease, border-color 0.2s ease, transform 0.2s ease; /* Smooth transition */
        }
        .perk-item-card .perk-status-action button:hover {
            background-color: #d993d3; /* Match .btn-perks hover color */
            border-color: #d993d3;   /* Lighter border on hover */
            transform: scale(1.03); /* Slight zoom effect on hover */
        }
        .perk-item-card.disabled-perk-card { opacity: 0.7; }

        /* Guild Member Card Specifics */
        .guild-member-card {
            border: 1px solid #4a4a52;
            background-color: #2c2c32; 
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            position: relative; /* Needed for z-indexing and absolute positioning of fill */
        }
        .guild-member-card.on-task {
            overflow: hidden; /* To clip the fill bar's corners */
            /* The base background-color of .guild-member-card will be the "empty" part of the bar */
        }
        /* This is the fill div *inside* the guild-member-card */
        .guild-member-card > .member-task-progress-bar-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background-color: #4ec9b0; /* Cyan for fill */
            width: 0%;
            transition: width 0.5s ease-out;
            z-index: 1; /* Behind info and controls */
            border-radius: 0; /* Card itself has border-radius */
        }

        .member-info {
            display: flex;
            justify-content: space-between;
            align-items: flex-start; /* Align to top */
            flex-wrap: wrap; /* Allow status to wrap if needed */
            position: relative; /* To stay on top of progress fill */
            z-index: 2;
            /* Card already has padding, so info div doesn't need extra unless desired */
        }
        .member-details { /* Wrapper for name/level/xp */
            /* flex-grow: 1; /* Allow it to take most space */
            margin-right: 10px; /* Space between details and status */
        }
        .member-status {
            font-style: italic;
            font-size: 0.9em;
            text-align: right;
            white-space: nowrap; /* Try to keep status on one line */
        }
        .guild-member-card .member-task-controls { /* Controls for "Return Early" */
            position: relative;
            z-index: 2;
            text-align: center;
            padding-top: 8px; /* Space above the button */
        }
        .member-action-panel { /* Panel with Gather/Mine/Hunt buttons */
            position: relative; /* Ensure it's also on top if card is somehow 'on-task' styled */
            z-index: 2;
            margin-top: 8px;
        }
        .member-action-button { 
            padding: 4px 8px; font-size: 0.85em; margin: 2px;
        }
        /* For Guild Stash transfer button */
        .item-entry .transfer-button {
            margin-left: auto; /* Pushes button to the right */
            padding: 3px 6px; font-size: 0.8em; /* Smaller button */
            /* margin-right: 5px; /* Removed as 'All' button per item is gone */
        }


        /* Styles for section footers (e.g., for Back buttons) */
        .section-footer-controls {
            display: flex;             /* New: To align items like the header */
            align-items: center;       /* New: To vertically center content */
            border-top: 1px solid #555; /* Same line style as the header */
            padding-top: 8px;          /* Space between the line and the button */
            margin-top: 15px;          /* Space between content above and the line */
        }
        .section-footer-controls button {
            margin: 0; /* Removes default button margins to align it neatly in the footer */
            padding-top: 0.262em;    /* Adjusted to match header content height */
            padding-bottom: 0.262em; /* Adjusted to match header content height */
            padding-left: 18px;      /* Keep horizontal padding consistent with other buttons */
            padding-right: 18px;     /* Keep horizontal padding consistent with other buttons */
        }
        /* Specific for main menu cheat code footer */
        .main-menu-footer-controls {
            justify-content: center; /* Center the cheat code container */
        }
        .cheat-code-container {
            display: flex;           /* Align input and button nicely */
            align-items: center;     /* Vertically center input and button */
        }
        .log-area {
            background-color: #1c1c1c;
            border: 1px dashed #555;
            padding: 10px;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
            white-space: pre-wrap;
        }

        .item, .monster-display, .skill-resource, .perk-entry {
            border: 1px solid #383838;
            padding: 8px;
            margin: 5px 0;
            background-color: #2d2d30;
            cursor: pointer; /* Existing */
            display: flex; /* New: for layout */
            justify-content: space-between; /* New: pushes count to the right */
            align-items: center; /* New: vertically aligns text and count */
        }
        .item:hover, .skill-resource:hover, .perk-entry:hover:not(.disabled-perk):not(.activated-perk) {
             background-color: #3a3d41;
        }
        .resource-inventory-count { /* New style for the count itself */
            background-color: #1c1c1c; padding: 2px 6px; border-radius: 4px; margin-left: 10px; font-weight: bold;
        }
        .monster-display .emoji { font-size: 2em; }
        .perk-entry.disabled-perk { cursor: not-allowed; background-color: #444; color: #888; }
        .perk-entry.activated-perk { cursor: default; background-color: #0e9c18; color: white; }
        .attacking-monster-list-item {
            background-color: #5e0000 !important; 
            border: 1px solid #ff4444 !important; 
            color: #fff !important;
        }
        .perk-entry .perk-cost { float: right; color: #dcdcaa;}

        /* Monster HP Bar Styles */
        #monster-display-combat {
            /* Override .monster-display styles that might conflict */
            display: block; /* Override flex from .monster-display */
            padding: 0;     /* Override padding from .monster-display */
            margin: 5px 0 15px 0; /* Vertical margin, more space below */
            background-color: #6d1f1f; /* Dark red for the empty part of the HP bar */
            cursor: default; /* It's not clickable like list items */

            /* Health bar specific styles */
            position: relative; /* For absolute positioning of fill and text */
            height: 30px;       /* Height of the health bar */
            border: 1px solid #333;
            border-radius: 5px; /* Rounded corners for the bar */
            overflow: hidden;   /* To clip the fill bar's corners */
            text-align: center; /* Center the text overlay */
            line-height: 30px;  /* Vertically center text (matches height) */
            color: white;       /* Default text color on the bar */
            font-weight: bold;
        }
        .monster-hp-bar-fill {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            background-color: #28a745; /* Green for HP */
            transition: width 0.25s ease-out; /* Smooth animation for HP loss */
            z-index: 1; /* Behind the text */
        }
        .monster-hp-bar-text {
            position: relative; /* To sit on top of the fill */
            z-index: 2;
            padding: 0 8px; /* Some horizontal padding for the text */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.6); /* For readability */
            font-size: 0.9em; /* Slightly smaller text to fit well */
        }
        #monster-display-combat .monster-hp-bar-text .emoji { /* Emoji inside the bar */
            font-size: 1em; /* Adjust to fit bar height */
            margin-right: 5px;
            vertical-align: middle; /* Better alignment with text */
        }
        .perk-entry .perk-desc { font-size: 0.9em; color: #aaa; margin-top: 3px;}
        
        .active-woodcutting-item, .active-mining-item, 
        .active-cooking-item, .active-smelting-item, .active-smithing-item {
            background-color: #004d00 !important; 
            border: 2px solid #33cc33 !important; 
            color: #fff !important;
            box-shadow: 0 0 8px #33cc33;
        }
        .active-mining-item {
            background-color: #33334d !important;
            border: 2px solid #6666cc !important;
            box-shadow: 0 0 8px #6666cc;
        }
        .active-smelting-item, .active-smithing-item {
            background-color: #502d00 !important;
            border: 2px solid #ff8c1a !important;
            box-shadow: 0 0 8px #ff8c1a;
        }
        .active-cooking-item {
            background-color: #665200 !important;
            border: 2px solid #ffcc00 !important;
            box-shadow: 0 0 8px #ffcc00;
        }

        .button-icon {
            display: inline-block; 
            transition: transform 0.2s ease-out, filter 0.2s ease-out;
            margin-right: 4px; 
        }
        button:hover .button-icon {
            transform: scale(1.3);
            filter: drop-shadow(0 0 5px #fff);
        }

        /* Color classes */
        .fore-blue { color: #569cd6; }
        .fore-green { color: #6a9955; }
        .fore-lightblack_ex { color: #999999; }
        .fore-yellow { color: #dcdcaa; }
        .fore-cyan { color: #4ec9b0; }
        .fore-red { color: #f44747; }
        .fore-lightred_ex { color: #ff7f7f; }
        .fore-magenta { color: #c586c0; }
        .fore-white { color: #d4d4d4; }
        .fore-orange { color: #ce9178; }
        .fore-dark-grey { color: #666666; }


        .hidden { display: none; }
        .inline-block { display: inline-block; }

        #equipment-display .slot { margin-bottom: 10px;}
        #equipment-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); /* Responsive grid */
            gap: 15px; /* Space between grid items */
            margin-top: 10px;
        }
        #equipment-display .slot {
            display: flex;
            flex-direction: column; /* Stack items vertically within the slot */
            align-items: center;   /* Center items horizontally */
            text-align: center;    /* Center text */
            padding: 10px;
            /* padding-bottom: 5px; */ /* Reverted to uniform padding from the rule above */
            border: 1px solid #383838;
            background-color: #2d2d30;
            border-radius: 4px;
        }
        #equipment-display .slot-name { font-weight: bold; margin-bottom: 5px; color: #a0a0a0; font-size: 0.9em; }
        #equipment-display .item-name { margin-bottom: 5px; font-size: 1.1em; min-height: 1.2em; /* Ensure space even if 'None' */ }
        #equipment-display .item-art { font-size: 2em; margin-bottom: 5px; min-height: 1.2em; /* Ensure space even if no art */ }
        #equipment-display .item-stats {
            font-size: 0.85em;
            color: #aaa;
            margin-top: 3px;
            flex-grow: 1; /* Allows this element to take up space, pushing button down */
        }
        #equipment-display .slot button {
            margin-top: auto; /* This pushes the button to the bottom of the flex container */
            width: 100%;      /* Make button full width of slot's content area */
            box-sizing: border-box; /* Include padding/border in width calculation */
            /* Override general button margins for horizontal and bottom */
            margin-left: 0;
            margin-right: 0;
            margin-bottom: 0; /* Button will be at the bottom of the slot's padding */
        }
        
        #inventory-list .item-entry {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        #inventory-list .inv-item-emoji {
            display: inline-block;
            width: 2.2em; 
            text-align: left;
            margin-right: 5px;
        }
        #inventory-list .item-name { 
            margin-right: 10px; 
        }
        #inventory-list .item-quantity { font-weight: bold; }

        #char-info-details p { margin: 5px 0; }
        .inventory-sort-controls {
            margin-bottom: 10px; display: flex; gap: 5px; flex-wrap: wrap;
        }
        .inventory-sort-button {
            padding: 5px 10px;
            font-size: 0.9em;
        }
        .inventory-sort-button.active-sort {
            background-color: #0e9c18; /* Green to indicate active */
            border-color: #0c8314;
        }
        .char-info-label { display: inline-block; width: 180px; font-weight: normal; color: #a0a0a0; }
        .char-info-value { font-weight: bold; }
        .char-info-xp { font-size: 0.9em; color: #b0b0b0; }


        .shop-item, .inv-item-equip, .cookable-item-list, .food-item-list, .smeltable-item-list, .smithable-item-list {
            cursor: pointer;
            padding: 5px;
        }
        .shop-item:hover, .inv-item-equip:hover, .cookable-item-list:hover, .food-item-list:hover, .smeltable-item-list:hover, .smithable-item-list:hover {
            background-color: #3a3d41;
        }
        .shop-item .price { color: #dcdcaa; margin-left: auto; /* Pushes price to the right in flex */ }
        .shop-item .req { font-size: 0.9em; color: #888; }

        .hud-item {
            display: flex;
            align-items: center;
        }
        .hud-icon {
            font-size: 1.2em;
            margin-right: 8px;
            display: inline-block;
            transition: transform 0.2s ease-out, filter 0.2s ease-out;
            position: relative;
            cursor: default;
        }
        .hud-icon:hover {
            transform: scale(1.3);
            filter: drop-shadow(0 0 5px #fff);
            z-index: 1001; /* Elevate the hovered icon itself */
        }
        .hud-icon .tooltip-text {
            visibility: hidden;
            width: max-content;
            max-width: 150px;
            background-color: #111;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 8px;
            position: absolute; /* Stays absolute */
            bottom: 125%; 
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8em;
            z-index: 1050; /* Increased z-index for the tooltip */
            pointer-events: none;
        }
        /* Removed: .hud-icon:hover .tooltip-text */

        /* Show tooltip when hovering the skill XP bar */
        .hud-skill-xp-bar:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        /* Show tooltip when hovering the HP bar */
        #hud-hp:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        /* Player HP Bar in HUD */
        #hud-hp { /* This is the container for the HP bar, also a .hud-item */
            position: relative;
            height: 22px; 
            background-color: #6d1f1f; /* Dark red for the empty part of the HP bar */
            border: 1px solid #333;
            border-radius: 4px;
            /* overflow: hidden; */ /* Removed to allow tooltip to show */
            display: block; /* Override .hud-item's flex if it was causing issues */
            padding: 0; /* No padding for the bar itself */
            box-sizing: border-box;
            transition: border-color 0.2s ease-out, box-shadow 0.2s ease-out, transform 0.2s ease-out; /* Added transform to transition */
            /* grid-column: span 2; */ /* Removed, HP bar will now take 1 cell width in 2-col layout */
        }
        #hud-hp:hover {
            border-color: #666; /* Lighter border on hover */
            box-shadow: 0 0 6px rgba(212, 212, 212, 0.25); /* Subtle white glow, using text color base */
            transform: scale(1.03); /* Make it grow slightly on hover */
            z-index: 1001; /* Bring hovered HP bar above top-controls */
        }
        #hud-hp.hud-hp-low { /* Style for low HP warning */
            box-shadow: 0 0 8px rgba(255, 0, 0, 0.7), 0 0 4px rgba(255,0,0,0.5) inset; /* Red glow */
            border-color: #a00; /* Darker red border for low HP */
            animation: pulse-red 1.5s infinite alternate; /* Pulsing animation */
        }
        .hud-hp-bar-fill {
            position: absolute; top: 0; left: 0;
            height: 100%;
            background-color: #28a745; /* Green for HP */
            transition: width 0.25s ease-out;
            z-index: 1;
            border-radius: 3px 0 0 3px; /* Rounded only on left if bar is not full */
        }
        .hud-hp-bar-fill.full { border-radius: 3px; }

        .hud-hp-bar-text {
            position: relative; z-index: 2;
            width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            color: white; font-size: 0.85em;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.7);
            gap: 4px; /* Space between icon and text value */
        }

        /* Skill XP Bar Styles */
        .hud-skill-xp-bar {
            position: relative;
            height: 22px; /* Match HP bar */
            border: 1px solid #333;
            border-radius: 4px;
            /* overflow: hidden; */ /* Removed to allow tooltip to show */
            box-sizing: border-box;
            background-color: #3a3a3d; /* Darker background for the empty part of XP bar */
            transition: border-color 0.2s ease-out, box-shadow 0.2s ease-out, transform 0.2s ease-out;
        }
        .hud-skill-xp-bar:hover {
            border-color: #666;
            box-shadow: 0 0 6px rgba(212, 212, 212, 0.25);
            transform: scale(1.03);
            z-index: 1001; /* Bring hovered skill bar above top-controls */
        }
         .hud-skill-xp-bar .hud-icon { /* Override default hud-icon margin if inside an XP bar */
            margin-right: 0;
        }
        .hud-xp-bar-fill {
            position: absolute; top: 0; left: 0;
            height: 100%;
            transition: width 0.25s ease-out;
            z-index: 1;
            border-radius: 3px 0 0 3px; /* Rounded only on left if bar is not full */
        }
        .hud-xp-bar-fill.full { border-radius: 3px; } /* Fully rounded when 100% */

        /* Specific fill colors for skill XP bars */
        #hud-wc .hud-xp-bar-fill { background-color: #6a9955; } /* Woodcutting Green */
        #hud-mn .hud-xp-bar-fill { background-color: #707d8b; } /* Mining - A dusty blue/grey */
        #hud-ck .hud-xp-bar-fill { background-color: #dcdcaa; } /* Cooking Yellow */
        #hud-bs .hud-xp-bar-fill { background-color: #ce9178; } /* Blacksmithing Orange */
        #hud-atk .hud-xp-bar-fill { background-color: #f44747; } /* Attack Red */

        .hud-xp-bar-text {
            position: relative; z-index: 2;
            width: 100%; height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.85em;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.7);
            padding: 0 5px;
            gap: 5px;
        }
        .hud-xp-bar-text .hud-skill-level-text {
            font-weight: bold;
        }

        /* End Skill XP Bar Styles */

        #hud-hp.hud-hp-low { /* Style for low HP warning - This was duplicated, ensure it's defined once */
            box-shadow: 0 0 8px rgba(255, 0, 0, 0.7), 0 0 4px rgba(255,0,0,0.5) inset; /* Red glow */
            border-color: #a00; /* Darker red border for low HP */
            animation: pulse-red 1.5s infinite alternate; /* Pulsing animation */
        }
        .hud-hp-bar-fill {
            position: absolute; top: 0; left: 0;
            height: 100%;
            background-color: #28a745; /* Green for HP */
            transition: width 0.25s ease-out;
            z-index: 1;
        }        
        @keyframes pulse-red { /* Pulsing animation for low HP */
            from {
                box-shadow: 0 0 8px rgba(255, 0, 0, 0.6), 0 0 3px rgba(255,0,0,0.4) inset;
            }
            to {
                box-shadow: 0 0 12px rgba(255, 0, 0, 0.9), 0 0 5px rgba(255,0,0,0.7) inset;
            }
        }


        .hud-icon:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        .main-menu-buttons-container {
            display: flex;
            gap: 5px; 
            margin-bottom: 10px; 
        }
        .main-menu-buttons-container button {
            flex: 1; 
            margin: 0; 
            padding: 10px 12px; 
            text-align: center; 
            min-width: 0; /* Allow buttons to shrink */
        }
        #main-menu-section .btn-actions { background-color: #0e9c18; border-color: #0c8314; }
        #main-menu-section .btn-char-info {
            background-color: #c1b7a0; /* Beige */
            border-color: #b0a58f;
        }
        #main-menu-section .btn-char-info:hover { background-color: #d4cbb9; }
        #main-menu-section .btn-inventory { background-color: #8b7355; border-color: #7a6244; } /* Brown */
        #main-menu-section .btn-inventory:hover { background-color: #a0886c; }
        #main-menu-section .btn-actions:hover { background-color: #11bb1a; }
        #main-menu-section .btn-shop {
            background-color: #b4a61a;
            border-color: #a09417;
        }
        #main-menu-section .btn-shop:hover { background-color: #d4c62a; }
        #main-menu-section .btn-perks { background-color: #c586c0; border-color: #b373ac; }
        #main-menu-section .btn-perks:hover { background-color: #d993d3; }

        /* Guild Button Style - similar to Buy Permits or a distinct color */
        #main-menu-section .btn-guild { background-color: #6a0dad; border-color: #500784; color: #fff; }
        #main-menu-section .btn-guild:hover { background-color: #832db5; }

        .submenu-buttons-container {
            display: flex;
            gap: 5px; 
            margin-bottom: 10px; 
        }
        .submenu-buttons-container button {
            flex: 1; 
            margin: 0; 
            padding: 10px 12px; 
            text-align: center; 
            min-width: 0; /* Allow buttons to shrink */
        }

        .btn-woodcutting { background-color: #588f46; border-color: #4a7a3a; } /* Made general */
        .btn-woodcutting:hover { background-color: #6aab55; }
        .btn-mining { background-color: #6c757d; border-color: #5a6268; } /* Made general */
        .btn-mining:hover { background-color: #808890; }
        #actions-menu-section .btn-blacksmithing { background-color: #d66f2e; border-color: #c06021; }
        #actions-menu-section .btn-blacksmithing:hover { background-color: #e8823f; }
        .btn-combat { background-color: #c9302c; border-color: #ac2925; } /* Made general */
        .btn-combat:hover { background-color: #e04440; }
        #actions-menu-section .btn-eat { background-color: #4cae4c; border-color: #459c45; }
        #actions-menu-section .btn-eat:hover { background-color: #5cb85c; }
        #actions-menu-section .btn-cook {
            background-color: #eea236;
            border-color: #d58d20;
        }
        #actions-menu-section .btn-cook:hover { background-color: #f0ad4e; }
        #actions-menu-section .btn-build-structures { background-color: #795548; border-color: #6a4a3e; }
        #actions-menu-section .btn-build-structures:hover { background-color: #8d6e63; }

        #shop-menu-section .btn-buy-tools {
            background-color: #d4af37;
            /* color: #3e300b; Inherited */
            border-color: #c09d31;
        }
        #shop-menu-section .btn-buy-tools:hover { background-color: #e6c350; }
        #shop-menu-section .btn-sell-items {
            background-color: #a7b0b9;
            /* color: #2a2d30; Inherited */
            border-color: #979fa6;
        }
        #shop-menu-section .btn-sell-items:hover { background-color: #c1c8cf; }

        #blacksmithing-menu-section .btn-smelt-bars { background-color: #e07a5f; border-color: #ca6b50; }
        #blacksmithing-menu-section .btn-smelt-bars:hover { background-color: #f28c70; }
        #blacksmithing-menu-section .btn-smith-weapons { background-color: #8d6e63; border-color: #7b5f55; }
        #blacksmithing-menu-section .btn-smith-weapons:hover { background-color: #a18278; }

        /* New Styles for Build Structures Section */
        .structure-item-card {
            display: flex;
            flex-direction: column;
            border: 1px solid #3b475c; /* Slightly darker, more distinct border */
            border-left: 5px solid #63b3ed; /* Accent color */
            padding: 15px;
            margin-bottom: 15px;
            background-color: #2a313f; /* Darker card background */
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .structure-item-card h3 { /* Name and Emoji */
            margin-top: 0;
            margin-bottom: 10px;
            color: #90cdf4; /* Lighter blue for title */
            display: flex;
            align-items: center;
            font-size: 1.2em;
        }
        .structure-item-card h3 .emoji {
            font-size: 1.6em; /* Larger emoji */
            margin-right: 12px;
        }
        .structure-item-card .built-status {
            font-size: 0.85em;
            margin-left: 10px;
            font-weight: normal;
        }
        .structure-item-card .description { /* Perk description */
            font-style: italic;
            color: #b0c4de; /* Lighter grey/blue for description */
            margin-bottom: 12px;
            font-size: 0.95em;
        }
        .structure-item-card .requirements-block { /* Cost and Prerequisite */
            background-color: #212733; /* Even darker for requirements block */
            padding: 12px;
            border-radius: 3px;
            margin-bottom: 12px;
            font-size: 0.9em;
        }
        .structure-item-card .requirements-block h4 { margin-top: 0; margin-bottom: 8px; color: #a0aec0; }
        .structure-item-card .requirements-block p { margin: 4px 0; color: #e2e8f0; }
        .structure-item-card .requirements-block .cost-item-name { color: #cbd5e0; }
        .structure-item-card .actions { /* Button or Locked Text */
            margin-top: 10px;
        }
        /* Style for built structure cards */
        .built-structure-card { border-left-color: #6a9955 !important; background-color: #2a3f2e !important; }
        .built-structure-card h3 { color: #8cc877 !important; } /* Make title green too */

        .glow-green-temp {
            background-color: #0e9c18 !important; /* Strong green */
            border-color: #33ff33 !important;
            box-shadow: 0 0 15px #33ff33, 0 0 8px #33ff33 inset !important; /* Green glow */
            color: white !important;
            transition: background-color 0.1s ease-out, box-shadow 0.1s ease-out, border-color 0.1s ease-out;
        }
        /* New Styles for Perk Tree Section */
        .perk-item-card {
            display: flex;
            flex-direction: column;
            border: 1px solid #4a3b5c; /* Perk-themed border */
            border-left: 5px solid #c586c0; /* Perk accent color (magenta) */
            padding: 15px;
            margin-bottom: 15px;
            background-color: #2d2a3f; /* Darker purple/magenta card background */
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .perk-item-card .perk-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        .perk-item-card .perk-name {
            color: #d993d3; /* Lighter magenta for title */
            font-size: 1.15em;
            font-weight: bold;
        }
        .perk-item-card .perk-cost-display {
            background-color: #1c1a25;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 0.9em;
            color: #e2e8f0;
        }
        .perk-item-card .perk-description {
            color: #b0c4de;
            margin-top: 2px;
            margin-bottom: 2px; /* Further reduced spacing below description */
            font-size: 0.95em;
        }
        .perk-item-card .perk-status-action { margin-top: 2px; } /* Further reduced spacing above action/button */
        .perk-item-card .perk-status-action { margin-bottom: 2px; }
        .perk-item-card .fore-green { margin: 2px;}
        .perk-item-card .perk-status-action .status-tet { font-style: italic; font-size: 0.9em; }
        .perk-item-card.activated-perk-card { border-left-color: #6a9955; background-color: #2a3f2e; } /* Greenish for activated */
        .perk-item-card.activated-perk-card .perk-name { color: #8cc877; }
        /* Style for the activate button within perk cards */
        .perk-item-card .perk-status-action button {
            background-color: #c586c0; /* Match .btn-perks base color */
            border: 1px solid #b373ac;   /* Match .btn-perks base border color */
            padding: 4px 5px; /* Further reduced padding to make button more compact */
            font-size: 0.9em;  /* Make font smaller */
            font-weight: bold; /* Ensure font weight is consistent */
            transition: background-color 0.2s ease, border-color 0.2s ease, transform 0.2s ease; /* Smooth transition */
        }
        .perk-item-card .perk-status-action button:hover {
            background-color: #d993d3; /* Match .btn-perks hover color */
            border-color: #d993d3;   /* Lighter border on hover */
            transform: scale(1.03); /* Slight zoom effect on hover */
        }
        .perk-item-card.disabled-perk-card { opacity: 0.7; }

        /* Guild Member Card Specifics */
        .guild-member-card {
            border: 1px solid #4a4a52;
            background-color: #2c2c32; 
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            position: relative; /* Needed for z-indexing and absolute positioning of fill */
        }
        .guild-member-card.on-task {
            overflow: hidden; /* To clip the fill bar's corners */
            /* The base background-color of .guild-member-card will be the "empty" part of the bar */
        }
        /* This is the fill div *inside* the guild-member-card */
        .guild-member-card > .member-task-progress-bar-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background-color: #4ec9b0; /* Cyan for fill */
            width: 0%;
            transition: width 0.5s ease-out;
            z-index: 1; /* Behind info and controls */
            border-radius: 0; /* Card itself has border-radius */
        }

        .member-info {
            display: flex;
            justify-content: space-between;
            align-items: flex-start; /* Align to top */
            flex-wrap: wrap; /* Allow status to wrap if needed */
            position: relative; /* To stay on top of progress fill */
            z-index: 2;
            /* Card already has padding, so info div doesn't need extra unless desired */
        }
        .member-details { /* Wrapper for name/level/xp */
            /* flex-grow: 1; /* Allow it to take most space */
            margin-right: 10px; /* Space between details and status */
        }
        .member-status {
            font-style: italic;
            font-size: 0.9em;
            text-align: right;
            white-space: nowrap; /* Try to keep status on one line */
            /* Make font bold for better readability over the progress bar */
            font-weight: bold;
        }
        .guild-member-card .member-task-controls { /* Controls for "Return Early" */
            position: relative;
            z-index: 2;
            text-align: center;
            padding-top: 8px; /* Space above the button */
        }
        .member-action-panel { /* Panel with Gather/Mine/Hunt buttons */
            position: relative; /* Ensure it's also on top if card is somehow 'on-task' styled */
            z-index: 2;
            margin-top: 8px;
        }
        .member-action-button { 
            padding: 4px 8px; font-size: 0.85em; margin: 2px;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="top-controls">
            <button onclick="exportSaveData()" title="Download current game progress to a file">Save Game</button>
            <input type="file" id="import-file-input" accept=".json,.txt" style="display: none;" onchange="handleImportFile(event)">
            <button onclick="document.getElementById('import-file-input').click()" title="Load game progress from a previously saved file">Load Game</button>
        </div>
        <div class="top-right-controls">
             <button id="mute-toggle-btn">Mute Sounds</button>
        </div>

        <div class="hud" id="hud">
            <!-- HUD items will be direct children and grid items -->
            <div id="hud-wc" class="hud-item"></div>          <!-- Col 1, Row 1 -->
            <div id="hud-atk" class="hud-item"></div>         <!-- Col 2, Row 1 -->
            <div id="hud-mn" class="hud-item"></div>          <!-- Col 1, Row 2 -->
            <div id="hud-gold" class="hud-item"></div>        <!-- Col 2, Row 2 -->
            <div id="hud-ck" class="hud-item"></div>          <!-- Col 1, Row 3 -->
            <div id="hud-perk-points" class="hud-item"></div> <!-- Col 2, Row 3 -->
            <div id="hud-bs" class="hud-item"></div>          <!-- Col 1, Row 4 -->
            <div id="hud-hp" class="hud-item"></div>          <!-- Col 2, Row 4 (HP Bar) -->
        </div>

        <div id="main-menu-section" class="section">
            <div class="section-title-header">
                <div class="section-title-text">Main Menu</div>
            </div>
            <div class="main-menu-buttons-container">
                <button class="btn-char-info" onclick="showCharacterInfo()"><span class="button-icon"></span><span class="button-label">Character Info</span></button>
                <button class="btn-inventory" onclick="showInventory()"><span class="button-icon"></span><span class="button-label">Inventory & Equipment</span></button>
                <button class="btn-actions" onclick="showActionsMenu()"><span class="button-icon"></span><span class="button-label">Actions</span></button>
                <button class="btn-shop" onclick="showShopMenu()"><span class="button-icon"></span><span class="button-label">Shop</span></button>
                <button class="btn-perks" onclick="showPerkTreeMenu()"><span class="button-icon"></span><span class="button-label">Perks</span></button>
                <button id="btn-guild" class="hidden" onclick="showGuildMenu()"><span class="button-icon"></span><span class="button-label">Guild</span></button> <!-- New Guild Button -->
            </div>
            <div class="section-footer-controls main-menu-footer-controls">
                <div class="cheat-code-container">
                    <input type="text" id="cheat-input" placeholder="Cheat code"><button id="button-apply-cheat" onclick="applyCheat()">Apply</button>
                </div>
            </div>
        </div>

        <div id="character-info-section" class="section hidden">
            <div class="section-title-header">
                <button class="btn-back-header" onclick="showMainMenu()" title="Back to Main Menu"></button>
                <div class="section-title-text fore-cyan">Character Information</div>
            </div>
            <div id="char-info-details"></div>
            <div id="char-info-permits" style="margin-top:10px;">
                <h4 style="margin-bottom: 5px; border-bottom: 1px solid #444; padding-bottom: 3px;">Active Permits:</h4>
                <div id="active-permits-list"></div>
            </div>
            <p>Total XP Gained (All Skills): <span id="total-xp-all-skills" class="fore-magenta">0</span></p>
            <div class="section-footer-controls">
                <button onclick="showMainMenu()"><span class="button-icon"></span><span class="button-label">Back</span></button>
            </div>
        </div>
        
        <div id="inventory-section" class="section hidden">
            <div class="section-title-header">
                <button class="btn-back-header" onclick="showMainMenu()" title="Back to Main Menu"></button>
                <div class="section-title-text fore-magenta">Inventory</div>
            </div>
            <div class="inventory-sort-controls" id="inventory-sort-controls">
                <button class="inventory-sort-button" id="sort-inv-default" onclick="setInventorySort('default')">Sort</button>
                <button class="inventory-sort-button" id="sort-inv-name" onclick="setInventorySort('name')">Name</button>
                <button class="inventory-sort-button" id="sort-inv-quantity" onclick="setInventorySort('quantity')">Quantity</button>
                <button class="inventory-sort-button" id="sort-inv-value_single" onclick="setInventorySort('value_single')">Value/Item</button>
                <button class="inventory-sort-button" id="sort-inv-value_stack" onclick="setInventorySort('value_stack')">Value/Stack</button>
            </div>
            <div id="inventory-list"></div>
            <hr>
            <div class="section-title-text fore-cyan" style="margin-top:15px; padding-bottom: 5px; border-bottom: 1px solid #555; margin-bottom:10px;">Equipped Gear</div>
            <div id="equipment-display">
                <div class="slot"><span class="slot-name">Weapon:</span><span class="item-name" id="eq-weapon-name">None</span><span class="item-art" id="eq-weapon-art"></span> <span id="eq-weapon-stats" style="font-size:0.9em; color:#aaa;"></span></div>
                <!-- Slots will be populated by JavaScript -->
            </div>
            <div id="item-selection-for-equip" class="hidden">
                <div class="section-title-header" style="border-bottom:none; margin-bottom:5px;"> <!-- Less margin for this sub-title -->
                    <div class="section-title-text" id="equip-item-type-title">Equip Item</div>
                </div>
                <div id="equip-item-list"></div>
                <button onclick="hideEquipSelection()">Cancel</button>
            </div>
            <div class="section-footer-controls">
                <button onclick="showMainMenu()"><span class="button-icon"></span><span class="button-label">Back to Main Menu</span></button>
            </div>
        </div>

        <div id="actions-menu-section" class="section hidden">
            <div class="section-title-header">
                <button class="btn-back-header" onclick="showMainMenu()" title="Back to Main Menu"></button>
                <div class="section-title-text">Actions Menu</div>
            </div>
            <div class="submenu-buttons-container"> 
                <button class="btn-woodcutting" onclick="showWoodcutting()"><span class="button-icon"></span><span class="button-label">Woodcutting</span></button>
                <button class="btn-mining" onclick="showMining()"><span class="button-icon"></span><span class="button-label">Mining</span></button>
            </div>
            <div class="submenu-buttons-container"> 
                <button class="btn-blacksmithing" onclick="showBlacksmithingMenu()"><span class="button-icon"></span><span class="button-label">Blacksmithing</span></button>
                <button class="btn-combat" onclick="showCombat()"><span class="button-icon"></span><span class="button-label">Attack Monsters</span></button>
            </div>
            <div class="submenu-buttons-container"> 
                <button class="btn-eat" onclick="showEatFood()"><span class="button-icon"></span><span class="button-label">Eat Food</span></button>
                <button class="btn-cook" onclick="showCookFood()"><span class="button-icon"></span><span class="button-label">Cook Food</span></button>
                <button class="btn-build-structures" onclick="showBuildStructuresMenu()"><span class="button-icon"></span><span class="button-label">Build Structures</span></button>
            </div>
            <div class="section-footer-controls">
                <button onclick="showMainMenu()"><span class="button-icon"></span><span class="button-label">Back to Main Menu</span></button>
            </div>
        </div>

        <div id="shop-menu-section" class="section hidden">
            <div class="section-title-header">
                <button class="btn-back-header" onclick="showMainMenu()" title="Back to Main Menu"></button>
                <div class="section-title-text fore-green">Store</div>
            </div>
            <div id="shop-gold-display" class="fore-yellow"></div>
            <div class="submenu-buttons-container">
                <button class="btn-buy-tools" onclick="showBuyMenu()">1. Buy Tools</button>
                <button class="btn-sell-items" onclick="showSellMenu()">2. Sell Items</button>
                <button class="btn-buy-permits" onclick="showBuyPermitsMenu()">3. Buy Permits</button>
            </div>
            <div class="section-footer-controls">
                <button onclick="showMainMenu()"><span class="button-icon"></span><span class="button-label">Back to Main Menu</span></button>
            </div>
        </div>
        
        <div id="buy-menu-section" class="section hidden">
            <div class="section-title-header">
                <button class="btn-back-header" onclick="showShopMenu()" title="Back to Shop Menu"></button>
                <div class="section-title-text fore-green">Buy Items</div>
            </div>
            <div id="buy-category-selection" class="submenu-buttons-container">
                 <button onclick="populateShopItems('axe', 'Axes')">Axes</button>
                 <button onclick="populateShopItems('pickaxe', 'Pickaxes')">Pickaxes</button>
            </div>
            <div id="shop-items-list"></div>
            <div class="section-footer-controls">
                <button onclick="showShopMenu()"><span class="button-icon"></span><span class="button-label">Back to Shop</span></button>
            </div>
        </div>

        <div id="sell-menu-section" class="section hidden">
            <div class="section-title-header">
                <button class="btn-back-header" onclick="showShopMenu()" title="Back to Shop Menu"></button>
                <div class="section-title-text fore-green">Sell Items</div>
            </div>
            <div id="sellable-items-list"></div>
            <div class="section-footer-controls">
                <button onclick="showShopMenu()"><span class="button-icon"></span><span class="button-label">Back to Shop</span></button>
            </div>
        </div>
        
        <!-- New Section for Buying Permits -->
        <div id="buy-permits-section" class="section hidden">
            <div class="section-title-header">
                <button class="btn-back-header" onclick="showShopMenu()" title="Back to Shop Menu"></button>
                <div class="section-title-text fore-green">Buy Permits</div>
            </div>
            <div id="permits-for-sale-list"></div>
            <div class="section-footer-controls">
                <button onclick="showShopMenu()"><span class="button-icon"></span><span class="button-label">Back to Shop</span></button>
            </div>
        </div>


        <div id="woodcutting-section" class="section hidden">
            <div class="section-title-header">
                <button class="btn-back-header" onclick="showActionsMenu()" title="Back to Actions Menu"></button>
                <div class="section-title-text fore-green">Woodcutting</div>
            </div>
            <div id="woodcutting-permit-status" class="fore-cyan" style="font-size:0.9em; margin-bottom:10px;">
                <!-- Permit status will be populated here -->
            </div>
            <div id="available-trees"></div>
            <div class="section-footer-controls">
                <button onclick="showActionsMenu()"><span class="button-icon"></span><span class="button-label">Back to Actions</span></button>
            </div>
        </div>
        
        <div id="mining-section" class="section hidden">
            <div class="section-title-header">
                <button class="btn-back-header" onclick="showActionsMenu()" title="Back to Actions Menu"></button>
                <div class="section-title-text fore-lightblack_ex">Mining</div>
            </div>
            <div id="mining-permit-status" class="fore-cyan" style="font-size:0.9em; margin-bottom:10px;">
                <!-- Permit status will be populated here -->
            </div>
            <div id="available-ores"></div>
            <div class="section-footer-controls">
                <button onclick="showActionsMenu()"><span class="button-icon"></span><span class="button-label">Back to Actions</span></button>
            </div>
        </div>
        
        <div id="blacksmithing-menu-section" class="section hidden">
            <div class="section-title-header">
                <button class="btn-back-header" onclick="showActionsMenu()" title="Back to Actions Menu"></button>
                <div class="section-title-text fore-orange">Blacksmithing</div>
            </div>
            <div class="submenu-buttons-container">
                <button class="btn-smelt-bars" onclick="showSmeltingMenu()">1. Smelt Bars</button>
                <button class="btn-smith-weapons" onclick="showSmithingMenu()">2. Smith Weapons</button>
            </div>
            <div class="section-footer-controls">
                <button onclick="showActionsMenu()"><span class="button-icon"></span><span class="button-label">Back to Actions</span></button>
            </div>
        </div>

        <div id="smelting-section" class="section hidden">
            <div class="section-title-header">
                <button class="btn-back-header" onclick="showBlacksmithingMenu()" title="Back to Blacksmithing Menu"></button>
                <div class="section-title-text fore-orange">Smelt Bars</div>
            </div>
            <div id="available-bars-to-smelt"></div>
            <div class="section-footer-controls">
                <button onclick="showBlacksmithingMenu()"><span class="button-icon"></span><span class="button-label">Back to Blacksmithing</span></button>
            </div>
        </div>

        <div id="smithing-section" class="section hidden">
            <div class="section-title-header">
                <button class="btn-back-header" onclick="showBlacksmithingMenu()" title="Back to Blacksmithing Menu"></button>
                <div class="section-title-text fore-orange">Smith Items</div>
            </div>
            <div id="available-items-to-smith"></div>
            <div class="section-footer-controls">
                <button onclick="showBlacksmithingMenu()"><span class="button-icon"></span><span class="button-label">Back to Blacksmithing</span></button>
            </div>
        </div>

        <div id="build-structures-section" class="section hidden">
            <div class="section-title-header">
                <button class="btn-back-header" onclick="showActionsMenu()" title="Back to Actions Menu"></button>
                <div class="section-title-text fore-blue">Build Structures</div>
            </div>
            <div id="available-structures-list"></div>
            <div class="section-footer-controls">
                <button onclick="showActionsMenu()"><span class="button-icon"></span><span class="button-label">Back to Actions</span></button>
            </div>
        </div>

        <div id="combat-section" class="section hidden">
            <div class="section-title-header">
                <button class="btn-back-header" onclick="stopCombatAndReturn()" title="Back to Actions Menu"></button>
                <div class="section-title-text fore-red">Combat</div>
            </div>
            <div id="combat-permit-status" class="fore-cyan" style="font-size:0.9em; margin-bottom:10px;">
                <!-- Permit status will be populated here -->
            </div>
            <div id="available-monsters"></div>
            <div id="combat-arena" class="hidden">
                <div id="monster-display-combat" class="monster-display"></div>
                <div>Player HP: <span id="player-hp-combat" class="fore-green"></span></div>
            </div>
            <div class="section-footer-controls">
                <button onclick="stopCombatAndReturn()"><span class="button-icon"></span><span class="button-label">Back to Actions</span></button>
            </div>
        </div>
        
        <div id="eat-food-section" class="section hidden">
            <div class="section-title-header">
                <button class="btn-back-header" onclick="showActionsMenu()" title="Back to Actions Menu"></button>
                <div class="section-title-text fore-green">Eat Food</div>
            </div>
             <div id="available-food-list"></div>
            <div class="section-footer-controls">
                <button onclick="showActionsMenu()"><span class="button-icon"></span><span class="button-label">Back to Actions</span></button>
            </div>
        </div>

        <div id="cook-food-section" class="section hidden">
            <div class="section-title-header">
                <button class="btn-back-header" onclick="showActionsMenu()" title="Back to Actions Menu"></button>
                <div class="section-title-text fore-yellow">Cook Food</div>
            </div>
            <div id="cookable-items-list"></div>
            <div class="section-footer-controls">
                <button onclick="showActionsMenu()"><span class="button-icon"></span><span class="button-label">Back to Actions</span></button>
            </div>
        </div>

        <div id="perk-tree-section" class="section hidden">
            <div class="section-title-header">
                <button class="btn-back-header" onclick="showMainMenu()" title="Back to Main Menu"></button>
                <div class="section-title-text fore-magenta">Perk Tree</div>
            </div>
            <p>Available Perk Points: <span id="available-perk-points" class="fore-magenta">0</span></p>
            <div id="perk-list"></div>
            <div class="section-footer-controls">
                <button onclick="showMainMenu()"><span class="button-icon"></span><span class="button-label">Back to Main Menu</span></button>
            </div>
        </div>

        <!-- New Guild Menu Section -->
        <div id="guild-menu-section" class="section hidden">
            <div class="section-title-header">
                <button class="btn-back-header" onclick="showMainMenu()" title="Back to Main Menu"></button>
                <div class="section-title-text fore-magenta">Guild Hall</div>
            </div>
            <p>Welcome, Guild Master <span id="guild-master-name" class="fore-yellow">PlayerName</span>!</p>
            <p>Guild Name: <span id="guild-name-display" class="fore-yellow">PlayerName's Guild</span> (Level <span id="guild-level-display" class="fore-yellow">1</span>)</p>
            <p>Guild XP: <span id="guild-xp-display" class="fore-yellow">0</span></p>
            <p>Members: <span id="guild-member-count" class="fore-yellow">0</span> / <span id="guild-member-capacity-display" class="fore-yellow">1</span></p>

            <div class="submenu-buttons-container">
                <button onclick="showGuildMembersScreen()">Manage Members</button>
                <button onclick="showGuildUpgradesScreen()">Guild Hall Upgrades</button>
                <button onclick="showGuildStashScreen()">View Guild Stash</button> <!-- New Button -->
                <button onclick="showGuildMissionsScreen()">Missions</button>
            </div>
            <div id="guild-details-area" style="margin-top: 15px; padding: 10px; border: 1px solid #444; background-color: #2a2a2d;">
                <p><i>Guild management features are under construction. More to come!</i></p>
            </div>
        </div>

        <!-- New Guild Members Screen -->
        <div id="guild-members-section" class="section hidden">
            <div class="section-title-header">
                <button class="btn-back-header" onclick="showGuildMenu()" title="Back to Guild Hall"></button>
                <div class="section-title-text fore-magenta">Manage Guild Members</div>
            </div>
            <p>Current Members: <span id="current-member-display-count">0</span> / <span id="current-member-display-capacity">1</span> (Max Potential: 10)</p>
            <div id="guild-member-list" style="margin-bottom: 15px;">
                <!-- Member cards will be populated here -->
            </div>

            <div id="recruit-member-area">
                <!-- Recruitment button and info will be populated here -->
            </div>

            <div class="section-footer-controls">
                <button onclick="showGuildMenu()"><span class="button-icon"></span><span class="button-label">Back to Guild Hall</span></button>
            </div>
        </div>

        <!-- New Guild Stash Screen -->
        <div id="guild-stash-section" class="section hidden">
            <div class="section-title-header">
                <button class="btn-back-header" onclick="showGuildMenu()" title="Back to Guild Hall"></button>
                <div class="section-title-text fore-magenta">Guild Stash</div>
                <div class="section-header-actions">
                    <button id="transfer-all-stash-btn" class="yellow" onclick="transferAllItemsFromGuildStashToPlayer()">Transfer All to Player</button>
                </div>
            </div>
            <div id="guild-stash-list">
                <!-- Stash items will be populated here -->
            </div>
            <div class="section-footer-controls">
                <button onclick="showGuildMenu()"><span class="button-icon"></span><span class="button-label">Back to Guild Hall</span></button>
            </div>
        </div>


        <div class="log-area" id="log-area">Welcome to the Adventure!</div>

        <div style="text-align: center; padding-top: 20px; border-top: 1px solid #444; margin-top:20px;">
            <button class="red" onclick="confirmResetGame()">Reset All Progress</button>
        </div>
    </div>

    <script>
        // --- Sound Effects ---
        const monsterKillSound = new Audio('sounds/attack.Hard.mp3'); 
        monsterKillSound.volume = 0.1;
        const playerDieSound = new Audio('sounds/backround1.mp3'); 
        playerDieSound.volume = 0.5;
        const sellItemSound = new Audio('sounds/sell_item.wav'); 
        const skillRoundSound = new Audio('sounds/chop.mp3'); 
        skillRoundSound.volume = 0.1;
        const levelUpSound = new Audio('sounds/ding.mp3'); 
        // const buildStructureSound = new Audio('sounds/build_structure.wav'); // Example

        let soundsMuted = false;

        function playSound(sound) {
            if (soundsMuted) return;
            if (sound && typeof sound.play === 'function') {
                sound.currentTime = 0;
                sound.play().catch(e => console.warn("Sound play prevented:", e));
            }
        }

        function toggleMute() {
            soundsMuted = !soundsMuted;
            const muteButton = document.getElementById('mute-toggle-btn');
            muteButton.textContent = soundsMuted ? "Unmute Sounds" : "Mute Sounds";
            localStorage.setItem('textAdventureSoundsMuted', soundsMuted.toString());
            logMessage(soundsMuted ? "Sounds Muted" : "Sounds Unmuted", "fore-cyan");
        }
        

        // --- Data Structures ---
        const BASE_GATHER_INTERVAL = 2200; // Was 1200
        const BASE_CRAFT_INTERVAL = 2200;  // Was 1200
        const BASE_COMBAT_INTERVAL = 3000; // Was 2000
        

        const LEVEL_PROGRESSION = [0];
        let _points = 0;
        for (let _lvl_idx = 1; _lvl_idx < 99; _lvl_idx++) {
            _points += Math.floor(_lvl_idx * 1.5 + 300 * (2**(_lvl_idx / 6.5)));
            const _xp_to_reach_level = Math.floor(_points / 4);
            LEVEL_PROGRESSION.push(_xp_to_reach_level);
        }

        const TOOL_DATA = {
            "axe": {
                "fists":   {"emoji": "",    "price":0,     "level_req":1,  "min_dmg":1,  "max_dmg":1,  "skill_type":"attack",      "color":"fore-white", "tier": "fists",
                    "yield_config": { "base": 0, "bonuses_by_tree": {"normal":[], "oak":[], "willow":[]} }
                },
                "bronze":  {"emoji": "",    "price":15,    "level_req":1,  "min_dmg":1,  "max_dmg":2,  "skill_type":"woodcutting", "color":"fore-yellow", "tier": "bronze",
                    "yield_config": { "base": 1, "bonuses_by_tree": {
                        "normal": [{ "chance": 0.20, "amount": 1 }],
                        "oak":    [{ "chance": 0.05, "amount": 1 }]
                    }}
                },
                "iron":    {"emoji": "",    "price":50,    "level_req":15, "min_dmg":2,  "max_dmg":3,  "skill_type":"woodcutting", "color":"fore-lightblack_ex", "tier": "iron",
                    "yield_config": { "base": 1, "bonuses_by_tree": {
                        "normal": [{ "chance": 0.70, "amount": 1 }],
                        "oak":    [{ "chance": 0.25, "amount": 1 }]
                    }}
                },
                "steel":   {"emoji": "",    "price":120,   "level_req":30, "min_dmg":3,  "max_dmg":5,  "skill_type":"woodcutting", "color":"fore-cyan", "tier": "steel",
                    "yield_config": { "base": 1, "bonuses_by_tree": {
                        "normal": [{ "chance": 0.85, "amount": 1 }, { "chance": 0.35, "amount": 1 }],
                        "oak":    [{ "chance": 0.80, "amount": 1 }, { "chance": 0.30, "amount": 1 }],
                        "willow": [{ "chance": 0.75, "amount": 1 }, { "chance": 0.25, "amount": 1 }]
                    }}
                },
                "mithril": {"emoji": "",    "price":300,   "level_req":45, "min_dmg":5,  "max_dmg":8,  "skill_type":"woodcutting", "color":"fore-blue", "tier": "mithril",
                    "yield_config": { "base": 2, "bonuses_by_tree": {
                        "normal": [{ "chance": 0.80, "amount": 1 }],
                        "oak":    [{ "chance": 0.70, "amount": 1 }],
                        "willow": [{ "chance": 0.60, "amount": 1 }]
                    }}
                },
                "adamant": {"emoji": "",    "price":750,   "level_req":60, "min_dmg":8,  "max_dmg":12, "skill_type":"woodcutting", "color":"fore-green", "tier": "adamant",
                    "yield_config": { "base": 2, "bonuses_by_tree": {
                        "normal": [{ "chance": 0.90, "amount": 1 }, { "chance": 0.50, "amount": 1 }],
                        "oak":    [{ "chance": 0.85, "amount": 1 }, { "chance": 0.45, "amount": 1 }],
                        "willow": [{ "chance": 0.80, "amount": 1 }, { "chance": 0.40, "amount": 1 }]
                    }}
                },
                "rune":    {"emoji": "",    "price":2000,  "level_req":75, "min_dmg":12, "max_dmg":18, "skill_type":"woodcutting", "color":"fore-magenta", "tier": "rune",
                    "yield_config": { "base": 2, "bonuses_by_tree": {
                        "normal": [{ "chance": 0.95, "amount": 1 }, { "chance": 0.75, "amount": 1 }],
                        "oak":    [{ "chance": 0.90, "amount": 1 }, { "chance": 0.70, "amount": 1 }],
                        "willow": [{ "chance": 0.85, "amount": 1 }, { "chance": 0.65, "amount": 1 }]
                    }}
                },
                "dragon":  {"emoji": "",  "price":10000, "level_req":90, "min_dmg":18, "max_dmg":25, "skill_type":"woodcutting", "color":"fore-red", "tier": "dragon",
                    "yield_config": { "base": 3, "bonuses_by_tree": {
                        "normal": [{ "chance": 0.90, "amount": 1 }, { "chance": 0.60, "amount": 1 }],
                        "oak":    [{ "chance": 0.85, "amount": 1 }, { "chance": 0.55, "amount": 1 }],
                        "willow": [{ "chance": 0.80, "amount": 1 }, { "chance": 0.50, "amount": 1 }]
                    }}
                }
            },
            "pickaxe": {
                "bronze":  {"emoji": "",    "price":10,    "level_req":1,  "min_dmg":1,  "max_dmg":2,  "skill_type":"mining", "color":"fore-yellow",        "tier": "bronze",  "yield_config": { "base": 1, "bonuses": [{ "chance": 0.15, "amount": 1 }] } },
                "iron":    {"emoji": "",    "price":40,    "level_req":15, "min_dmg":2,  "max_dmg":3,  "skill_type":"mining", "color":"fore-lightblack_ex", "tier": "iron",    "yield_config": { "base": 1, "bonuses": [{ "chance": 0.60, "amount": 1 }] } },
                "steel":   {"emoji": "",    "price":100,   "level_req":30, "min_dmg":3,  "max_dmg":5,  "skill_type":"mining", "color":"fore-cyan",          "tier": "steel",   "yield_config": { "base": 1, "bonuses": [{ "chance": 0.75, "amount": 1 }, { "chance": 0.25, "amount": 1 }] } },
                "mithril": {"emoji": "",    "price":280,   "level_req":45, "min_dmg":5,  "max_dmg":8,  "skill_type":"mining", "color":"fore-blue",          "tier": "mithril", "yield_config": { "base": 2, "bonuses": [{ "chance": 0.50, "amount": 1 }] } },
                "adamant": {"emoji": "",    "price":700,   "level_req":60, "min_dmg":8,  "max_dmg":12, "skill_type":"mining", "color":"fore-green",         "tier": "adamant", "yield_config": { "base": 2, "bonuses": [{ "chance": 0.70, "amount": 1 }, { "chance": 0.35, "amount": 1 }] } },
                "rune":    {"emoji": "",    "price":1900,  "level_req":75, "min_dmg":12, "max_dmg":18, "skill_type":"mining", "color":"fore-magenta",       "tier": "rune",    "yield_config": { "base": 2, "bonuses": [{ "chance": 0.85, "amount": 1 }, { "chance": 0.65, "amount": 1 }] } },
                "dragon":  {"emoji": "",  "price":9500,  "level_req":90, "min_dmg":18, "max_dmg":25, "skill_type":"mining", "color":"fore-red",           "tier": "dragon",  "yield_config": { "base": 3, "bonuses": [{ "chance": 0.75, "amount": 1 }, { "chance": 0.45, "amount": 1 }] } }
            }
        };
        
        const SWORD_DATA = {
            "bronze 2h sword":   {"emoji": "",   "smith_level_req":1,  "wield_level_req":1,  "min_dmg":5,   "max_dmg":8,   "skill_type":"attack", "color":"fore-yellow",        "lifesteal_chance": 0.02, "lifesteal_amount": 1,     "recipe": {"bronze bar": 5}},
            "iron 2h sword":     {"emoji": "",   "smith_level_req":15, "wield_level_req":15, "min_dmg":10,  "max_dmg":16,  "skill_type":"attack", "color":"fore-lightblack_ex", "lifesteal_chance": 0.03, "lifesteal_amount": [1,2], "recipe": {"iron bar": 5}},
            "steel 2h sword":    {"emoji": "",   "smith_level_req":30, "wield_level_req":30, "min_dmg":18,  "max_dmg":28,  "skill_type":"attack", "color":"fore-cyan",          "lifesteal_chance": 0.04, "lifesteal_amount": [2,3], "recipe": {"steel bar": 5}},
            "mithril 2h sword":  {"emoji": "",   "smith_level_req":45, "wield_level_req":45, "min_dmg":30,  "max_dmg":45,  "skill_type":"attack", "color":"fore-blue",          "lifesteal_chance": 0.05, "lifesteal_amount": [2,4], "recipe": {"mithril bar": 5}},
            "adamant 2h sword":  {"emoji": "",   "smith_level_req":60, "wield_level_req":60, "min_dmg":48,  "max_dmg":70,  "skill_type":"attack", "color":"fore-green",         "lifesteal_chance": 0.06, "lifesteal_amount": [3,5], "recipe": {"adamantite bar": 5}},
            "rune 2h sword":     {"emoji": "",   "smith_level_req":75, "wield_level_req":75, "min_dmg":72,  "max_dmg":100, "skill_type":"attack", "color":"fore-magenta",       "lifesteal_chance": 0.07, "lifesteal_amount": [4,6], "recipe": {"runite bar": 5}},
            "dragon 2h sword":   {"emoji": "", "smith_level_req":90, "wield_level_req":90, "min_dmg":100, "max_dmg":140, "skill_type":"attack", "color":"fore-red",           "lifesteal_chance": 0.08, "lifesteal_amount": [5,8], "recipe": {"dragon bar": 5}}
        };


        const FOOD_DATA = {
            "cooked meat":       {"heal_amount": 5,  "sell_price": 2, "emoji": ""}, 
            "bread":             {"heal_amount": 3,  "sell_price": 1, "emoji": ""},
            "health potion (s)": {"heal_amount": 15, "sell_price": 10, "emoji": ""}
        };

        const COOKABLE_ITEMS = {
            "raw meat": {"cooked_item":"cooked meat", "burnt_item":"burnt meat", "xp_gain":10, "level_req":1, "difficulty_level":1, "emoji": ""},
        };
        
        const ARMOR_DATA = {
            "bronze chestplate":  {"defense":0.03, "price":40,    "level_req":5,  "color":"fore-yellow",        "emoji":""},
            "iron chestplate":    {"defense":0.06, "price":100,   "level_req":15, "color":"fore-lightblack_ex", "emoji":""},
            "steel chestplate":   {"defense":0.09, "price":250,   "level_req":30, "color":"fore-cyan",          "emoji":""},
            "mithril chestplate": {"defense":0.12, "price":600,   "level_req":45, "color":"fore-blue",          "emoji":""},
            "adamant chestplate": {"defense":0.15, "price":1500,  "level_req":60, "color":"fore-green",         "emoji":""},
            "rune chestplate":    {"defense":0.18, "price":5000,  "level_req":75, "color":"fore-magenta",       "emoji":""},
            "dragon chestplate":  {"defense":0.22, "price":20000, "level_req":90, "color":"fore-red",           "emoji":""}
        };
        
        const BAR_DATA = {
            "bronze bar":     {"emoji": "<span class='fore-yellow'></span>",   "level_req": 1,  "xp_gain": 10,  "color": "fore-yellow",        "recipe": {"copper ore": 1, "tin ore": 1}},
            "iron bar":       {"emoji": "<span class='fore-lightblack_ex'></span>",   "level_req": 15, "xp_gain": 20,  "color": "fore-lightblack_ex", "recipe": {"iron ore": 1}},
            "steel bar":      {"emoji": "<span class='fore-white'></span>",   "level_req": 30, "xp_gain": 30,  "color": "fore-cyan",          "recipe": {"iron ore": 1, "coal": 2}},
            "mithril bar":    {"emoji": "<span class='fore-blue'></span>",   "level_req": 45, "xp_gain": 50,  "color": "fore-blue",          "recipe": {"mithril ore": 1, "coal": 4}},
            "adamantite bar": {"emoji": "<span class='fore-green'></span>",   "level_req": 60, "xp_gain": 70,  "color": "fore-green",         "recipe": {"adamantite ore": 1, "coal": 6}},
            "runite bar":     {"emoji": "<span class='fore-magenta'></span>",   "level_req": 75, "xp_gain": 100, "color": "fore-magenta",       "recipe": {"runite ore": 1, "coal": 8}},
            "dragon bar":     {"emoji": "<span class='fore-red'></span>", "level_req": 90, "xp_gain": 150, "color": "fore-red",           "recipe": {"special dragon ore": 1, "coal": 10}}
        };

        const ORE_DATA = { 
            "copper":    {"level_req": 1,  "xp": 15,  "item_name": "copper ore",     "color": "fore-orange", "emoji": "<span class='fore-orange'></span>"},
            "tin":       {"level_req": 1,  "xp": 15,  "item_name": "tin ore",        "color": "fore-lightblack_ex", "emoji": "<span class='fore-lightblack_ex'></span>"},
            "iron":      {"level_req": 15, "xp": 35,  "item_name": "iron ore",       "color": "fore-white",  "emoji": "<span class='fore-white'></span>"},
            "coal":      {"level_req": 30, "xp": 40,  "item_name": "coal",           "color": "fore-lightblack_ex", "emoji": "<span class='fore-lightblack_ex'></span>", "required_pickaxe_tier": "steel"},
            "mithril":   {"level_req": 45, "xp": 80,  "item_name": "mithril ore",    "color": "fore-blue",   "emoji": "<span class='fore-blue'></span>", "required_pickaxe_tier": "steel"},
            "adamantite":{"level_req": 60, "xp": 120, "item_name": "adamantite ore", "color": "fore-green",  "emoji": "<span class='fore-green'></span>", "required_pickaxe_tier": "steel"},
            "runite":    {"level_req": 75, "xp": 200, "item_name": "runite ore",     "color": "fore-magenta","emoji": "<span class='fore-magenta'></span>", "required_pickaxe_tier": "steel"},
            "special dragon ore": {"level_req": 90, "xp":300,"item_name":"special dragon ore","color":"fore-red","emoji":"<span class='fore-red'></span>", "required_pickaxe_tier": "steel"}
        };
        
        const STRUCTURE_DATA = {
            "camp": {
                name: "Camp", emoji: "",
                cost: { "normal logs": 100 },
                perk_desc: "+5% chance for an extra base log/ore from Woodcutting/Mining.",
                perk_effect: { type: "base_gather_yield_bonus", value: 0.05 },
                requires_structure: null, 
                rent_value: 0 
            },
            "shed": {
                name: "Shed", emoji: "",
                cost: { "normal logs": 500, "oak logs": 100 },
                perk_desc: "All crafting actions (Cooking, Smelting, Smithing) are 10% faster.",
                perk_effect: { type: "crafting_speed_boost", value: 0.10 },
                requires_structure: "camp",
                rent_value: 1 
            },
            "cabin": {
                name: "Cabin", emoji: "",
                cost: { "oak logs": 1000, "willow logs": 200, "bronze bar": 50 },
                perk_desc: "Increases Max HP by +10.",
                perk_effect: { type: "max_hp_bonus", value: 10 },
                requires_structure: "shed",
                rent_value: 5 
            },
            "house": {
                name: "House", emoji: "",
                cost: { "willow logs": 2500, "iron bar": 300, "bronze bar": 100 },
                perk_desc: "Increases all Skill XP gain by +2%. Also grants a 5% chance for non-chicken monsters to drop bonus gold equal to 10% of their base gold drop (stacks with Mansion).",
                perks: [ 
                    { type: "global_xp_boost", value: 0.02 },
                    { type: "scaled_bonus_mob_gold_drop_chance", value: 0.05, bonus_gold_percentage_of_base: 0.10 }
                ],
                requires_structure: "cabin",
                rent_value: 15 
            },
            "lumberMill": {
                name: "Lumber Mill",
                emoji: "",
                cost: { "willow logs": 1500, "steel bar": 100, "oak logs": 3000, "gold": 100000 },
                perk_desc: "Allows continuous woodcutting even when your Woodcutting skill levels up. Also enables the House to generate +5 gold every 5 minutes.",
                requires_structure: "house",
                rent_value: 5 // This is the rent the HOUSE now generates due to the Lumber Mill.
            },
            "mansion": {
                name: "Mansion", emoji: "",
                cost: { "willow logs": 5000, "steel bar": 200, "coal": 100 },
                perk_desc: "Grants a 10% chance for monster kills to drop double their normal gold amount.",
                perks: [
                    { type: "monster_gold_drop_multiplier_chance", value: 0.10, multiplier: 2 }
                ],
                requires_structure: "house",
                rent_value: 40 
            },
            "castle": {
                name: "Castle", emoji: "",
                cost: { "willow logs": 10000, "mithril bar": 300, "adamantite bar": 100 },
                perk_desc: "Shop purchase prices -5%, item sell prices +5%.",
                perk_effect: { type: "shop_price_modifier", buy_mod: -0.05, sell_mod: 0.05 },
                requires_structure: "mansion",
                rent_value: 100 
            },
            "stronghold": {
                name: "The Stronghold", emoji: "",
                cost: {
                    "willow logs": 25000, 
                    "oak logs": 10000,
                    "normal logs": 5000,
                    "bronze bar": 500,
                    "iron bar": 400,
                    "steel bar": 300,
                    "mithril bar": 250,
                    "adamantite bar": 200,
                    "runite bar": 150,
                    "dragon bar": 100,
                    "dragon gem": 5, 
                    "demon heart": 10 
                }, // Perk description updated below
                perk_desc: "A bastion of ultimate power. Grants +10% to all damage dealt, +25 Max HP, heals 5% of Max HP on monster kill, and all skill actions are 10% faster.",
                perks: [
                    { type: "global_damage_boost", value: 0.10 },
                    { type: "max_hp_bonus_flat", value: 25 }, 
                    { type: "heal_on_kill_percent", value: 0.05 },
                    { type: "global_skill_speed_boost", value: 0.10 }
                ],
                requires_structure: "castle", 
                rent_value: 250
            }
        };
        const RENT_COLLECTION_INTERVAL = 5 * 60 * 1000; // 5 minutes

        const DEFAULT_PLAYER = {
            "name":"PlayerOne","woodcutting_xp":0,"attack_xp":0,"mining_xp":0,"cooking_xp":0, "blacksmithing_xp":0,
            "hp":10,"gold":10, "total_skill_xp": 0, "perk_points_earned": 0, "perk_points_spent": 0, "active_perks": {},
            "inventory": {
                "weapon":"none","axe":"none","pickaxe":"none","chestplate":"none", 
                "normal logs":0,"oak logs":0,"willow logs":0,
                "copper ore":0,"tin ore":0,"iron ore":0,"coal":0,"mithril ore":0,"adamantite ore":0,"runite ore":0,"special dragon ore":0,
                "bronze bar":0,"iron bar":0, "steel bar":0, "mithril bar":0, "adamantite bar":0, "runite bar":0, "dragon bar":0,
                "egg":0,"goblin beads":0,"dragon gem":0,
                "raw meat":0,"cooked meat":0,"bread":0,"burnt meat":0,"health potion (s)":0,
                "wolf fang":0,"bear claw":0,"ogre club fragment":0,"troll hide":0,"giant's toe":0,"demon heart":0,
            },
            "built_structures": {
                "camp": false, "shed": false, "cabin": false, "house": false, "mansion": false, "castle": false, "stronghold": false,
                "lumberMill": false
            },
            "permits": { // NEW: Added permits to DEFAULT_PLAYER
                "hunter": false,
                "miner": false,
                "blacksmith": false,
                "woodcutter": false // Added for consistency, though not used yet by a permit
            },
            "last_rent_collection_time": 0,
            // Guild System - NG+
            "guild_unlocked": false,
            "guild_level": 1,
            "guild_xp": 0,
            "guild_name": "PlayerOne's Guild",
            "guild_members": [],
            "guild_stash": {}, // Will be initialized like inventory
            "guild_member_capacity": 1,
            "guild_hall_upgrades": { "barracks_level": 0, "forge_level": 0, "mission_board_level": 0 },
            // current_task for members will be initialized when they are recruited
        };
        Object.keys(ARMOR_DATA).forEach(armor_name => {
            if (!(armor_name in DEFAULT_PLAYER.inventory)) DEFAULT_PLAYER.inventory[armor_name] = 0;
        });
        Object.keys(SWORD_DATA).forEach(sword_name => {
            if (!(sword_name in DEFAULT_PLAYER.inventory)) DEFAULT_PLAYER.inventory[sword_name] = 0;
        });
        // Initialize guild_stash similar to inventory (empty)
        DEFAULT_PLAYER.guild_stash = JSON.parse(JSON.stringify(DEFAULT_PLAYER.inventory));
        // Ensure all default inventory keys are also in guild_stash, initialized to 0 or "none"
        for (const itemKey in DEFAULT_PLAYER.inventory) {
            if (!(itemKey in DEFAULT_PLAYER.guild_stash)) {
                // For 'weapon', 'axe', etc., it should be "none", for others 0
                DEFAULT_PLAYER.guild_stash[itemKey] = (typeof DEFAULT_PLAYER.inventory[itemKey] === 'string') ? "none" : 0;
            }
        }


        const ITEM_SELL_PRICES = {
            "normal logs":1,"oak logs":3,"willow logs":5,
            "copper ore":2,"tin ore":3,"iron ore":5,"coal":4,"mithril ore":10,"adamantite ore":20,"runite ore":50,"special dragon ore":100,
            "bronze bar": 8, "iron bar": 15, "steel bar": 30, "mithril bar": 70, "adamantite bar": 150, "runite bar": 300, "dragon bar": 750,
            "egg":1,"goblin beads":10,"dragon gem":30000,
            "raw meat":1,"burnt meat":0,
            "wolf fang":15,"bear claw":30,"ogre club fragment":70,"troll hide":120,"giant's toe":250,"demon heart":500,
        };
        for (const food_name in FOOD_DATA) ITEM_SELL_PRICES[food_name] = FOOD_DATA[food_name].sell_price;
        for (const armor_name in ARMOR_DATA) ITEM_SELL_PRICES[armor_name] = Math.floor(ARMOR_DATA[armor_name].price*0.4);
        for (const sword_name in SWORD_DATA) { 
            let totalBarCost = 0;
            for(const bar in SWORD_DATA[sword_name].recipe){
                totalBarCost += (ITEM_SELL_PRICES[bar] || (BAR_DATA[bar] ? BAR_DATA[bar].level_req * 5 : 0) ) * SWORD_DATA[sword_name].recipe[bar];
            }
            ITEM_SELL_PRICES[sword_name] = Math.floor(totalBarCost * 0.8); 
        }
        
        const MONSTER_DATA = { 
            "chicken":     {"name":"Chicken", "level_req":1,  "hp":5,    "attack_xp":5,   "gold_drop": [0,1], "color":"fore-white", "emoji":"", "drops":[{"item_name":"egg","base_chance":0.9, "quantity":[1,2], "always_drop_one":true},{"item_name":"raw meat","base_chance":0.7, "quantity":[1,1]}]},
            "goblin":      {"name":"Goblin", "level_req":5,  "hp":20,   "attack_xp":15,  "gold_drop": [1,5], "color":"fore-green", "emoji":"", "drops":[{"item_name":"goblin beads","base_chance":0.5, "quantity":[1,1]},{"item_name":"bread","base_chance":0.2, "quantity":[1,1]}, {"item_name":"bronze chestplate",  "base_chance":0.02, "quantity":[1,1]}]},
            "wolf":        {"name":"Wolf", "level_req":10, "hp":35,   "attack_xp":25,  "gold_drop": [3,8], "color":"fore-lightblack_ex", "emoji":"", "drops":[{"item_name":"raw meat","base_chance":0.8, "quantity":[1,2]},{"item_name":"wolf fang","base_chance":0.3, "quantity":[1,1]}]},
            "bear":        {"name":"Bear", "level_req":20, "hp":70,   "attack_xp":50,  "gold_drop": [10,25],"color":"fore-yellow","emoji":"", "drops":[{"item_name":"raw meat","base_chance":0.9, "quantity":[2,3]},{"item_name":"bear claw","base_chance":0.25, "quantity":[1,1]},{"item_name":"cooked meat","base_chance":0.1, "quantity":[1,1]}, {"item_name":"iron chestplate",    "base_chance":0.025, "quantity":[1,1]}]},
            "ogre":        {"name":"Ogre", "level_req":30, "hp":120,  "attack_xp":90,  "gold_drop": [20,50],"color":"fore-green", "emoji":"", "drops":[{"item_name":"ogre club fragment","base_chance":0.4, "quantity":[1,1]},{"item_name":"cooked meat","base_chance":0.3, "quantity":[1,2]}, {"item_name":"steel chestplate",   "base_chance":0.03, "quantity":[1,1]}]},
            "troll":       {"name":"Troll", "level_req":40, "hp":200,  "attack_xp":150, "gold_drop": [40,100],"color":"fore-cyan","emoji":"", "drops":[{"item_name":"troll hide","base_chance":0.35, "quantity":[1,1]},{"item_name":"health potion (s)","base_chance":0.15, "quantity":[1,1]}, {"item_name":"mithril chestplate", "base_chance":0.02, "quantity":[1,1]}]},
            "giant":       {"name":"Giant", "level_req":55, "hp":350,  "attack_xp":280, "gold_drop": [75,150],"color":"fore-blue","emoji":"", "drops":[{"item_name":"giant's toe","base_chance":0.2, "quantity":[1,1]},{"item_name":"cooked meat","base_chance":0.5, "quantity":[2,4]}, {"item_name":"adamant chestplate", "base_chance":0.025, "quantity":[1,1]}]},
            "demon":       {"name":"Demon", "level_req":70, "hp":500,  "attack_xp":500, "gold_drop": [150,300],"color":"fore-magenta","emoji":"", "drops":[{"item_name":"demon heart","base_chance":0.04, "quantity":[1,1]},{"item_name":"health potion (s)","base_chance":0.3, "quantity":[1,2]}, {"item_name":"rune chestplate",    "base_chance":0.015, "quantity":[1,1]}]},
            "dark_dragon": {"name":"Dark Dragon", "level_req":85, "hp":1200, "attack_xp":2500,"gold_drop": [500,2000],"color":"fore-red","emoji":"", "drops":[{"item_name":"dragon gem","base_chance":0.02, "quantity":[1,1]},{"item_name":"health potion (s)","base_chance":0.5, "quantity":[2,3]}, {"item_name":"dragon chestplate",  "base_chance":0.01, "quantity":[1,1]}, {"item_name":"special dragon ore", "base_chance":0.1, "quantity":[1,2]}]}
        };
        const ALL_MONSTER_NAMES = Object.keys(MONSTER_DATA);
        const ALL_ORE_NAMES = Object.keys(ORE_DATA);

        const PICKAXE_TIER_ORDER = ["bronze", "iron", "steel", "mithril", "adamant", "rune", "dragon"];
        const AXE_TIER_ORDER = ["fists", "bronze", "iron", "steel", "mithril", "adamant", "rune", "dragon"];
        const TREE_DATA = { 
            "normal": {"exp":10, "log":"normal logs", "level":1,  "emoji": ""},
            "oak":    {"exp":25, "log":"oak logs",    "level":15, "emoji": ""},
            "willow": {"exp":55, "log":"willow logs", "level":30, "emoji": "", "required_axe_tier": "steel"}
        };
        
        const MAX_PERK_POINTS = 25;
        const PERK_POINT_XP_THRESHOLDS = []; 
        function calculateCumulativeXpThresholds() {
            let current_cumulative_xp = 0;
            for (let i = 0; i < MAX_PERK_POINTS; i++) {
                let increment;
                if (i === 0) increment = 1000;
                else if (i === 1) increment = 2500;
                else increment = 2500 + (i - 1) * 1000; 
                
                current_cumulative_xp += increment;
                PERK_POINT_XP_THRESHOLDS.push(current_cumulative_xp);
            }
        }
        calculateCumulativeXpThresholds(); 

        const PERK_DATA = {
            "efficientGatherer1": {
                id: "efficientGatherer1", name: "Efficient Gatherer I",
                description: "Woodcutting and Mining actions are 10% faster.",
                cost: 1, tier: 1, type: "gathering_speed_boost", value: 0.10, requires: []
            },
            "weaponMaster1": {
                id: "weaponMaster1", name: "Weapon Master I",
                description: "2H Swords you wield deal +10% damage.",
                cost: 1, tier: 1, type: "sword_damage_boost", value: 0.10, requires: []
            },
            "preciseStrikes1": {
                id: "preciseStrikes1", name: "Precise Strikes I",
                description: "Gain a 5% chance to deal 1.5x damage in combat.",
                cost: 1, tier: 1, type: "crit_chance_boost", value: 0.05, crit_multiplier: 1.5, requires: []
            },
            "vampiricEdge1": {
                id: "vampiricEdge1", name: "Vampiric Edge I",
                description: "2H Swords you wield gain +1% lifesteal chance.",
                cost: 2, tier: 2, type: "sword_lifesteal_boost", value: 0.01, requires: ["weaponMaster1"]
            },
             "advancedSmelting": {
                id: "advancedSmelting", name: "Advanced Smelting",
                description: "10% chance to smelt an extra bar (doesn't consume extra ore).",
                cost: 2, tier: 2, type: "bonus_smelt_chance", value: 0.10, requires: []
            },
            "masterSmith": {
                id: "masterSmith", name: "Master Smith",
                description: "Smithing 2H swords requires 1 less bar (minimum 1 bar).",
                cost: 3, tier: 3, type: "smithing_bar_reduction", value: 1, requires: ["vampiricEdge1", "advancedSmelting"]
            },
            "combatSustenance": {
                id: "combatSustenance", name: "Combat Sustenance",
                description: "Automatically consumes the best available food when HP drops to 20% or below during combat.",
                cost: 5, tier: 3, type: "auto_eat_combat", value: 0.20, requires: ["vampiricEdge1"]
            },
            "masterGuildCharter": { // NEW PERK
                id: "masterGuildCharter", name: "Master Guild Charter",
                description: "Unlock New Game+! Resets progress but grants Guild Leadership and retains earned Perk Points. Requires 1,000,000 Gold & Level 75 in all core skills to activate its power.",
                cost: 5, // Cost to "learn" the charter
                tier: 4, // Highest tier
                type: "master_guild_charter", requires: ["masterSmith", "combatSustenance"]
            },
        };

        const GUILD_MEMBER_NAMES = [
            "Valerius", "Lyra", "Marcus", "Seraphina", "Orion",
            "Astrid", "Gideon", "Elara", "Jasper", "Rowena"
        ];
        const MAX_GUILD_MEMBERS = 10;

        // XP Progression for Guild Members (can be simpler or same as player for now)
        const GUILD_MEMBER_LEVEL_PROGRESSION = [0];
        let _gm_points = 0;
        for (let _gm_lvl_idx = 1; _gm_lvl_idx < 99; _gm_lvl_idx++) { // Assuming max level 99 for progression table
            _gm_points += Math.floor(_gm_lvl_idx * 2.5 + 400 * (2**(_gm_lvl_idx / 6.0))); // Increased base and exponential factor
            GUILD_MEMBER_LEVEL_PROGRESSION.push(Math.floor(_gm_points / 3)); // Adjusted divisor
        }

        const GUILD_MEMBER_TASK_DURATION_MS = 8 * 60 * 60 * 1000; // 8 hours for active task
        const GUILD_MEMBER_TASK_TICK_INTERVAL_MS = 5 * 1000; // Check for drops every 5 seconds

        const GUILD_MEMBER_LOOT_TABLES = {
            wood: {
                // Tiered by member level. Chance: 0-1. Higher level = better chance for higher tier.
                // For each tick, one category (common, uncommon, rare) is chosen based on weighted random.
                // Then one item from that category.
                // Example: Member Level 15.
                // Base chance for common: 0.6, uncommon: 0.3, rare: 0.1
                // Level bonus might shift these weights.
                categories: [
                    { name: "common", minMemberLevel: 1, items: [{ item: "normal logs", minQty: 1, maxQty: 3 }] },
                    { name: "uncommon", minMemberLevel: 10, items: [{ item: "oak logs", minQty: 1, maxQty: 2 }] },
                    { name: "rare", minMemberLevel: 20, items: [{ item: "willow logs", minQty: 1, maxQty: 1 }] }
                ]
            },
            mining: {
                categories: [
                    { name: "common", minMemberLevel: 1, items: [{ item: "copper ore", minQty: 1, maxQty: 3 }, { item: "tin ore", minQty: 1, maxQty: 2 }] },
                    { name: "uncommon", minMemberLevel: 10, items: [{ item: "iron ore", minQty: 1, maxQty: 2 }] },
                    { name: "rare", minMemberLevel: 15, items: [{ item: "coal", minQty: 1, maxQty: 2 }] }
                ]
            },
            hunting: { // Simplified: one item per category for now
                categories: [
                    { name: "common", minMemberLevel: 1, items: [{ item: "raw meat", minQty: 1, maxQty: 2 }] },
                    { name: "uncommon", minMemberLevel: 5, items: [{ item: "egg", minQty: 1, maxQty: 1 }, { item: "goblin beads", minQty: 1, maxQty: 1, minLevelReqForDrop: 10 }] }, // goblin beads need higher member level
                    { name: "rare", minMemberLevel: 15, items: [{ item: "wolf fang", minQty: 1, maxQty: 1 }] }
                ]
            }
        };

        // --- Global Game State ---
        let playerData = {};
        let currentSection = 'main-menu-section';
        
        let isAutoAttacking = false;
        let autoAttackInterval = null;
        let currentMonsterTarget = null;
        let currentMonsterHP = 0;
        
        let isAutoWoodcutting = false;
        let autoWoodcuttingInterval = null;
        let currentWoodcuttingTarget = null;

        let isAutoMining = false;
        let autoMiningInterval = null;
        let currentMiningTarget = null;

        let isAutoCooking = false;
        let autoCookingInterval = null;
        let currentCookingTarget = null;

        let isAutoSmelting = false;
        let autoSmeltingInterval = null;
        let currentSmeltingTarget = null; 
        let maxSmeltableForCurrentTarget = 0;


        let isAutoSmithing = false;
        let autoSmithingInterval = null;
        let currentSmithingTarget = null; 

        let rentInterval = null;

        // --- Global Game State for Inventory Sorting ---
        let currentInventorySort = 'default';
        const DEFAULT_ITEM_ORDER = Object.keys(DEFAULT_PLAYER.inventory); // For default sort order


        // --- Utility Functions ---
        function getLevelFromXp(xp) {
            for (let i = LEVEL_PROGRESSION.length - 1; i >= 0; i--) {
                if (xp >= LEVEL_PROGRESSION[i]) return i + 1;
            }
            return 1;
        }

        function getXpForDisplay(totalXp, currentLevel) {
            if (currentLevel >= 99) {
                const xpAtLevelStart = LEVEL_PROGRESSION[98];
                const currentProgressInLevel = totalXp - xpAtLevelStart;
                return `${currentProgressInLevel} / --- (Max Level)`;
            }
            const xpAtLevelStart = LEVEL_PROGRESSION[currentLevel - 1];
            const xpForNextLevelTotal = LEVEL_PROGRESSION[currentLevel];
            const currentProgressInLevel = totalXp - xpAtLevelStart;
            const xpNeededForThisLevelUp = xpForNextLevelTotal - xpAtLevelStart;
            return `${currentProgressInLevel} / ${xpNeededForThisLevelUp}`;
        }

        function getMaxHp(attackLevel) {
            let baseMaxHp = 10 + (attackLevel - 1);
            if (playerData && playerData.built_structures && playerData.built_structures.cabin) {
                baseMaxHp += STRUCTURE_DATA.cabin.perk_effect.value;
            }
            if (playerData && playerData.built_structures && playerData.built_structures.stronghold) {
                const strongholdHpPerk = STRUCTURE_DATA.stronghold.perks.find(p => p.type === "max_hp_bonus_flat");
                if (strongholdHpPerk) {
                    baseMaxHp += strongholdHpPerk.value;
                }
            }

            return baseMaxHp;
        }

        function logMessage(message, colorClass = "fore-white", emoji = "") {
            const logArea = document.getElementById('log-area');
            const D = new Date();
            const timestamp = `${D.getHours().toString().padStart(2,'0')}:${D.getMinutes().toString().padStart(2,'0')}:${D.getSeconds().toString().padStart(2,'0')}`;
            const emojiSpan = emoji ? `<span class="log-emoji">${emoji}</span> ` : "";
            logArea.innerHTML = `<span class="${colorClass}">${timestamp} - ${emojiSpan}${message}</span>\n` + logArea.innerHTML;
            if (logArea.children.length > 50) { 
                logArea.removeChild(logArea.lastChild);
            }
        }
        
        function capitalize(str) {
            if (!str) return '';
            return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
        }
        
        function titleCase(str) {
            if (!str) return '';
            return str.toLowerCase().split(' ').map(word => capitalize(word)).join(' ');
        }

        function formatDurationHHMMSS(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }



        function grantUniversalXP(amount) {
            let actualAmount = amount;
            if (playerData && playerData.built_structures && playerData.built_structures.house && STRUCTURE_DATA.house.perks) {
                STRUCTURE_DATA.house.perks.forEach(perk => {
                    if (perk.type === "global_xp_boost") {
                        actualAmount *= (1 + perk.value);
                    }
                });
            }
            playerData.total_skill_xp = (playerData.total_skill_xp || 0) + Math.floor(actualAmount);
            updatePerkPoints();
        }


        function updatePerkPoints() {
            let new_points_earned = 0;
            for (const threshold of PERK_POINT_XP_THRESHOLDS) {
                if (playerData.total_skill_xp >= threshold) new_points_earned++;
                else break; 
            }
            if (new_points_earned > playerData.perk_points_earned) {
                const gained = new_points_earned - playerData.perk_points_earned;
                logMessage(`You earned ${gained} new Perk Point(s)! (${playerData.total_skill_xp.toLocaleString()} total XP)`, "fore-magenta");
                playerData.perk_points_earned = new_points_earned;
            }
            // updateHud is usually called after this, or this calls updateHud. Let's ensure it's consistent.
            // No, updateHud is separate. This is fine.
        }
        
        function setupSkillXpBar(containerElement, iconHtml, skillLevel, skillXp, levelProgressionArray, tooltipText, levelTextColorClass) {
            containerElement.innerHTML = ''; // Clear previous
            containerElement.classList.add('hud-skill-xp-bar'); // Add the base class for styling

            const fillDiv = document.createElement('div');
            fillDiv.className = 'hud-xp-bar-fill'; // Specific color will be applied via CSS #id .hud-xp-bar-fill
            containerElement.appendChild(fillDiv);

            const textDiv = document.createElement('div');
            textDiv.className = 'hud-xp-bar-text';

            let xpPercent = 0;
            let levelDisplayText = `${skillLevel}`;

            if (skillLevel >= 99) {
                xpPercent = 100;
                levelDisplayText = `${skillLevel} (Max)`;
                fillDiv.classList.add('full');
            } else {
                const xpAtLevelStart = levelProgressionArray[skillLevel - 1];
                const xpForNextLevelTotal = levelProgressionArray[skillLevel]; // XP needed to REACH (i.e., complete) skillLevel
                const currentProgressInLevel = skillXp - xpAtLevelStart;
                const xpNeededForThisLevelUp = xpForNextLevelTotal - xpAtLevelStart;

                if (xpNeededForThisLevelUp > 0) {
                    xpPercent = (currentProgressInLevel / xpNeededForThisLevelUp) * 100;
                } else { 
                    xpPercent = 0; // Should ideally not happen if not max level
                }
                
                if (xpPercent >= 100) fillDiv.classList.add('full'); else fillDiv.classList.remove('full');
                // levelDisplayText is already set to just the skillLevel for non-max levels
            }

            fillDiv.style.width = `${Math.max(0, Math.min(100, xpPercent))}%`;

            textDiv.innerHTML = `
                <span class="hud-icon">${iconHtml}<span class="tooltip-text">${tooltipText}</span></span>
                <span class="hud-skill-level-text ${levelTextColorClass}">${levelDisplayText}</span>
            `;
            containerElement.appendChild(textDiv);
        }

        function isPerkActive(perkId) {
            return !!playerData.active_perks[perkId];
        }


        // --- Player Data Management & Save/Load/Reset ---
        function migratePlayerData(data) {
            let dataChanged = false;
            const skills = ["woodcutting", "attack", "mining", "cooking", "blacksmithing"]; 
            skills.forEach(skill => {
                const xpField = `${skill}_xp`;
                if (!(xpField in data)) { data[xpField] = 0; dataChanged = true; }
            });
            
            if (!("total_skill_xp" in data)) { data.total_skill_xp = 0; dataChanged = true; }
            if (!("perk_points_earned" in data)) { data.perk_points_earned = 0; dataChanged = true; }
            if (!("perk_points_spent" in data)) { data.perk_points_spent = 0; dataChanged = true; }
            if (!("active_perks" in data) || typeof data.active_perks !== 'object') { data.active_perks = {}; dataChanged = true; }


            if (!("hp" in data)) { data.hp = getMaxHp(getLevelFromXp(data.attack_xp || 0)); dataChanged = true; }
            if (!("gold" in data)) { data.gold = DEFAULT_PLAYER.gold; dataChanged = true; }
            if (!("inventory" in data)) { data.inventory = JSON.parse(JSON.stringify(DEFAULT_PLAYER.inventory)); dataChanged = true; }
            else {
                for (const itemKey in DEFAULT_PLAYER.inventory) {
                    if (!(itemKey in data.inventory)) {
                        data.inventory[itemKey] = DEFAULT_PLAYER.inventory[itemKey];
                        dataChanged = true;
                    }
                }
                ["weapon", "axe", "pickaxe", "chestplate"].forEach(slot => {
                    if (data.inventory[slot] === null || data.inventory[slot] === undefined) {
                         data.inventory[slot] = "none"; dataChanged = true;
                    }
                });
                if (typeof data.inventory.fishing_rod === 'string') {
                    delete data.inventory.fishing_rod; dataChanged = true;
                }
                if ("fishing_xp" in data) { delete data.fishing_xp; dataChanged = true;}
            }
            
            if (!("built_structures" in data) || typeof data.built_structures !== 'object') {
                data.built_structures = JSON.parse(JSON.stringify(DEFAULT_PLAYER.built_structures));
                dataChanged = true;
            } else { 
                for (const structKey in DEFAULT_PLAYER.built_structures) { // Ensure all default structure keys exist
                    if (!(structKey in data.built_structures)) {
                        data.built_structures[structKey] = DEFAULT_PLAYER.built_structures[structKey];
                        dataChanged = true;
                    }
                }
            }
            if (!("lumberMill" in data.built_structures)) {
                data.built_structures.lumberMill = false;
                dataChanged = true;
            }
            if (!("last_rent_collection_time" in data)) {
                data.last_rent_collection_time = 0;
                dataChanged = true;
            }
            // NEW: Migration for permits
            if (!("permits" in data) || typeof data.permits !== 'object') {
                data.permits = { hunter: false, miner: false, blacksmith: false };
                dataChanged = true;
            } else {
                if (!("hunter" in data.permits)) { data.permits.hunter = false; dataChanged = true; }
                if (!("miner" in data.permits)) { data.permits.miner = false; dataChanged = true; }
                if (!("blacksmith" in data.permits)) { data.permits.blacksmith = false; dataChanged = true; }
                if (!("woodcutter" in data.permits)) { data.permits.woodcutter = false; dataChanged = true; } // New
            }

            // Guild System Migration
            if (!("guild_unlocked" in data)) { data.guild_unlocked = false; dataChanged = true; }
            if (!("guild_level" in data)) { data.guild_level = 1; dataChanged = true; }
            if (!("guild_xp" in data)) { data.guild_xp = 0; dataChanged = true; }
            if (!("guild_name" in data)) { data.guild_name = (data.name || "PlayerOne") + "'s Guild"; dataChanged = true; }
            if (!("guild_members" in data) || !Array.isArray(data.guild_members)) { data.guild_members = []; dataChanged = true; }
            if (!("guild_stash" in data) || typeof data.guild_stash !== 'object') {
                data.guild_stash = JSON.parse(JSON.stringify(DEFAULT_PLAYER.inventory)); // Initialize empty like inventory
                dataChanged = true;
            } else { // Ensure all default inventory keys exist in guild_stash if it's already an object
                 for (const itemKey in DEFAULT_PLAYER.inventory) {
                    if (!(itemKey in data.guild_stash)) {
                        data.guild_stash[itemKey] = DEFAULT_PLAYER.inventory[itemKey]; // Should be 0 or "none"
                        dataChanged = true;
                    }
                }
            }
            if (!("guild_member_capacity" in data)) { data.guild_member_capacity = 1; dataChanged = true; }
            if (!("guild_hall_upgrades" in data) || typeof data.guild_hall_upgrades !== 'object') {
                data.guild_hall_upgrades = { barracks_level: 0, forge_level: 0, mission_board_level: 0 };
                dataChanged = true;
            }
            // Ensure members have current_task
            if (data.guild_members && Array.isArray(data.guild_members)) {
                data.guild_members.forEach(member => {
                    if (typeof member.current_task === 'undefined') {
                        member.current_task = null; dataChanged = true;
                    }
                });
            }


            return { data, dataChanged };
        }

        function loadPlayerData() {
            const savedData = localStorage.getItem('textAdventurePlayerData');
            // console.log("loadPlayerData: Data read from localStorage on page load:", savedData); 
            if (savedData) {
                try {
                    let parsedData = JSON.parse(savedData);
                    const migrationResult = migratePlayerData(parsedData);
                    playerData = migrationResult.data;
                    if (migrationResult.dataChanged) { 
                        logMessage("Player data migrated to new format.", "fore-yellow");
                        savePlayerData(); 
                    }
                } catch (e) {
                    console.error("Error parsing player data:", e); 
                    logMessage("Error loading saved data. Starting new game.", "fore-red");
                    playerData = JSON.parse(JSON.stringify(DEFAULT_PLAYER)); 
                    savePlayerData(); 
                    console.log("loadPlayerData: playerData set to DEFAULT_PLAYER due to error.");
                }
            } else {
                playerData = JSON.parse(JSON.stringify(DEFAULT_PLAYER)); 
                console.log("loadPlayerData: No saved data found, playerData set to DEFAULT_PLAYER.");
            }
        }

        function savePlayerData() {
            localStorage.setItem('textAdventurePlayerData', JSON.stringify(playerData));
        }

        function exportSaveData() {
            const saveDataString = localStorage.getItem('textAdventurePlayerData');
            if (!saveDataString) {
                logMessage("No save data found to export.", "fore-yellow", "");
                alert("No save data found to export.");
                return;
            }
            const blob = new Blob([saveDataString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'textAdventurePlayerData_' + new Date().toISOString().slice(0, 10) + '.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            logMessage("Game progress saved to " + a.download, "fore-green", "");
            alert("Game progress saved to " + a.download + "\nKeep this file safe to load your game later.");
        }

        function handleImportFile(event) {
            const file = event.target.files[0];
            if (!file) {
                logMessage("No file selected for import.", "fore-yellow", "");
                return;
            }
            // console.log("handleImportFile: File selected:", file.name); 
            const reader = new FileReader();
            reader.onload = function(e) {
                const fileContent = e.target.result;
                // console.log("handleImportFile: File loaded by reader, content length:", fileContent.length); 
                try {
                    const jsonData = JSON.parse(fileContent);
                    // console.log("handleImportFile: JSON parsed successfully."); 

                    if (!jsonData || typeof jsonData.gold === 'undefined' || typeof jsonData.inventory === 'undefined' || typeof jsonData.attack_xp === 'undefined' ) {
                        console.error("handleImportFile: Validation failed - missing core fields (gold, inventory, attack_xp).");
                        throw new Error("File does not appear to be valid player data. Missing core fields (gold, inventory, attack_xp).");
                    }
                    if (typeof jsonData.inventory !== 'object' || jsonData.inventory === null) {
                        console.error("handleImportFile: Validation failed - inventory format incorrect (must be an object).");
                        throw new Error("File does not appear to be valid player data. Inventory format incorrect (must be an object).");
                    }
                    // console.log("handleImportFile: JSON validated. Showing confirm dialog."); 

                    if (confirm("Loading this save will OVERWRITE your current game in this browser. This cannot be undone. Are you sure?")) {
                        // console.log("handleImportFile: User confirmed. Saving to localStorage and reloading."); 
                        // console.log("handleImportFile: Content to be saved:", fileContent); 
                        try {
                            localStorage.setItem('textAdventurePlayerData', fileContent);
                            const verifyRead = localStorage.getItem('textAdventurePlayerData');
                            if (verifyRead === fileContent) {
                                // console.log("handleImportFile: localStorage write verified successfully.");
                                let tempParsedDataForGlobalUpdate = JSON.parse(fileContent);
                                const migrationResultForGlobalUpdate = migratePlayerData(tempParsedDataForGlobalUpdate);
                                playerData = migrationResultForGlobalUpdate.data;
                                // If migrationResultForGlobalUpdate.dataChanged is true, savePlayerData() in quitGame will save the migrated version.

                                logMessage("Game data loaded successfully! Reloading game to apply changes...", "fore-green", "");
                                alert("Game data loaded successfully! The game will now reload.");
                                window.location.reload();
                            } else {
                                console.error("handleImportFile: localStorage write verification FAILED. Data read back does not match data written.");
                                alert("Critical error: Failed to save data to local storage correctly. Load aborted.");
                                logMessage("Load failed: Could not write to local storage (verification failed).", "fore-red", "");
                            }
                        } catch (storageError) {
                            console.error("handleImportFile: Error during localStorage.setItem:", storageError);
                            alert("Error saving data: " + storageError.message + "\nLoad aborted. Check console for details.");
                            logMessage("Load failed: Error writing to local storage: " + storageError.message, "fore-red", "");
                        }
                    } else {
                        console.log("handleImportFile: User cancelled load operation."); // Log cancellation
                        logMessage("Load operation cancelled by user.", "fore-yellow", "");
                    }
                } catch (error) {
                    console.error("handleImportFile: Error during file import process:", error); // Log the full error object
                    logMessage("Load failed: Invalid save file. Error: " + error.message, "fore-red", "");
                    alert("Load failed: The selected file is not a valid save file.\nError: " + error.message);
                }
            };
            reader.onerror = function(err) { // Add err parameter to see details
                console.error("handleImportFile: FileReader error:", err); // Log FileReader errors
                logMessage("Error reading the import file.", "fore-red");
                alert("Error reading the import file.");
            };
            reader.readAsText(file);
            event.target.value = null; 
        }

        function confirmResetGame() {
            if (confirm("Are you sure you want to ERASE ALL current game progress in this browser and start over? This cannot be undone.")) {
                resetGame();
            }
        }

        function resetGame() {
            stopAllAutoActions();
            if(rentInterval) clearInterval(rentInterval); // Stop rent timer

            // Instead of removing, set playerData to a deep copy of DEFAULT_PLAYER and save it.
            playerData = JSON.parse(JSON.stringify(DEFAULT_PLAYER));
            savePlayerData(); // This writes the "zeroed-out" state to localStorage.

            logMessage("All game data has been reset to default. Reloading to start fresh...", "fore-yellow", "");
            alert("All game data has been reset to default. The game will now reload.");
            window.location.reload();
        }

        // --- UI Update Functions ---
        function updateHud() {
            if (!playerData || playerData.attack_xp === undefined) { 
                console.warn("updateHud called before playerData is fully initialized or is malformed.");
                if (!playerData || Object.keys(playerData).length === 0) {
                    loadPlayerData(); 
                    if (!playerData || Object.keys(playerData).length === 0) { 
                        console.error("FATAL: playerData could not be initialized.");
                        alert("Error: Game data is corrupted. Please try resetting the game or importing a valid save.");
                        document.querySelectorAll('button:not(.red):not(#mute-toggle-btn)').forEach(btn => btn.disabled = true);
                        return;
                    }
                }
            }

            const atkLvl = getLevelFromXp(playerData.attack_xp);
            const maxHp = getMaxHp(atkLvl); // getMaxHp will now consider Cabin perk
            playerData.hp = Math.min(playerData.hp, maxHp); 

            const wcLvl = getLevelFromXp(playerData.woodcutting_xp);
            const mnLvl = getLevelFromXp(playerData.mining_xp);
            const ckLvl = getLevelFromXp(playerData.cooking_xp);
            const bsLvl = getLevelFromXp(playerData.blacksmithing_xp); 

            // Woodcutting XP Bar
            const wcContainer = document.getElementById('hud-wc');
            const wcTooltip = `Woodcutting: ${wcLvl} (XP: ${getXpForDisplay(playerData.woodcutting_xp, wcLvl)})`;
            setupSkillXpBar(wcContainer, '', wcLvl, playerData.woodcutting_xp, LEVEL_PROGRESSION, wcTooltip, 'fore-green');

            // Mining XP Bar
            const mnContainer = document.getElementById('hud-mn');
            const mnTooltip = `Mining: ${mnLvl} (XP: ${getXpForDisplay(playerData.mining_xp, mnLvl)})`;
            setupSkillXpBar(mnContainer, '', mnLvl, playerData.mining_xp, LEVEL_PROGRESSION, mnTooltip, 'fore-lightblack_ex');

            // Cooking XP Bar
            const ckContainer = document.getElementById('hud-ck');
            const ckTooltip = `Cooking: ${ckLvl} (XP: ${getXpForDisplay(playerData.cooking_xp, ckLvl)})`;
            setupSkillXpBar(ckContainer, '', ckLvl, playerData.cooking_xp, LEVEL_PROGRESSION, ckTooltip, 'fore-yellow');

            // Blacksmithing XP Bar
            const bsContainer = document.getElementById('hud-bs');
            const bsTooltip = `Blacksmithing: ${bsLvl} (XP: ${getXpForDisplay(playerData.blacksmithing_xp, bsLvl)})`;
            setupSkillXpBar(bsContainer, '', bsLvl, playerData.blacksmithing_xp, LEVEL_PROGRESSION, bsTooltip, 'fore-orange');

            // Attack XP Bar
            const atkContainer = document.getElementById('hud-atk');
            const atkTooltip = `Attack: ${atkLvl} (XP: ${getXpForDisplay(playerData.attack_xp, atkLvl)})`;
            setupSkillXpBar(atkContainer, '', atkLvl, playerData.attack_xp, LEVEL_PROGRESSION, atkTooltip, 'fore-red');

            // Player HP Bar update
            const hpContainer = document.getElementById('hud-hp');
            hpContainer.innerHTML = ''; // Clear previous content

            const fillDiv = document.createElement('div');
            fillDiv.className = 'hud-hp-bar-fill';
            hpContainer.appendChild(fillDiv);

            const textDiv = document.createElement('div');
            textDiv.className = 'hud-hp-bar-text';

            const hpPercent = maxHp > 0 ? (playerData.hp / maxHp) * 100 : 0;
            fillDiv.style.width = Math.max(0, hpPercent) + '%';
            // Moved this line to after hpPercent is calculated
            if (hpPercent >= 100) fillDiv.classList.add('full'); else fillDiv.classList.remove('full');

            textDiv.innerHTML = `
                <span class="hud-icon"><span class="tooltip-text">HP: ${playerData.hp}/${maxHp}</span></span>
                <span class="hud-hp-value-text">${playerData.hp}/${maxHp}</span>
            `;
            // Add or remove low HP warning class
            if (playerData.hp <= maxHp * 0.20 && maxHp > 0) { // Check if HP is 20% or less
                hpContainer.classList.add('hud-hp-low');
            } else {
                hpContainer.classList.remove('hud-hp-low');
            }
            hpContainer.appendChild(textDiv);

            document.getElementById('hud-gold').innerHTML = `<span class="hud-icon"><span class="tooltip-text">Gold: ${playerData.gold.toLocaleString()}</span></span><span class="fore-yellow">${playerData.gold.toLocaleString()}</span>`;
            const availablePerkPoints = (playerData.perk_points_earned || 0) - (playerData.perk_points_spent || 0);
            document.getElementById('hud-perk-points').innerHTML = `<span class="hud-icon"><span class="tooltip-text">Perk Points: ${availablePerkPoints}</span></span><span class="fore-magenta">${availablePerkPoints}</span>`;
        }

        function showSection(sectionId) {
            if(document.getElementById(currentSection)) { // Safety check
                document.getElementById(currentSection).classList.add('hidden');
            }
            const newSection = document.getElementById(sectionId);
            if(newSection) { // Safety check
                newSection.classList.remove('hidden');
                currentSection = sectionId;
                adjustButtonLabels(); // Adjust labels for buttons in the newly shown section
            } else {
                console.error("Attempted to show non-existent section:", sectionId);
                showSection('main-menu-section'); // Fallback
            }
        }

        // --- Button Label Adjustment ---
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function adjustButtonLabels() {
            const buttons = document.querySelectorAll('button');
            buttons.forEach(button => {
                const icon = button.querySelector('.button-icon');
                const label = button.querySelector('.button-label');
                if (icon && label) { // Only process buttons with an icon and a label span
                    button.classList.remove('icon-only'); // Ensure label is visible for measurement
                    if (button.scrollWidth > button.clientWidth + 1) { // +1 for tolerance
                        button.classList.add('icon-only');
                    }
                }
            });
        }
        
        function hideAllActionSubsections() {
            ['woodcutting-section', 'mining-section', 'combat-section', 'eat-food-section', 'cook-food-section', 
             'blacksmithing-menu-section', 'smelting-section', 'smithing-section', 'perk-tree-section',
             'guild-stash-section', // Add new section here
             'build-structures-section' // NEW
            ].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.classList.add('hidden');
            });
        }

        // --- Menu Navigation ---
        function stopAllAutoActions() { 
            stopAutoAttack();
            stopAutoWoodcutting();
            stopAutoMining();
            stopAutoCooking();
            stopAutoSmelting();
            stopAutoSmithing();
        }

        function showMainMenu() { 
            stopAllAutoActions();
            hideAllActionSubsections(); 
            // Conditionally show/hide Guild button
            const guildButton = document.getElementById('btn-guild');
            if (playerData && playerData.guild_unlocked) {
                guildButton.classList.remove('hidden');
            } else {
                guildButton.classList.add('hidden');
            }
            showSection('main-menu-section'); 
        }
        function showCharacterInfo() { 
            const atkLvl = getLevelFromXp(playerData.attack_xp);
            const wcLvl = getLevelFromXp(playerData.woodcutting_xp);
            const mnLvl = getLevelFromXp(playerData.mining_xp);
            const ckLvl = getLevelFromXp(playerData.cooking_xp);
            const bsLvl = getLevelFromXp(playerData.blacksmithing_xp); 
            const maxHp = getMaxHp(atkLvl);
            const detailsDiv = document.getElementById('char-info-details');
            detailsDiv.innerHTML = `
                <p>Name: ${playerData.name}</p>
                <p><span class="char-info-label">Attack Level:</span> <span class="char-info-value fore-red">${atkLvl}</span> <span class="char-info-xp fore-red">(XP: ${getXpForDisplay(playerData.attack_xp, atkLvl)})</span></p>
                <p><span class="char-info-label">Woodcutting Level:</span> <span class="char-info-value fore-green">${wcLvl}</span> <span class="char-info-xp fore-green">(XP: ${getXpForDisplay(playerData.woodcutting_xp, wcLvl)})</span></p>
                <p><span class="char-info-label">Mining Level:</span> <span class="char-info-value fore-lightblack_ex">${mnLvl}</span> <span class="char-info-xp fore-lightblack_ex">(XP: ${getXpForDisplay(playerData.mining_xp, mnLvl)})</span></p>
                <p><span class="char-info-label">Cooking Level:</span> <span class="char-info-value fore-yellow">${ckLvl}</span> <span class="char-info-xp fore-yellow">(XP: ${getXpForDisplay(playerData.cooking_xp, ckLvl)})</span></p>
                <p><span class="char-info-label">Blacksmithing Level:</span> <span class="char-info-value fore-orange">${bsLvl}</span> <span class="char-info-xp fore-orange">(XP: ${getXpForDisplay(playerData.blacksmithing_xp, bsLvl)})</span></p>
                <p><span class="char-info-label">HP:</span> <span class="char-info-value fore-lightred_ex">${playerData.hp}/${maxHp}</span></p>
                <p class="fore-cyan" style="font-size:0.9em; margin-top:10px;">Max HP increases with Attack Level and Cabin/Stronghold. Heal by leveling Attack or eating food.</p>
            `;
            // Populate Active Permits
            const activePermitsListDiv = document.getElementById('active-permits-list');
            activePermitsListDiv.innerHTML = '';
            let hasActivePermits = false;
            if (playerData.permits) {
                for (const permitKey in playerData.permits) {
                    if (playerData.permits[permitKey]) {
                        hasActivePermits = true;
                        activePermitsListDiv.innerHTML += `<p style="margin: 3px 0;"><span class="fore-yellow"> ${titleCase(permitKey)}'s Permit</span></p>`;
                    }
                }
            }
            if (!hasActivePermits) activePermitsListDiv.innerHTML = "<p><i>No active permits.</i></p>";

            document.getElementById('total-xp-all-skills').textContent = (playerData.total_skill_xp || 0).toLocaleString();
            showSection('character-info-section');
        }
        
        function showInventory() {
            populateInventoryDisplay();
            populateEquipmentDisplay();
            showSection('inventory-section');
            hideEquipSelection(); 
        }

        function setInventorySort(sortType) {
            currentInventorySort = sortType;
            localStorage.setItem('textAdventureInventorySort', currentInventorySort); // Save the sort preference
            // Remove active class from all sort buttons
            document.querySelectorAll('.inventory-sort-button').forEach(btn => btn.classList.remove('active-sort'));
            // Add active class to the clicked button
            const activeButton = document.getElementById(`sort-inv-${sortType}`);
            if (activeButton) {
                activeButton.classList.add('active-sort');
            } else {
                console.warn(`Sort button for type '${sortType}' not found.`);
            }
            populateInventoryDisplay(); // Re-populate with new sort
        }

        function showActionsMenu() { 
            stopAllAutoActions();
            showSection('actions-menu-section'); 
        }

        function populateInventoryDisplay() {
            const listDiv = document.getElementById('inventory-list');
            listDiv.innerHTML = '';
            let hasItems = false; // This will be set if we add any item to itemsToDisplay
            // New: Create an array of item objects to sort and display
            let itemsToDisplay = [];

            for (const itemName in playerData.inventory) { // Iterate through player's inventory
                const quantity = playerData.inventory[itemName];
                const isEquippableSlot = ["weapon", "axe", "pickaxe", "chestplate"].includes(itemName);

                // Only process actual items with quantity > 0, not equipped slots
                if (!isEquippableSlot && typeof quantity === 'number' && quantity > 0) {
                    hasItems = true;
                    let emoji = "&nbsp;";
                    let displayItemName = titleCase(itemName);
                    let itemColorClass = "fore-white";
                    let priceLookupKey = itemName; // Used to find sell price for sorting

                    // 1. Specific full names / unique items
                    if (SWORD_DATA[itemName]) {
                        emoji = SWORD_DATA[itemName].emoji || "&nbsp;";
                        itemColorClass = SWORD_DATA[itemName].color || "fore-white";
                        // priceLookupKey is already itemName
                    } else if (ARMOR_DATA[itemName]) {
                        emoji = ARMOR_DATA[itemName].emoji || "&nbsp;";
                        itemColorClass = ARMOR_DATA[itemName].color || "fore-white";
                        // priceLookupKey is already itemName
                    } else if (itemName === "egg") {
                        emoji = "";
                    } else if (itemName === "goblin beads") {
                        emoji = "";
                    } else if (itemName === "dragon gem") {
                        emoji = "<span class='fore-red'></span>";
                    } else if (itemName === "demon heart") {
                        emoji = "<span class='fore-magenta'></span>";
                    } else if (itemName === "burnt meat") {
                        emoji = "  "; // New emoji for burnt meat
                        itemColorClass = "fore-dark-grey";
                    }
                    // 2. Pattern-based (logs, ores)
                    else if (itemName.endsWith(" ore")) {
                        const nameParts = itemName.toLowerCase().split(" ");
                        const baseNameFromParts = nameParts[0];
                        if (ORE_DATA[baseNameFromParts]) {
                            emoji = ORE_DATA[baseNameFromParts].emoji || "&nbsp;";
                            itemColorClass = ORE_DATA[baseNameFromParts].color || "fore-white";
                        }
                    } else if (itemName.endsWith(" logs")) {
                        const nameParts = itemName.toLowerCase().split(" ");
                        const baseNameFromParts = nameParts[0];
                        if (TREE_DATA[baseNameFromParts]) {
                            emoji = TREE_DATA[baseNameFromParts].emoji || "&nbsp;";
                            // Color for logs is often green, but let TREE_DATA define it if it has a color prop
                            itemColorClass = (TREE_DATA[baseNameFromParts] && TREE_DATA[baseNameFromParts].color) ? TREE_DATA[baseNameFromParts].color : "fore-green";
                        }
                    }
                    // 3. Food data
                    else if (FOOD_DATA[itemName]) {
                        emoji = FOOD_DATA[itemName].emoji || "&nbsp;";
                        itemColorClass = (FOOD_DATA[itemName] && FOOD_DATA[itemName].color) ? FOOD_DATA[itemName].color : "fore-green";
                    }
                    // 4. Cookable items (raw forms)
                    else if (COOKABLE_ITEMS[itemName.replace(/s$/, '')]) {
                        const cookableBase = itemName.replace(/s$/, '');
                        if (COOKABLE_ITEMS[cookableBase]) {
                             emoji = COOKABLE_ITEMS[cookableBase].emoji || "&nbsp;";
                             itemColorClass = (COOKABLE_ITEMS[cookableBase] && COOKABLE_ITEMS[cookableBase].color) ? COOKABLE_ITEMS[cookableBase].color : "fore-white";
                        }
                    }
                    // 5. Bar data
                    else if (BAR_DATA[itemName]) {
                        emoji = BAR_DATA[itemName].emoji || "&nbsp;";
                        itemColorClass = BAR_DATA[itemName].color || "fore-white";
                    }
                    // 6. Unequipped tools (inventory key is the material, e.g., "bronze" for "bronze axe")
                    else if (TOOL_DATA.axe[itemName]) { // itemName is "bronze", "iron" etc.
                        const toolData = TOOL_DATA.axe[itemName];
                        emoji = toolData.emoji || "&nbsp;";
                        displayItemName = titleCase(itemName + " Axe");
                        itemColorClass = toolData.color || "fore-white";
                        priceLookupKey = itemName + " axe"; // For ITEM_SELL_PRICES
                    } else if (TOOL_DATA.pickaxe[itemName]) { // itemName is "bronze", "iron" etc.
                        const toolData = TOOL_DATA.pickaxe[itemName];
                        emoji = toolData.emoji || "&nbsp;";
                        displayItemName = titleCase(itemName + " Pickaxe");
                        itemColorClass = toolData.color || "fore-white";
                        priceLookupKey = itemName + " pickaxe"; // For ITEM_SELL_PRICES
                    }

                    // 7. Default fallback emoji if still not found
                    if (emoji === "&nbsp;") {
                        emoji = `<span class='${itemColorClass}'></span>`;
                    }
                    // (Burnt meat color already handled above)

                    const value_single = ITEM_SELL_PRICES[priceLookupKey] || 0;
                    const value_stack = value_single * quantity;

                    itemsToDisplay.push({
                        key: itemName, // Original key from playerData.inventory
                        quantity: quantity,
                        displayName: displayItemName,
                        emoji: emoji,
                        colorClass: itemColorClass,
                        value_single: value_single,
                        value_stack: value_stack
                    });
                }
            }

            // Sorting logic based on currentInventorySort
            if (currentInventorySort === 'name') {
                itemsToDisplay.sort((a, b) => a.displayName.localeCompare(b.displayName));
            } else if (currentInventorySort === 'quantity') {
                itemsToDisplay.sort((a, b) => b.quantity - a.quantity); // Descending
            } else if (currentInventorySort === 'value_single') {
                itemsToDisplay.sort((a, b) => { // Descending, secondary by name
                    if (b.value_single === a.value_single) return a.displayName.localeCompare(b.displayName);
                    return b.value_single - a.value_single;
                });
            } else if (currentInventorySort === 'value_stack') {
                itemsToDisplay.sort((a, b) => { // Descending, secondary by name
                    if (b.value_stack === a.value_stack) return a.displayName.localeCompare(b.displayName);
                    return b.value_stack - a.value_stack;
                });
            } else if (currentInventorySort === 'default') {
                itemsToDisplay.sort((a, b) => {
                    const indexA = DEFAULT_ITEM_ORDER.indexOf(a.key);
                    const indexB = DEFAULT_ITEM_ORDER.indexOf(b.key);
                    if (indexA === -1 && indexB === -1) return a.displayName.localeCompare(b.displayName); // Both not in default, sort by name
                    if (indexA === -1) return 1; // a is not in default, b is; b comes first
                    if (indexB === -1) return -1; // b is not in default, a is; a comes first
                    return indexA - indexB;
                });
            }

            // Render the sorted items
            if (!hasItems) { // If no items were ever pushed to itemsToDisplay
                listDiv.innerHTML = "<p>Your inventory is empty.</p>";
            } else {
                itemsToDisplay.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'item-entry';
                    itemDiv.innerHTML = `<span class="inv-item-emoji">${item.emoji}</span><span class="item-name ${item.colorClass}">${item.displayName}:</span> <span class="item-quantity">${item.quantity.toLocaleString()}</span>`;
                    listDiv.appendChild(itemDiv);
                });
            }
        }


        function populateEquipmentDisplay() {
            const weaponKey = playerData.inventory.weapon;
            const weaponName = weaponKey === "none" ? "None" : titleCase(weaponKey);
            const weaponData = SWORD_DATA[weaponKey];
            const weaponColorClass = weaponData ? weaponData.color : 'fore-white';
            const weaponArt = weaponData ? (weaponData.emoji || "") : "";
            let weaponStatsDisplay = "";

            if (weaponData) {
                let minDmg = weaponData.min_dmg;
                let maxDmg = weaponData.max_dmg;

                // Apply Weapon Master I perk if active
                if (isPerkActive("weaponMaster1")) {
                    minDmg = Math.floor(minDmg * (1 + PERK_DATA.weaponMaster1.value));
                    maxDmg = Math.floor(maxDmg * (1 + PERK_DATA.weaponMaster1.value));
                }
                // Apply Stronghold global damage boost
                if (playerData.built_structures.stronghold) {
                    const strongholdDmgPerk = STRUCTURE_DATA.stronghold.perks.find(p => p.type === "global_damage_boost");
                    if (strongholdDmgPerk) {
                        minDmg = Math.floor(minDmg * (1 + strongholdDmgPerk.value));
                        maxDmg = Math.floor(maxDmg * (1 + strongholdDmgPerk.value));
                    }
                }
                weaponStatsDisplay += `(Dmg: ${minDmg}-${maxDmg}`;
                if (isPerkActive("weaponMaster1") || playerData.built_structures.stronghold) {
                     weaponStatsDisplay += "*"; // Indicate boosted damage
                }
                 weaponStatsDisplay += ")";


                let effectiveLifestealChance = weaponData.lifesteal_chance || 0;
                if (isPerkActive("vampiricEdge1")) {
                    effectiveLifestealChance += PERK_DATA.vampiricEdge1.value;
                }
                if (effectiveLifestealChance > 0) {
                    const lsAmount = Array.isArray(weaponData.lifesteal_amount) ? `${weaponData.lifesteal_amount[0]}-${weaponData.lifesteal_amount[1]}` : weaponData.lifesteal_amount;
                    weaponStatsDisplay += ` (LS: ${(effectiveLifestealChance * 100).toFixed(0)}% for ${lsAmount} HP)`;
                }
            }

            const equipmentDisplayDiv = document.getElementById('equipment-display');
            equipmentDisplayDiv.innerHTML = ''; // Clear previous slots

            // Weapon Slot
            const weaponSlotDiv = document.createElement('div');
            weaponSlotDiv.className = 'slot';
            weaponSlotDiv.innerHTML = `
                <div class="slot-name">Weapon:</div>
                <div class="item-name ${weaponColorClass}">${weaponName}</div>
                <div class="item-art">${weaponArt}</div>
                <div class="item-stats">${weaponStatsDisplay.trim()}</div>
            `;
            const equipWeaponButton = document.createElement('button');
            equipWeaponButton.innerHTML = 'Equip<br>Weapon';
            equipWeaponButton.onclick = () => showEquipSelection('weapon');
            equipWeaponButton.classList.add('btn-combat'); // Attack color (red)
            weaponSlotDiv.appendChild(equipWeaponButton);
            equipmentDisplayDiv.appendChild(weaponSlotDiv);

            // Axe Slot
            const axeKey = playerData.inventory.axe;
            const axeName = axeKey === "none" ? "None" : titleCase(axeKey);
            const axeData = TOOL_DATA.axe[axeKey];
            const axeColorClass = axeData ? axeData.color : 'fore-white';
            const axeArt = axeData ? (axeData.emoji || "") : "";
            let axeStatsDisplay = "";
            if (axeData && axeData.yield_config) {
                axeStatsDisplay += `Base Yield: ${axeData.yield_config.base}`;
                if (axeData.yield_config.bonuses_by_tree) {
                    let treeBonusesStrings = [];
                    for (const treeType in axeData.yield_config.bonuses_by_tree) {
                        const bonuses = axeData.yield_config.bonuses_by_tree[treeType];
                        if (bonuses && bonuses.length > 0) {
                            let currentTreeBonusStrings = bonuses.map(b => `+${b.amount} (${(b.chance * 100).toFixed(0)}%)`);
                            treeBonusesStrings.push(`${titleCase(treeType)}: ${currentTreeBonusStrings.join(', ')}`);
                        }
                    }
                    if (treeBonusesStrings.length > 0) {
                        axeStatsDisplay += `<br>${treeBonusesStrings.join('<br>')}`;
                    }
                }
            }

            const axeSlotDiv = document.createElement('div');
            axeSlotDiv.className = 'slot';
            axeSlotDiv.innerHTML = `
                <div class="slot-name">Axe:</div>
                <div class="item-name ${axeColorClass}">${axeName}</div>
                <div class="item-art">${axeArt}</div>
                <div class="item-stats">${axeStatsDisplay}</div>
            `;
            const equipAxeButton = document.createElement('button');
            equipAxeButton.innerHTML = 'Equip<br>Axe';
            equipAxeButton.onclick = () => showEquipSelection('axe');
            equipAxeButton.classList.add('btn-woodcutting'); // Woodcutting color (green)
            axeSlotDiv.appendChild(equipAxeButton);
            equipmentDisplayDiv.appendChild(axeSlotDiv);

            // Pickaxe Slot
            const pickaxeKey = playerData.inventory.pickaxe;
            const pickaxeName = pickaxeKey === "none" ? "None" : titleCase(pickaxeKey);
            const pickaxeData = TOOL_DATA.pickaxe[pickaxeKey];
            const pickaxeColorClass = pickaxeData ? pickaxeData.color : 'fore-white';
            const pickaxeArt = pickaxeData ? (pickaxeData.emoji || "") : "";
            let pickaxeStatsDisplay = "";
            if (pickaxeData && pickaxeData.yield_config) {
                pickaxeStatsDisplay += `Base Yield: ${pickaxeData.yield_config.base}`;
                if (pickaxeData.yield_config.bonuses && pickaxeData.yield_config.bonuses.length > 0) {
                    let bonusStrings = pickaxeData.yield_config.bonuses.map(b => `+${b.amount} (${(b.chance * 100).toFixed(0)}%)`);
                    pickaxeStatsDisplay += `<br>Bonus: ${bonusStrings.join(', ')}`;
                }
            }

            const pickaxeSlotDiv = document.createElement('div');
            pickaxeSlotDiv.className = 'slot';
            pickaxeSlotDiv.innerHTML = `
                <div class="slot-name">Pickaxe:</div>
                <div class="item-name ${pickaxeColorClass}">${pickaxeName}</div>
                <div class="item-art">${pickaxeArt}</div>
                <div class="item-stats">${pickaxeStatsDisplay}</div>
            `;
            const equipPickaxeButton = document.createElement('button');
            equipPickaxeButton.innerHTML = 'Equip<br>Pickaxe';
            equipPickaxeButton.onclick = () => showEquipSelection('pickaxe');
            equipPickaxeButton.classList.add('btn-mining'); // Mining color (grey)
            pickaxeSlotDiv.appendChild(equipPickaxeButton);
            equipmentDisplayDiv.appendChild(pickaxeSlotDiv);

            // Chestplate Slot
            const chestplateKey = playerData.inventory.chestplate;
            const chestplateName = chestplateKey === "none" ? "None" : titleCase(chestplateKey);
            const armorData = ARMOR_DATA[chestplateKey];
            const chestplateColorClass = armorData ? armorData.color : 'fore-white';
            const chestplateArt = armorData ? (armorData.emoji || "") : "";
            let defenseDisplay = "";
            if (armorData && armorData.defense) defenseDisplay = `(-${(armorData.defense * 100).toFixed(0)}% Mob Hit)`;
            const chestplateSlotDiv = document.createElement('div');
            chestplateSlotDiv.className = 'slot';
            chestplateSlotDiv.innerHTML = `
                <div class="slot-name">Chestplate:</div>
                <div class="item-name ${chestplateColorClass}">${chestplateName}</div>
                <div class="item-art">${chestplateArt}</div>
                <div class="item-stats fore-cyan">${defenseDisplay}</div>
            `;
            const equipChestplateButton = document.createElement('button');
            equipChestplateButton.innerHTML = 'Equip<br>Chestplate';
            equipChestplateButton.onclick = () => showEquipSelection('chestplate');
            equipChestplateButton.classList.add('cyan'); // New light blue color
            chestplateSlotDiv.appendChild(equipChestplateButton);
            equipmentDisplayDiv.appendChild(chestplateSlotDiv);
        }

        function showEquipSelection(slot) {
            const listDiv = document.getElementById('equip-item-list');
            listDiv.innerHTML = '';
            document.getElementById('equip-item-type-title').textContent = `Equip ${titleCase(slot)}`;
            let foundItems = false;

            for (const itemName in playerData.inventory) {
                if (playerData.inventory[itemName] > 0 || typeof playerData.inventory[itemName] === 'string') { // Check for items in inv or if it's an equipped string
                    let itemData;
                    let matchesSlot = false;

                    if (slot === 'weapon' && SWORD_DATA[itemName]) { itemData = SWORD_DATA[itemName]; matchesSlot = true; }
                    else if (slot === 'axe' && TOOL_DATA.axe[itemName]) { itemData = TOOL_DATA.axe[itemName]; matchesSlot = true; }
                    else if (slot === 'pickaxe' && TOOL_DATA.pickaxe[itemName]) { itemData = TOOL_DATA.pickaxe[itemName]; matchesSlot = true; }
                    else if (slot === 'chestplate' && ARMOR_DATA[itemName]) { itemData = ARMOR_DATA[itemName]; matchesSlot = true; }

                    if (matchesSlot && (playerData.inventory[itemName] > 0 || playerData.inventory[slot] === itemName)) { // Item is in inventory OR is the currently equipped one
                        // We only care about items that are *in the inventory stacks* for equipping, not the slot itself.
                        if (typeof playerData.inventory[itemName] === 'number' && playerData.inventory[itemName] > 0) {
                            foundItems = true;
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'inv-item-equip item';
                            itemDiv.innerHTML = `${itemData.emoji || ''} ${titleCase(itemName)}`;
                            itemDiv.onclick = () => equipItem(slot, itemName);
                            listDiv.appendChild(itemDiv);
                        }
                    }
                }
            }

            if (!foundItems) {
                listDiv.innerHTML = `<p>No ${slot}s in your inventory to equip.</p>`;
            }
            document.getElementById('item-selection-for-equip').classList.remove('hidden');
        }

        function hideEquipSelection() {
            document.getElementById('item-selection-for-equip').classList.add('hidden');
        }

        function equipItem(slot, itemName) {
            // Unequip old item (if any and it's not "none") and add to inventory
            const oldItem = playerData.inventory[slot];
            if (oldItem !== "none" && oldItem !== itemName) { // Don't add if it's the same item or "none"
                playerData.inventory[oldItem] = (playerData.inventory[oldItem] || 0) + 1;
            }

            playerData.inventory[slot] = itemName; // Equip new item
            if (typeof playerData.inventory[itemName] === 'number') { // If it was from a stack
                playerData.inventory[itemName]--; // Decrement from inventory stack
            }

            logMessage(`Equipped ${titleCase(itemName)} to ${slot} slot.`, "fore-green", "");
            savePlayerData();
            updateHud();
            populateEquipmentDisplay();
            populateInventoryDisplay(); // Refresh inventory list
            hideEquipSelection();
        }

        function showShopMenu() { 
            document.getElementById('shop-gold-display').textContent = `Your Gold: ${playerData.gold.toLocaleString()}`;
            showSection('shop-menu-section');

            // Check if all permits are bought and hide the button if so
            const buyPermitsButton = document.querySelector('#shop-menu-section .btn-buy-permits');
            if (buyPermitsButton) {
                let allPermitsBought = true;
                // Ensure PERMIT_MASTER_LIST is not empty before checking
                if (Object.keys(PERMIT_MASTER_LIST).length > 0) {
                    for (const permitKey in PERMIT_MASTER_LIST) {
                        if (!playerData.permits || !playerData.permits[permitKey]) {
                            allPermitsBought = false;
                            break;
                        }
                    }
                } else { // If there are no permits defined, effectively all (zero) are "bought"
                    allPermitsBought = true; 
                }
                if (allPermitsBought) buyPermitsButton.classList.add('hidden');
                else buyPermitsButton.classList.remove('hidden');
            }
        }

        // --- Inventory & Equipment (Existing - no major changes needed for structures here) ---
        // ... (populateInventoryDisplay, populateEquipmentDisplay, showEquipSelection, hideEquipSelection, equipItem, unequipItem)

        // --- Shop Logic (Existing - modified for Castle perk) ---
        function showBuyMenu() {
            stopAllAutoActions();
            // Default to showing axes, or clear if no default desired
            populateShopItems('axe', 'Axes'); // Or clear #shop-items-list
            showSection('buy-menu-section');
        }

        function populateShopItems(categoryKey, categoryName) {
            const listDiv = document.getElementById('shop-items-list');
            listDiv.innerHTML = `<div class="section-title">Buying: ${categoryName}</div>`;
            const sourceData = TOOL_DATA[categoryKey] || ARMOR_DATA; // ARMOR_DATA is flat, TOOL_DATA is nested

            let itemsAvailable = false;
            for (const itemName in sourceData) {
                if (categoryKey === 'axe' && itemName === 'fists') continue; // Skip fists for axes
                if (categoryKey === 'chestplate' && !ARMOR_DATA[itemName]) continue; // Ensure we only list armor for chestplate
                if (categoryKey !== 'chestplate' && (!TOOL_DATA[categoryKey] || !TOOL_DATA[categoryKey][itemName])) continue;

                const item = sourceData[itemName];
                itemsAvailable = true;
                const itemDiv = document.createElement('div');
                itemDiv.id = `shop-item-buy-${categoryKey}-${itemName.replace(/\s+/g, '-')}`; // Add unique ID
                itemDiv.className = 'shop-item item';

                let actualPrice = item.price;
                if (playerData.built_structures.castle && STRUCTURE_DATA.castle.perk_effect.type === "shop_price_modifier") { // Check perk type
                    actualPrice *= (1 + STRUCTURE_DATA.castle.perk_effect.buy_mod);
                    actualPrice = Math.max(1, Math.floor(actualPrice));
                }


                const displayName = (categoryKey === 'axe' || categoryKey === 'pickaxe') ? titleCase(itemName + " " + categoryKey) : titleCase(itemName);
                const itemDisplayColorClass = item.color || 'fore-white'; // Get color from item data or default
                itemDiv.innerHTML = `
                    <div class="shop-item-details">
                        ${item.emoji || ''} <span class="${itemDisplayColorClass}">${displayName}</span>
                        <br><small class="req">Req Lvl: ${item.level_req} ${titleCase(item.skill_type || categoryKey)}</small>
                    </div>
                    <span class="price">${actualPrice}g</span>`;
                itemDiv.onclick = () => buyItem(categoryKey, itemName);
                listDiv.appendChild(itemDiv);
            }
            if (!itemsAvailable) listDiv.innerHTML += "<p>No items in this category.</p>";
        }

        // MODIFIED for Castle Perk
        function buyItem(categoryKey, itemName) { 
            const sourceData = TOOL_DATA[categoryKey]; 
            const itemToBuy = sourceData[itemName];

            const skillType = itemToBuy.skill_type;
            const playerSkillLevel = getLevelFromXp(playerData[`${skillType}_xp`] || 0);
            if (playerSkillLevel < itemToBuy.level_req) {
                logMessage(`Your ${titleCase(skillType)} Lvl (${playerSkillLevel}) is too low for ${titleCase(itemName)} (Req: ${itemToBuy.level_req}).`, "fore-red", "");
                return;
            }

            let actualPrice = itemToBuy.price;
            if (playerData.built_structures.castle && STRUCTURE_DATA.castle.perk_effect.type === "shop_price_modifier") { // Check perk type
                actualPrice *= (1 + STRUCTURE_DATA.castle.perk_effect.buy_mod);
                actualPrice = Math.max(1, Math.floor(actualPrice)); 
            }

            if (playerData.gold < actualPrice) {
                logMessage(`Not enough gold. Need ${actualPrice}g, have ${playerData.gold.toLocaleString()}g.`, "fore-red", "");
                return;
            } 
            
            const currentlyEquippedInSlot = playerData.inventory[categoryKey];
            if (currentlyEquippedInSlot === itemName) {
                logMessage(`You already have ${titleCase(itemName)} equipped. Purchase not made.`, "fore-yellow");
                return;
            }

            playerData.gold -= actualPrice;
            
            const oldEquippedItemName = playerData.inventory[categoryKey]; 
            if (oldEquippedItemName && oldEquippedItemName !== "none") {
                if (sourceData[oldEquippedItemName]) { 
                    playerData.inventory[oldEquippedItemName] = (playerData.inventory[oldEquippedItemName] || 0) + 1; 
                    logMessage(`Unequipped ${titleCase(oldEquippedItemName)} and moved to inventory.`, "fore-yellow");
                }
            }
            playerData.inventory[categoryKey] = itemName; 
             
            logMessage(`Bought and equipped ${titleCase(itemName)} for ${actualPrice}g!`, "fore-green");
            savePlayerData();

            // Visual feedback for successful purchase
            if (categoryKey === 'axe' || categoryKey === 'pickaxe') {
                const boughtButtonId = `shop-item-buy-${categoryKey}-${itemName.replace(/\s+/g, '-')}`;
                const boughtButton = document.getElementById(boughtButtonId);
                if (boughtButton) {
                    boughtButton.classList.add('glow-green-temp');
                    setTimeout(() => boughtButton.classList.remove('glow-green-temp'), 500); // Glow for 0.5 seconds
                }
            }

            updateHud();
            populateEquipmentDisplay(); 
            populateInventoryDisplay();
            document.getElementById('shop-gold-display').textContent = `Your Gold: ${playerData.gold.toLocaleString()}`; 
        }

        function showSellMenu() {
            stopAllAutoActions();
            populateSellableItemsList();
            showSection('sell-menu-section');
        }

        function populateSellableItemsList() {
            const listDiv = document.getElementById('sellable-items-list');
            listDiv.innerHTML = '<div class="section-title">Your Sellable Items</div>';
            let hasSellable = false;
            
            for (const inventoryKey in playerData.inventory) {
                const quantity = playerData.inventory[inventoryKey];
                const isEquippableSlot = ["weapon", "axe", "pickaxe", "chestplate"].includes(inventoryKey);

                // Skip equipped slots and items with 0 quantity or non-numeric quantity (like equipped item names)
                if (isEquippableSlot || typeof quantity !== 'number' || quantity <= 0) {
                    continue;
                }

                let emoji = "&nbsp;";
                let itemColorClass = "fore-white";
                let displayFullName = titleCase(inventoryKey); // Default display name
                let priceLookupKey = inventoryKey;          // Default key for ITEM_SELL_PRICES

                // Handle tools that are stored by material name in inventory (e.g., "bronze" for bronze axe)
                // These are typically unequipped tools.
                if (TOOL_DATA.axe[inventoryKey]) {
                    const toolData = TOOL_DATA.axe[inventoryKey];
                    displayFullName = titleCase(inventoryKey + " axe");
                    priceLookupKey = inventoryKey + " axe"; // ITEM_SELL_PRICES uses "bronze axe", etc.
                    emoji = toolData.emoji || "&nbsp;";
                    itemColorClass = toolData.color || "fore-white";
                } else if (TOOL_DATA.pickaxe[inventoryKey]) {
                    const toolData = TOOL_DATA.pickaxe[inventoryKey];
                    displayFullName = titleCase(inventoryKey + " pickaxe");
                    priceLookupKey = inventoryKey + " pickaxe";
                    emoji = toolData.emoji || "&nbsp;";
                    itemColorClass = toolData.color || "fore-white";
                }
                // Handle other item types by their direct inventoryKey
                else if (FOOD_DATA[inventoryKey]) {
                    emoji = FOOD_DATA[inventoryKey].emoji || "&nbsp;";
                    itemColorClass = FOOD_DATA[inventoryKey].color || "fore-green";
                } else if (COOKABLE_ITEMS[inventoryKey.replace(/s$/, '')]) { // Handle plural "raw meats" if needed
                    const cookableBase = inventoryKey.replace(/s$/, '');
                    emoji = COOKABLE_ITEMS[cookableBase].emoji || "&nbsp;";
                    itemColorClass = COOKABLE_ITEMS[cookableBase].color || "fore-white";
                } else if (BAR_DATA[inventoryKey]) {
                    emoji = BAR_DATA[inventoryKey].emoji || "&nbsp;";
                    itemColorClass = BAR_DATA[inventoryKey].color || "fore-white";
                } else if (SWORD_DATA[inventoryKey]) { // Swords are stored by full name, e.g., "bronze 2h sword"
                    emoji = SWORD_DATA[inventoryKey].emoji || "&nbsp;";
                    itemColorClass = SWORD_DATA[inventoryKey].color || "fore-white";
                } else if (ARMOR_DATA[inventoryKey]) { // Armor is stored by full name, e.g., "bronze chestplate"
                    emoji = ARMOR_DATA[inventoryKey].emoji || "&nbsp;";
                    itemColorClass = ARMOR_DATA[inventoryKey].color || "fore-white";
                } else { // Generic items like logs, ores, misc drops
                    const nameParts = inventoryKey.toLowerCase().split(" ");
                    const baseName = nameParts[0];

                    if (inventoryKey.endsWith(" ore") && ORE_DATA[baseName]) {
                        emoji = ORE_DATA[baseName].emoji || "&nbsp;";
                        itemColorClass = ORE_DATA[baseName].color || "fore-white";
                    } else if (inventoryKey.endsWith(" logs") && TREE_DATA[baseName]) {
                        emoji = TREE_DATA[baseName].emoji || "&nbsp;";
                        itemColorClass = TREE_DATA[baseName].color || "fore-green"; // Default for logs
                    }
                    else if (inventoryKey === "egg") {
                        emoji = "";
                    } else if (inventoryKey === "goblin beads") {
                        emoji = "";
                    } else if (inventoryKey === "dragon gem") {
                        emoji = "<span class='fore-red'></span>";
                    } else if (inventoryKey === "demon heart") {
                        emoji = "<span class='fore-magenta'></span>";
                    } else if (inventoryKey === "burnt meat") { // Explicitly set emoji for burnt meat in shop
                        emoji = "  ";
                        itemColorClass = "fore-dark-grey";
                    } else if (emoji === "&nbsp;") { // Default emoji if still not found for other generic items
                        emoji = `<span class='${itemColorClass}'></span>`;
                    }
                }

                // Determine sell price
                let baseSellPrice = ITEM_SELL_PRICES[priceLookupKey];
                if (typeof baseSellPrice === 'undefined') {
                    baseSellPrice = 1; // Default sell price for items not explicitly priced
                }

                let actualSellPrice = baseSellPrice;
                if (playerData.built_structures.castle && typeof actualSellPrice === 'number' && STRUCTURE_DATA.castle.perk_effect.type === "shop_price_modifier") {
                    actualSellPrice *= (1 + STRUCTURE_DATA.castle.perk_effect.sell_mod);
                    actualSellPrice = Math.floor(actualSellPrice);
                }

                if (actualSellPrice < 0) { // Don't list items that would sell for negative gold
                    continue;
                }

                hasSellable = true;
                const itemDiv = document.createElement('div');
                itemDiv.className = 'shop-item item'; // Using shop-item for consistency

                // Mimic inventory display structure for consistency
                itemDiv.innerHTML = `
                    <div class="shop-item-details">
                        <span class="inv-item-emoji">${emoji}</span><span class="item-name ${itemColorClass}">${displayFullName}:</span> <span class="item-quantity">${quantity.toLocaleString()}</span>
                    </div>
                    <span class="price">${actualSellPrice}g each</span>`;
                itemDiv.onclick = () => sellItem(inventoryKey, quantity, baseSellPrice); // Pass original inventoryKey and baseSellPrice
                listDiv.appendChild(itemDiv);
            }

            if (!hasSellable) listDiv.innerHTML += "<p>You have no items to sell (or they are worthless).</p>";
        }

        // MODIFIED for Castle Perk
        function sellItem(itemName, currentQuantity, pricePerItem) { // pricePerItem is base price
            const amountToSell = parseInt(prompt(`How many ${titleCase(itemName)} to sell? (Max ${currentQuantity})`, currentQuantity));
            if (isNaN(amountToSell) || amountToSell <= 0) {
                logMessage("Invalid amount.", "fore-red", "");
                return;
            }
            if (amountToSell > currentQuantity) {
                logMessage("You don't have that many to sell.", "fore-red", "");
                return;
            }

            let actualSellPricePerItem = pricePerItem;
            if (playerData.built_structures.castle && actualSellPricePerItem && STRUCTURE_DATA.castle.perk_effect.type === "shop_price_modifier") { // Check perk type
                actualSellPricePerItem *= (1 + STRUCTURE_DATA.castle.perk_effect.sell_mod);
                actualSellPricePerItem = Math.floor(actualSellPricePerItem);
            }

            playerData.inventory[itemName] -= amountToSell;
            const goldEarned = amountToSell * actualSellPricePerItem;
            playerData.gold += goldEarned;

            logMessage(`Sold ${amountToSell} ${titleCase(itemName)} for ${goldEarned} gold (${actualSellPricePerItem}g each).`, "fore-yellow", "");
            playSound(sellItemSound); 
            savePlayerData();
            updateHud();
            populateSellableItemsList(); // Just refresh the list, don't change section
            populateInventoryDisplay(); 
            document.getElementById('shop-gold-display').textContent = `Your Gold: ${playerData.gold.toLocaleString()}`;
        }
        
        // NEW: Functions for Buying Permits
        function showBuyPermitsMenu() {
            stopAllAutoActions();
            populatePermitsShopList();
            showSection('buy-permits-section');
        }

        function populatePermitsShopList() {
            const listDiv = document.getElementById('permits-for-sale-list');
            listDiv.innerHTML = ''; // Clear previous items

            // Define Permit Details (can be moved to a global const later if more permits are added)
            const permitMasterList = {
                hunter: {
                    permitTypeKey: "hunter",
                    displayName: "Hunter's Permit",
                    emoji: "",
                    description: "A decree from the Hunter's Guild, recognizing your prowess. This allows relentless pursuit of your chosen prey, enabling continuous combat even as your Attack skill ascends. You'll keep fighting that monster type until you choose to stop, or meet your end!",
                    goldCost: 10000,
                    resourceCosts: { "wolf fang": 50, "bear claw": 20 }
                },
                miner: { 
                    permitTypeKey: "miner",
                    displayName: "Miner's Permit",
                    emoji: "",
                    description: "Endorsed by the Deep Earth Mining Conglomerate, this permit certifies your tireless dedication. Delve ever deeper, as it allows continuous mining through Mining skill level ups. A sturdy pickaxe is, of course, essential for such endeavors!",
                    goldCost: 12000, // Increased cost slightly
                    resourceCosts: { "coal": 200, "iron bar": 50 }
                },
                blacksmith: {
                    permitTypeKey: "blacksmith",
                    displayName: "Blacksmith's Royal Charter",
                    emoji: "",
                    description: "A Royal Charter from the King, granting authority to distribute Arms and Armor to other cities in the kingdom. This esteemed document also allows continuous blacksmithing (smelting/smithing) through level ups.",
                    goldCost: 25000,
                    resourceCosts: { "steel bar": 100, "mithril bar": 50, "adamantite bar": 25 } 
                }
                // Future permits (miner, blacksmith) will be added here
            };

            let canBuyAnyPermit = false;

            for (const permitKey in permitMasterList) {
                const details = permitMasterList[permitKey];
                if (playerData.permits && !playerData.permits[permitKey]) {
                    canBuyAnyPermit = true;
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'shop-item item'; // Use existing styling for consistency

                    let resourceCostString = Object.entries(details.resourceCosts)
                        .map(([name, amount]) => `${amount.toLocaleString()} ${titleCase(name)}`)
                        .join(', ');
                    
                    // Ensure gold cost from resourceCosts is handled correctly if present
                    let displayGoldCost = details.goldCost;
                    if (details.resourceCosts.gold) displayGoldCost -= details.resourceCosts.gold;
                    
                    let currentResourcesString = "";
                    if (Object.keys(details.resourceCosts).length > 0) {
                         currentResourcesString = "<br><small>You have: ";
                         currentResourcesString += Object.entries(details.resourceCosts)
                            .map(([name, reqAmount]) => {
                                const currentAmount = playerData.inventory[name] || 0;
                                const isGoldResource = name === 'gold'; // Special handling for gold in resource list
                                const color = (isGoldResource ? (playerData.gold >= reqAmount) : (currentAmount >= reqAmount)) ? 'fore-green' : 'fore-red';
                                return `<span class="${color}">${currentAmount.toLocaleString()} ${titleCase(name)}</span>`;
                            }).join(', ');
                        currentResourcesString += "</small>";
                    }


                    itemDiv.innerHTML = `
                        <div class="shop-item-details">
                            ${details.emoji} <span class="fore-white">${details.displayName}</span>
                            <br><small>${details.description}</small>
                            ${resourceCostString ? `<br><small class="req">Resources: ${resourceCostString}</small>` : ''}
                            ${currentResourcesString}
                        </div>
                        <span class="price">${displayGoldCost.toLocaleString()}g</span>
                    `;
                    itemDiv.onclick = () => buyPermit(details.permitTypeKey, displayGoldCost, details.resourceCosts);
                    listDiv.appendChild(itemDiv);
                }
            }

            if (!canBuyAnyPermit) {
                listDiv.innerHTML = "<p>All available permits purchased.</p>";
            }
        }

        function buyPermit(permitTypeKey, goldCost, requiredResourceCosts) {
            if (playerData.permits[permitTypeKey]) {
                logMessage("You already own this permit.", "fore-yellow", "");
                return;
            }

            let totalGoldNeeded = goldCost; // This is the main gold cost (already adjusted if gold was in resources)
            if (requiredResourceCosts.gold) { // If gold is also part of resourceCosts
                totalGoldNeeded += requiredResourceCosts.gold; // Add the resource gold part
            }

            if (playerData.gold < totalGoldNeeded) {
                logMessage(`Not enough gold. Need ${totalGoldNeeded.toLocaleString()}g.`, "fore-red", "");
                return;
            }

            for (const resourceName in requiredResourceCosts) {
                if (resourceName === 'gold') continue; // Gold is handled with totalGoldNeeded
                if ((playerData.inventory[resourceName] || 0) < requiredResourceCosts[resourceName]) {
                    logMessage(`Not enough ${titleCase(resourceName)}. Need ${requiredResourceCosts[resourceName].toLocaleString()}.`, "fore-red", "");
                    return;
                }
            }
            // Deduct costs
            playerData.gold -= totalGoldNeeded; // Deduct the combined gold cost
            for (const resourceName in requiredResourceCosts) {
                playerData.inventory[resourceName] -= requiredResourceCosts[resourceName];
            }

            playerData.permits[permitTypeKey] = true;
            const permitDisplayName = titleCase(permitTypeKey) + "'s Permit"; // e.g. Hunter's Permit
            logMessage(`${permitDisplayName} purchased!`, "fore-green", "");
            playSound(sellItemSound); 

            savePlayerData();
            updateHud();
            populateInventoryDisplay(); 
            document.getElementById('shop-gold-display').textContent = `Your Gold: ${playerData.gold.toLocaleString()}`;
            populatePermitsShopList(); // Refresh the permit shop list
        }


        // --- Action: Woodcutting (Modified for Camp Perk and new interaction) ---
        function showWoodcutting() {
            stopAllAutoActions(); 
            const treeListDiv = document.getElementById('available-trees');
            treeListDiv.innerHTML = '<div class="section-title">Available Trees</div>';
            currentWoodcuttingTarget = null; // Clear target when re-entering screen unless auto-action restarts

            // Display Woodcutting Permit Status
            const wcPermitStatusDiv = document.getElementById('woodcutting-permit-status');
            wcPermitStatusDiv.innerHTML = ''; // Clear previous
            // Check for a generic 'woodcutter' permit, even if not purchasable yet, for consistency
            // This could be tied to the Lumber Mill structure's effect display in the future.
            if (playerData.built_structures && playerData.built_structures.lumberMill) {
               wcPermitStatusDiv.innerHTML = " Lumber Mill Active: Continuous chopping through level ups!";
            }
            const wcLvl = getLevelFromXp(playerData.woodcutting_xp);
            const equippedAxeName = playerData.inventory.axe;
            const equippedAxeData = TOOL_DATA.axe[equippedAxeName] || TOOL_DATA.axe.fists;
            const equippedAxeTierIndex = AXE_TIER_ORDER.indexOf(equippedAxeData.tier);

            let available = false;
            for (const treeName in TREE_DATA) {
                const tree = TREE_DATA[treeName];
                if (wcLvl >= tree.level) {
                    available = true;
                    const treeDiv = document.createElement('div');
                    treeDiv.className = 'skill-resource fore-green';
                    let treeDisplayText = `${tree.emoji} ${titleCase(treeName)} (Lvl: ${tree.level}, XP per log: ${tree.exp})`;
                    let canChopThisTree = true;

                    if (tree.required_axe_tier) {
                        const requiredTierIndex = AXE_TIER_ORDER.indexOf(tree.required_axe_tier);
                        if (equippedAxeTierIndex < requiredTierIndex) {
                            treeDisplayText += ` <span class="fore-red">(Req: ${titleCase(tree.required_axe_tier)} Axe)</span>`;
                            treeDiv.style.opacity = "0.6";
                            treeDiv.style.cursor = "not-allowed";
                            treeDiv.title = `Requires a ${titleCase(tree.required_axe_tier)} Axe or better.`;
                            canChopThisTree = false;
                        }
                    }
                    // Updated display to match mining style
                    treeDiv.innerHTML = `
                        <span class="resource-main-text">${treeDisplayText}</span>
                        <span class="resource-inventory-count" id="inv-count-wc-${treeName.replace(/\s+/g, '-')}">${playerData.inventory[tree.log] || 0}</span>`;
                    treeDiv.id = `tree-list-item-${treeName.replace(/\s+/g, '-')}`;
                    if (isAutoWoodcutting && currentWoodcuttingTarget === treeName) {
                        treeDiv.classList.add('active-woodcutting-item');
                    }
                    if (canChopThisTree) treeDiv.onclick = () => selectTreeForWoodcutting(treeName);
                    treeListDiv.appendChild(treeDiv);
                }
            }
            if (!available) treeListDiv.innerHTML += "<p>No trees available at your level.</p>";
            showSection('woodcutting-section');
        }
        
        function selectTreeForWoodcutting(treeName) {
            if (isAutoWoodcutting && currentWoodcuttingTarget === treeName) {
                stopAutoWoodcutting();
            } else {
                if (isAutoWoodcutting) { 
                    stopAutoWoodcutting();
                }
                startAutoWoodcutting(treeName);
            }
        }

        function startAutoWoodcutting(treeName) {
            if (!treeName) { logMessage("No tree selected.", "fore-red", ""); return false; }
            document.querySelectorAll('.active-woodcutting-item').forEach(el => el.classList.remove('active-woodcutting-item'));
            currentWoodcuttingTarget = treeName; 

            const equippedAxeName = playerData.inventory.axe;
            if (equippedAxeName === "none") { logMessage("You need an axe to chop wood.", "fore-red", ""); currentWoodcuttingTarget=null; return; }
            
            const axeProps = TOOL_DATA.axe[equippedAxeName];
            if (!axeProps) { logMessage("Error: Equipped axe data not found.", "fore-red", ""); stopAutoWoodcutting(); currentWoodcuttingTarget=null; return; }
            
            const currentWcLvl = getLevelFromXp(playerData.woodcutting_xp);
            if (currentWcLvl < axeProps.level_req) {
                logMessage(`Woodcutting Lvl (${currentWcLvl}) too low for ${titleCase(equippedAxeName)}. Req: ${axeProps.level_req}`, "fore-red", "");
                currentWoodcuttingTarget = null; 
                return false;
            }

            const treeData = TREE_DATA[treeName];
            if (treeData.required_axe_tier) {
                const equippedAxeTierIndex = AXE_TIER_ORDER.indexOf(axeProps.tier);
                const requiredTierIndex = AXE_TIER_ORDER.indexOf(treeData.required_axe_tier);
                if (equippedAxeTierIndex < requiredTierIndex) {
                    logMessage(`Your ${titleCase(equippedAxeName)} is not strong enough for ${titleCase(treeName)}. Requires a ${titleCase(treeData.required_axe_tier)} Axe or better.`, "fore-red", "");
                    currentWoodcuttingTarget = null;
                    return false;
                }
            }

            isAutoWoodcutting = true;
            const treeListItem = document.getElementById(`tree-list-item-${currentWoodcuttingTarget.replace(/\s+/g, '-')}`);
            if (treeListItem) treeListItem.classList.add('active-woodcutting-item');

            logMessage(`Auto-chopping ${titleCase(currentWoodcuttingTarget)}...`, "fore-cyan", "");

            let interval = BASE_GATHER_INTERVAL;
            if(isPerkActive("efficientGatherer1")) interval *= (1 - PERK_DATA.efficientGatherer1.value);
            if (playerData.built_structures.stronghold) {
                const speedPerk = STRUCTURE_DATA.stronghold.perks.find(p => p.type === "global_skill_speed_boost");
                if (speedPerk) interval *= (1 - speedPerk.value);
            }
            autoWoodcuttingInterval = setInterval(singleChopAction, interval);
            return true;
        }

        function stopAutoWoodcutting() {
            if (isAutoWoodcutting) {
                isAutoWoodcutting = false;
                clearInterval(autoWoodcuttingInterval);
                autoWoodcuttingInterval = null;
                if (currentWoodcuttingTarget) {
                    const treeListItem = document.getElementById(`tree-list-item-${currentWoodcuttingTarget.replace(/\s+/g, '-')}`);
                    if (treeListItem) { // Check if the element exists before trying to modify it
                        treeListItem.classList.remove('active-woodcutting-item');
                    }
                }
                logMessage("Auto-chopping stopped.", "fore-yellow", "");
            }
        }
        
        function singleChopAction() {
            if (!isAutoWoodcutting || !currentWoodcuttingTarget) { stopAutoWoodcutting(); return; }
            const equippedAxeName = playerData.inventory.axe; 
            if (equippedAxeName === "none") { logMessage("No axe equipped. Stopping.", "fore-red", ""); stopAutoWoodcutting(); return; }
             
            const axeProps = TOOL_DATA.axe[equippedAxeName];
            if (!axeProps || !axeProps.yield_config) { logMessage("Error with axe data.", "fore-red"); stopAutoWoodcutting(); return; }

            const treeData = TREE_DATA[currentWoodcuttingTarget]; 
            const oldLevel = getLevelFromXp(playerData.woodcutting_xp);
            
            let baseYieldBonus = 0;
            if (playerData.built_structures.camp && STRUCTURE_DATA.camp.perk_effect.type === "base_gather_yield_bonus" && Math.random() < STRUCTURE_DATA.camp.perk_effect.value) {
                baseYieldBonus = 1; 
            }

            let logsGained = axeProps.yield_config.base + baseYieldBonus;
            // Use tree-specific bonuses
            const treeTypeKey = currentWoodcuttingTarget; // "normal", "oak", "willow"
            const treeSpecificBonuses = axeProps.yield_config.bonuses_by_tree ? axeProps.yield_config.bonuses_by_tree[treeTypeKey] || [] : [];

            if (treeSpecificBonuses.length > 0) {
                treeSpecificBonuses.forEach(bonus => {
                    if (Math.random() < bonus.chance) logsGained += bonus.amount;
                });
            }
            if (logsGained < 0) logsGained = 0;

            let xpPerLog = treeData.exp; 
            let totalXpGainedThisAction = 0;

            if (logsGained > 0) {
                playerData.inventory[treeData.log] = (playerData.inventory[treeData.log] || 0) + logsGained;
                totalXpGainedThisAction = logsGained * xpPerLog;

                let logMsg = `Got ${logsGained} ${titleCase(treeData.log)}.`;
                if (baseYieldBonus > 0) logMsg += " ( Camp bonus!)";
                
                let displayXpGained = totalXpGainedThisAction;
                if (playerData.built_structures.house) {
                    const houseXpPerk = STRUCTURE_DATA.house.perks.find(p => p.type === "global_xp_boost");
                    if (houseXpPerk) {
                        displayXpGained *= (1 + houseXpPerk.value);
                    }
                }
                displayXpGained = Math.floor(displayXpGained);

                logMessage(`+${displayXpGained} WC XP. ${logMsg}`, "fore-green", "");
                
                playerData.woodcutting_xp += displayXpGained;
                grantUniversalXP(totalXpGainedThisAction); 
                
            } else {
                 logMessage(`Got no logs this time. (+0 WC XP)`, "fore-yellow", "");
            } 
            
            playSound(skillRoundSound); 
            const leveledUp = handleLevelUp("woodcutting_xp", oldLevel);
            if (leveledUp) { // If a level up occurred
                if (playerData.built_structures && playerData.built_structures.lumberMill) {
                    logMessage("Woodcutting level up! The Lumber Mill keeps you chopping!", "fore-green", "");
                    // Action continues, no need to call stopAutoWoodcutting()
                } else {
                    logMessage("Woodcutting level up! Action stopped. Build the Lumber Mill to continue chopping through level ups.", "fore-blue", "");
                    stopAutoWoodcutting(); // Stop if no Lumber Mill
                }
            }

            savePlayerData();
            updateHud();
            // Update inventory count display for the current tree
            const countSpan = document.getElementById(`inv-count-wc-${currentWoodcuttingTarget.replace(/\s+/g, '-')}`);
            if (countSpan) {
                countSpan.textContent = playerData.inventory[treeData.log] || 0;
            }
            if (leveledUp && !isAutoWoodcutting) return; // If stopped due to level up, exit.

        }


        // --- Action: Mining (Modified for Camp Perk and new interaction) ---
        function showMining() {
            stopAllAutoActions();
            const oreListDiv = document.getElementById('available-ores');
            oreListDiv.innerHTML = '<div class="section-title">Available Ores</div>';
            currentMiningTarget = null;

            // Display Mining Permit Status
            const mnPermitStatusDiv = document.getElementById('mining-permit-status');
            mnPermitStatusDiv.innerHTML = ''; // Clear previous
            if (playerData.permits && playerData.permits.miner) {
                mnPermitStatusDiv.innerHTML = " Miner's Permit Active: Continuous mining through level ups!";
            }

            const equippedPickaxeName = playerData.inventory.pickaxe;
            const equippedPickaxeData = TOOL_DATA.pickaxe[equippedPickaxeName] || null; // No "fists" for pickaxe
            const equippedPickaxeTierIndex = equippedPickaxeData ? PICKAXE_TIER_ORDER.indexOf(equippedPickaxeData.tier) : -1;

            const mnLvl = getLevelFromXp(playerData.mining_xp);
            let available = false;
            for (const oreName in ORE_DATA) {
                const ore = ORE_DATA[oreName];
                if (mnLvl >= ore.level_req) {
                    available = true;
                    let canMineThisOre = true;
                    let oreDisplayText = `${ore.emoji} ${titleCase(oreName)} (Lvl: ${ore.level_req}, XP per ore: ${ore.xp})`;

                    if (ore.required_pickaxe_tier) {
                        if (!equippedPickaxeData) { // No pickaxe equipped
                            oreDisplayText += ` <span class="fore-red">(Req: ${titleCase(ore.required_pickaxe_tier)} Pickaxe)</span>`;
                            canMineThisOre = false;
                        } else {
                            const requiredTierIndex = PICKAXE_TIER_ORDER.indexOf(ore.required_pickaxe_tier);
                            if (equippedPickaxeTierIndex < requiredTierIndex) {
                                oreDisplayText += ` <span class="fore-red">(Req: ${titleCase(ore.required_pickaxe_tier)} Pickaxe)</span>`;
                                canMineThisOre = false;
                            }
                        }
                    }

                    const oreDiv = document.createElement('div');
                    oreDiv.className = `skill-resource ${ore.color}`;
                    oreDiv.innerHTML = `
                        <span class="resource-main-text">${oreDisplayText}</span>
                        <span class="resource-inventory-count" id="inv-count-mn-${oreName.replace(/\s+/g, '-')}">${playerData.inventory[ore.item_name] || 0}</span>
                    `;
                    oreDiv.id = `ore-list-item-${oreName.replace(/\s+/g, '-')}`;
                     if (isAutoMining && currentMiningTarget === oreName) {
                        oreDiv.classList.add('active-mining-item');
                    }
                    if (canMineThisOre) {
                        oreDiv.onclick = () => selectOreForMining(oreName);
                    } else {
                        oreDiv.style.opacity = "0.6";
                        oreDiv.style.cursor = "not-allowed";
                        oreDiv.title = `Requires a ${titleCase(ore.required_pickaxe_tier || 'better')} Pickaxe.`;
                    }
                    oreListDiv.appendChild(oreDiv);
                }
            }
            if (!available) oreListDiv.innerHTML += "<p>No ores available at your level.</p>";
            showSection('mining-section');
        }

        function selectOreForMining(oreName) {
            if (isAutoMining && currentMiningTarget === oreName) {
                stopAutoMining();
            } else {
                if (isAutoMining) {
                    stopAutoMining();
                }
                startAutoMining(oreName);
            }
        }

        function startAutoMining(oreName) {
            if (!oreName) { logMessage("No ore selected.", "fore-red", ""); return false; }
            document.querySelectorAll('.active-mining-item').forEach(el => el.classList.remove('active-mining-item'));
            currentMiningTarget = oreName;

            const equippedPickaxeName = playerData.inventory.pickaxe;
            if (equippedPickaxeName === "none") { logMessage("You need a pickaxe to mine.", "fore-red", ""); currentMiningTarget = null; return; }
            
            const pickaxeProps = TOOL_DATA.pickaxe[equippedPickaxeName];
            if (!pickaxeProps) { logMessage("Error: Pickaxe data missing.", "fore-red", ""); stopAutoMining(); currentMiningTarget = null; return; }
            
            const currentMnLvl = getLevelFromXp(playerData.mining_xp);
            if (currentMnLvl < pickaxeProps.level_req) {
                logMessage(`Mining Lvl (${currentMnLvl}) too low for ${titleCase(equippedPickaxeName)}. Req: ${pickaxeProps.level_req}`, "fore-red", "");
                currentMiningTarget = null;
                return false;
            }

            const oreData = ORE_DATA[currentMiningTarget];
            if (oreData.required_pickaxe_tier) {
                const equippedPickaxeTierIndex = PICKAXE_TIER_ORDER.indexOf(pickaxeProps.tier);
                const requiredTierIndex = PICKAXE_TIER_ORDER.indexOf(oreData.required_pickaxe_tier);
                if (equippedPickaxeTierIndex < requiredTierIndex) {
                    logMessage(`Your ${titleCase(equippedPickaxeName)} is not strong enough for ${titleCase(currentMiningTarget)}. Requires a ${titleCase(oreData.required_pickaxe_tier)} Pickaxe or better.`, "fore-red", "");
                    // Also remove active class if it was somehow set
                    const oreListElementId = `ore-list-item-${currentMiningTarget.replace(/\s+/g, '-')}`; // Use currentMiningTarget before nulling
                    const oreListItem = document.getElementById(oreListElementId);
                    if (oreListItem) oreListItem.classList.remove('active-mining-item');
                    currentMiningTarget = null; // Null it after using it
                    return false;
                }
            }

            isAutoMining = true;
            const oreListItem = document.getElementById(`ore-list-item-${currentMiningTarget.replace(/\s+/g, '-')}`);
            if (oreListItem) oreListItem.classList.add('active-mining-item');
            logMessage(`Auto-mining ${titleCase(currentMiningTarget)}...`, "fore-cyan", "");
            
            let interval = BASE_GATHER_INTERVAL;
            if(isPerkActive("efficientGatherer1")) interval *= (1 - PERK_DATA.efficientGatherer1.value);
            if (playerData.built_structures.stronghold) {
                const speedPerk = STRUCTURE_DATA.stronghold.perks.find(p => p.type === "global_skill_speed_boost");
                if (speedPerk) interval *= (1 - speedPerk.value);
            }
            autoMiningInterval = setInterval(singleMineAction, interval);
            return true;
        }

        function stopAutoMining() {
            if (isAutoMining) {
                isAutoMining = false;
                clearInterval(autoMiningInterval);
                autoMiningInterval = null;
                if (currentMiningTarget) {
                    const oreListItem = document.getElementById(`ore-list-item-${currentMiningTarget.replace(/\s+/g, '-')}`);
                    if (oreListItem) { // Check if the element exists
                        oreListItem.classList.remove('active-mining-item');
                    }
                }
                logMessage("Auto-mining stopped.", "fore-yellow", "");
            }
        }

        function singleMineAction() {
            if (!isAutoMining || !currentMiningTarget) { stopAutoMining(); return; }
            const equippedPickaxeName = playerData.inventory.pickaxe;
            if (equippedPickaxeName === "none") { logMessage("No pickaxe. Stopping.", "fore-red", ""); stopAutoMining(); return; }
            
            const pickaxeProps = TOOL_DATA.pickaxe[equippedPickaxeName];
            if (!pickaxeProps || !pickaxeProps.yield_config) { logMessage("Error with pickaxe data.", "fore-red"); stopAutoMining(); return; }

            const oreData = ORE_DATA[currentMiningTarget];
            const oldLevel = getLevelFromXp(playerData.mining_xp);
            
            let baseYieldBonus = 0;
            if (playerData.built_structures.camp && STRUCTURE_DATA.camp.perk_effect.type === "base_gather_yield_bonus" && Math.random() < STRUCTURE_DATA.camp.perk_effect.value) {
                baseYieldBonus = 1;
            }

            let oreGained = pickaxeProps.yield_config.base + baseYieldBonus;
            if (pickaxeProps.yield_config.bonuses) {
                pickaxeProps.yield_config.bonuses.forEach(bonus => {
                    if (Math.random() < bonus.chance) oreGained += bonus.amount;
                });
            }
            if (oreGained < 0) oreGained = 0; 

            let xpPerOre = oreData.xp; 
            let totalXpGainedThisAction = 0;

            if (oreGained > 0) {
                playerData.inventory[oreData.item_name] = (playerData.inventory[oreData.item_name] || 0) + oreGained;
                totalXpGainedThisAction = oreGained * xpPerOre;

                let logMsg = `Got ${oreGained} ${titleCase(oreData.item_name)}.`;
                 if (baseYieldBonus > 0) logMsg += " ( Camp bonus!)";
                
                let displayXpGained = totalXpGainedThisAction;
                if (playerData.built_structures.house) {
                     const houseXpPerk = STRUCTURE_DATA.house.perks.find(p => p.type === "global_xp_boost");
                    if (houseXpPerk) {
                        displayXpGained *= (1 + houseXpPerk.value);
                    }
                }
                displayXpGained = Math.floor(displayXpGained);
                
                logMessage(`+${displayXpGained} Mining XP. ${logMsg}`, oreData.color, oreData.emoji);

                playerData.mining_xp += displayXpGained;
                grantUniversalXP(totalXpGainedThisAction);

            } else {
                 logMessage(`Got no ore this time. (+0 Mining XP)`, "fore-yellow", "");
            } 
            
            playSound(skillRoundSound); 
            const leveledUp = handleLevelUp("mining_xp", oldLevel);
            if (leveledUp) {
                if (playerData.permits && playerData.permits.miner) { // Check for miner permit
                    logMessage("Mining Level up! Miner's Permit keeps you digging!", "fore-green", "");
                    // Action continues, no need to call stopAutoMining()
                } else {
                    logMessage("Mining level up! Action stopped. Get a Miner's Permit to continue mining through level ups.", "fore-blue", "");
                    stopAutoMining(); // Stop if no Miner's Permit
                }
            }
            savePlayerData();
            updateHud();
            // Update inventory count display for the current ore
            const countSpan = document.getElementById(`inv-count-mn-${currentMiningTarget.replace(/\s+/g, '-')}`);
            if (countSpan) {
                countSpan.textContent = playerData.inventory[oreData.item_name] || 0;
            }
             if (leveledUp && !isAutoMining) return; 
        }

        // --- Action: Blacksmithing (Modified for Shed Perk & new interaction) ---
        function showBlacksmithingMenu() {
            stopAllAutoActions();
            showSection('blacksmithing-menu-section');
        }
        
        function calculateMaxCraftableForBar(barName) {
            const bar = BAR_DATA[barName];
            if (!bar) return 0;
            let maxSets = Infinity;
            for (const ore in bar.recipe) {
                const oreOnHand = playerData.inventory[ore] || 0;
                const oreNeededPerSet = bar.recipe[ore];
                if (oreNeededPerSet === 0) continue;
                maxSets = Math.min(maxSets, Math.floor(oreOnHand / oreNeededPerSet));
            }
            return maxSets === Infinity ? 0 : maxSets;
        }

        function showSmeltingMenu() {
            if (!isAutoSmelting) { 
                stopAllAutoActions();
                currentSmeltingTarget = null;
            }
            const listDiv = document.getElementById('available-bars-to-smelt');
            listDiv.innerHTML = '<div class="section-title">Available Bars to Smelt</div>';
            
            const bsLvl = getLevelFromXp(playerData.blacksmithing_xp);
            let canSmeltAnythingAtAll = false; 

            for (const barName in BAR_DATA) {
                const bar = BAR_DATA[barName];
                let recipeString = "";
                for(const ore in bar.recipe) {
                    recipeString += `${bar.recipe[ore]} ${titleCase(ore)} (${playerData.inventory[ore] || 0}), `;
                }
                recipeString = recipeString.slice(0, -2); 

                const maxCraftableNow = calculateMaxCraftableForBar(barName);
                const canMakeAtLeastOne = maxCraftableNow > 0;
                
                const levelReqColor = bsLvl >= bar.level_req ? 'fore-green' : 'fore-red';
                const currentStock = playerData.inventory[barName] || 0;
                const itemDiv = document.createElement('div');
                itemDiv.className = `smeltable-item-list item ${bar.color}`;
                itemDiv.id = `smeltable-item-div-${barName.replace(/\s+/g, '-')}`; 

                itemDiv.innerHTML = `
                    <span class="item-details-left">
                        ${bar.emoji} ${titleCase(barName)} (XP: ${bar.xp_gain})
                        <br><small>Requires: ${recipeString} - <span class="${levelReqColor}">Lvl: ${bar.level_req} BS</span> - Max: <span id="max-craftable-${barName.replace(/\s+/g, '-')}">${maxCraftableNow}</span></small>
                    </span>
                    <span class="resource-inventory-count">
                        <span id="inv-count-smelt-${barName.replace(/\s+/g, '-')}">${currentStock}</span>
                    </span>
                `;

                if (isAutoSmelting && currentSmeltingTarget === barName) {
                    itemDiv.classList.add('active-smelting-item');
                }
                if (bsLvl >= bar.level_req && canMakeAtLeastOne) {
                    itemDiv.onclick = () => selectBarForSmelting(barName);
                    canSmeltAnythingAtAll = true;
                } else {
                    itemDiv.style.cursor = 'not-allowed';
                    itemDiv.title = bsLvl < bar.level_req ? 'BS level too low' : 'Not enough materials';
                    itemDiv.style.opacity = "0.6";
                }
                listDiv.appendChild(itemDiv);
            }

            if (!canSmeltAnythingAtAll && Object.keys(BAR_DATA).length > 0) listDiv.innerHTML += "<p>No bars you can currently smelt (check level & materials).</p>";
            else if (Object.keys(BAR_DATA).length === 0) listDiv.innerHTML += "<p>No bar recipes known.</p>";
            
            showSection('smelting-section');
        }

        function selectBarForSmelting(barName) {
            if (isAutoSmelting && currentSmeltingTarget === barName) {
                stopAutoSmelting();
            } else {
                if (isAutoSmelting) {
                    stopAutoSmelting();
                }
                startAutoSmelting(barName);
            }
        }

        function startAutoSmelting(barName) {
            if(!barName) { logMessage("No bar selected to smelt.", "fore-red", ""); return false; }
            document.querySelectorAll('.active-smelting-item').forEach(el => el.classList.remove('active-smelting-item'));
            
            const barData = BAR_DATA[barName]; 
            if (!barData) { logMessage("Error: Bar data not found for " + barName, "fore-red", ""); currentSmeltingTarget = null; return false; }
            currentSmeltingTarget = barName; 

            const currentBsLvl = getLevelFromXp(playerData.blacksmithing_xp);
            if(currentBsLvl < barData.level_req) {
                logMessage(`BS Lvl (${currentBsLvl}) too low for ${titleCase(currentSmeltingTarget)}. Req: ${barData.level_req}`, "fore-red", "");
                currentSmeltingTarget = null; return false;
            }

            maxSmeltableForCurrentTarget = calculateMaxCraftableForBar(currentSmeltingTarget);
            if (maxSmeltableForCurrentTarget <= 0) {
                logMessage(`Not enough materials to smelt any ${titleCase(currentSmeltingTarget)}.`, "fore-red", "");
                currentSmeltingTarget = null; return false;
            }

            isAutoSmelting = true; 
            const barListItem = document.getElementById(`smeltable-item-div-${currentSmeltingTarget.replace(/\s+/g, '-')}`);
            if (barListItem) barListItem.classList.add('active-smelting-item');
            logMessage(`Auto-smelting ${titleCase(currentSmeltingTarget)}... (Up to ${maxSmeltableForCurrentTarget} times)`, "fore-cyan");
            
            let interval = BASE_CRAFT_INTERVAL;
            if (playerData.built_structures.shed && STRUCTURE_DATA.shed.perk_effect.type === "crafting_speed_boost") { // Specific check for shed
                interval *= (1 - STRUCTURE_DATA.shed.perk_effect.value);
            }
            if (playerData.built_structures.stronghold) {
                const speedPerk = STRUCTURE_DATA.stronghold.perks.find(p => p.type === "global_skill_speed_boost");
                if (speedPerk) interval *= (1 - speedPerk.value);
            }
            if (autoSmeltingInterval) clearInterval(autoSmeltingInterval);
            autoSmeltingInterval = setInterval(singleSmeltAction, interval);
            return true;
        }

        function stopAutoSmelting() {
            if(isAutoSmelting) {
                isAutoSmelting = false;
                clearInterval(autoSmeltingInterval);
                autoSmeltingInterval = null;
                if (currentSmeltingTarget) {
                    const barListItem = document.getElementById(`smeltable-item-div-${currentSmeltingTarget.replace(/\s+/g, '-')}`);
                    if (barListItem) { // Check if the element exists
                        barListItem.classList.remove('active-smelting-item');
                    }
                }
                logMessage("Auto-smelting stopped.", "fore-yellow", "");
            }
        }

        function singleSmeltAction() {
            if(!isAutoSmelting || !currentSmeltingTarget) { stopAutoSmelting(); return; }

            const barData = BAR_DATA[currentSmeltingTarget];
            maxSmeltableForCurrentTarget = calculateMaxCraftableForBar(currentSmeltingTarget); 

            if (maxSmeltableForCurrentTarget <= 0) {
                logMessage(`Ran out of materials for ${titleCase(currentSmeltingTarget)}. Stopping.`, "fore-red", "");
                stopAutoSmelting();
                showSmeltingMenu(); 
                return;
            }

            for(const ore in barData.recipe) {
                playerData.inventory[ore] -= barData.recipe[ore];
            }

            let barsMade = 1;
            if(isPerkActive("advancedSmelting") && Math.random() < PERK_DATA.advancedSmelting.value) {
                barsMade++;
                logMessage("Bonus! Advanced Smelting produced an extra bar!", "fore-magenta", "");
            }

            playerData.inventory[currentSmeltingTarget] = (playerData.inventory[currentSmeltingTarget] || 0) + barsMade;
            const oldLevel = getLevelFromXp(playerData.blacksmithing_xp);
            
            let xpGainedRaw = barData.xp_gain; // Store raw XP before House perk
            let xpGainedDisplay = xpGainedRaw; 
            if (playerData.built_structures.house) {
                const houseXpPerk = STRUCTURE_DATA.house.perks.find(p => p.type === "global_xp_boost");
                if(houseXpPerk) xpGainedDisplay *= (1 + houseXpPerk.value);
            }
            xpGainedDisplay = Math.floor(xpGainedDisplay);

            playerData.blacksmithing_xp += xpGainedDisplay;
            grantUniversalXP(xpGainedRaw); // Pass raw XP to universal XP function

            logMessage(`Smelted ${barsMade} ${titleCase(currentSmeltingTarget)}! (+${xpGainedDisplay} BS XP)`, barData.color, "");
            playSound(skillRoundSound);

            // Store oldLevel before handleLevelUp modifies transientLevelUpInfo potentially
            const leveledUp = handleLevelUp("blacksmithing_xp", oldLevel); // handleLevelUp returns true if leveled up

            if (leveledUp) {
                if (playerData.permits && playerData.permits.blacksmith) {
                    logMessage("Blacksmithing Level up! Royal Charter allows continuous smelting!", "fore-green", "");
                    // Action continues
                } else {
                    logMessage("Blacksmithing level up! Action stopped. Get a Blacksmith's Royal Charter to continue.", "fore-blue", "");
                    stopAutoSmelting(); // This will log "Auto-smelting stopped."
                                        // handleLevelUp already logs "Congrats!"
                    return; // Exit early, stopAutoSmelting handles saving and HUD
                }
            }
            // If not leveled up, or leveled up with permit, continue to savePlayerData etc.
            savePlayerData();
            updateHud();
            
            const itemDivToUpdate = document.getElementById(`smeltable-item-div-${currentSmeltingTarget.replace(/\s+/g, '-')}`);
            if (itemDivToUpdate) {
                let newRecipeString = "";
                 for(const ore in barData.recipe) {
                    newRecipeString += `${barData.recipe[ore]} ${titleCase(ore)} (${playerData.inventory[ore] || 0}), `;
                }
                newRecipeString = newRecipeString.slice(0, -2);
                const newMaxCraftableDisplay = calculateMaxCraftableForBar(currentSmeltingTarget);
                const bsLvl = getLevelFromXp(playerData.blacksmithing_xp);
                const levelReqColor = bsLvl >= barData.level_req ? 'fore-green' : 'fore-red';
                const newStockCount = playerData.inventory[currentSmeltingTarget] || 0;

                // Reconstruct innerHTML matching the new structure in showSmeltingMenu
                itemDivToUpdate.innerHTML = `
                    <span class="item-details-left">
                        ${barData.emoji} ${titleCase(currentSmeltingTarget)} (XP: ${barData.xp_gain})
                        <br><small>Requires: ${newRecipeString} - <span class="${levelReqColor}">Lvl: ${barData.level_req} BS</span> - Max: <span id="max-craftable-${currentSmeltingTarget.replace(/\s+/g, '-')}">${newMaxCraftableDisplay}</span></small>
                    </span>
                    <span class="resource-inventory-count">
                        <span id="inv-count-smelt-${currentSmeltingTarget.replace(/\s+/g, '-')}">${newStockCount}</span>
                    </span>
                `;
                 if (newMaxCraftableDisplay === 0 || bsLvl < barData.level_req) {
                    itemDivToUpdate.style.cursor = 'not-allowed';
                    itemDivToUpdate.title = bsLvl < barData.level_req ? 'BS level too low' : 'Not enough materials';
                    itemDivToUpdate.style.opacity = "0.6";
                    itemDivToUpdate.onclick = null; 
                } else { 
                    itemDivToUpdate.style.cursor = 'pointer';
                    itemDivToUpdate.title = '';
                    itemDivToUpdate.style.opacity = "1";
                    itemDivToUpdate.onclick = () => selectBarForSmelting(currentSmeltingTarget);
                }
            }

            if (calculateMaxCraftableForBar(currentSmeltingTarget) <= 0) { 
                 logMessage(`No more materials for ${titleCase(currentSmeltingTarget)}. Auto-smelting stopped.`, "fore-yellow", "");
                 stopAutoSmelting();
            }
        }


        // Smithing (Modified for Shed Perk & new interaction)
        function calculateMaxCraftableForSword(swordName) {
            const sword = SWORD_DATA[swordName];
            if (!sword) return 0;
            let maxSets = Infinity;
            for (const bar in sword.recipe) {
                const barsOnHand = playerData.inventory[bar] || 0;
                const barsNeededPerSet = isPerkActive("masterSmith") && sword.recipe[bar] > 1 ?
                                          Math.max(1, sword.recipe[bar] - PERK_DATA.masterSmith.value) :
                                          sword.recipe[bar];
                if (barsNeededPerSet === 0) continue;
                maxSets = Math.min(maxSets, Math.floor(barsOnHand / barsNeededPerSet));
            }
            return maxSets === Infinity ? 0 : maxSets;
        }
        function showSmithingMenu() {
            if (!isAutoSmithing) { // Only stop if not currently auto-smithing (i.e., user navigated here)
                stopAllAutoActions();
                currentSmithingTarget = null;
            }
            const listDiv = document.getElementById('available-items-to-smith');
            listDiv.innerHTML = '<div class="section-title">Available Items to Smith</div>';

            const bsLvl = getLevelFromXp(playerData.blacksmithing_xp);
            let canSmithAnything = false;

            for (const itemName in SWORD_DATA) {
                const itemData = SWORD_DATA[itemName];
                let recipeString = "";
                const maxCraftableNow = calculateMaxCraftableForSword(itemName);
                const canMakeAtLeastOne = maxCraftableNow > 0;
                
                for(const bar in itemData.recipe) {
                    const requiredAmount = isPerkActive("masterSmith") && itemData.recipe[bar] > 1 ?
                                          Math.max(1, itemData.recipe[bar] - PERK_DATA.masterSmith.value) :
                                          itemData.recipe[bar];
                    recipeString += `${requiredAmount} ${titleCase(bar)} (${playerData.inventory[bar] || 0}), `;
                }
                recipeString = recipeString.slice(0, -2);

                const levelReqColor = bsLvl >= itemData.smith_level_req ? 'fore-green' : 'fore-red';
                const itemDiv = document.createElement('div');
                let lifestealInfo = "";
                if (itemData.lifesteal_chance && itemData.lifesteal_amount) {
                    const lsChanceDisplay = itemData.lifesteal_chance * 100;
                    const lsAmountDisplay = Array.isArray(itemData.lifesteal_amount) ? `${itemData.lifesteal_amount[0]}-${itemData.lifesteal_amount[1]}` : itemData.lifesteal_amount;
                    lifestealInfo = `<br><small class="fore-magenta">Lifesteal: ${lsChanceDisplay.toFixed(0)}% for ${lsAmountDisplay} HP</small>`;
                }
                itemDiv.className = `smithable-item-list item ${itemData.color}`;
                const currentStock = playerData.inventory[itemName] || 0;
                itemDiv.innerHTML = `
                    <span class="item-details-left"> <!-- Details on the left -->
                        ${itemData.emoji} ${titleCase(itemName)}
                        <br><small>XP: ${itemData.smith_level_req * 5} - Dmg: ${itemData.min_dmg}-${itemData.max_dmg}</small>
                        <br><small>Requires: ${recipeString} - <span class="${levelReqColor}">Lvl: ${itemData.smith_level_req} BS</span> - Max: <span id="max-craftable-smith-${itemName.replace(/\s+/g, '-')}">${maxCraftableNow}</span></small>${lifestealInfo}
                    </span>
                    <span class="resource-inventory-count"> <!-- Count on the right -->
                        <span id="inv-count-smith-${itemName.replace(/\s+/g, '-')}">${currentStock}</span>
                    </span>
                `;
                itemDiv.id = `smithable-item-div-${itemName.replace(/\s+/g, '-')}`;
                if (isAutoSmithing && currentSmithingTarget === itemName) {
                    itemDiv.classList.add('active-smithing-item');
                }
                if (bsLvl >= itemData.smith_level_req && canMakeAtLeastOne) {
                    itemDiv.onclick = () => selectItemForSmithing(itemName);
                    canSmithAnything = true;
                } else {
                    itemDiv.style.cursor = 'not-allowed';
                    itemDiv.title = bsLvl < itemData.smith_level_req ? 'BS level too low' : 'Not enough materials';
                    itemDiv.style.opacity = "0.6";
                }
                listDiv.appendChild(itemDiv);
            }
             if (!canSmithAnything && Object.keys(SWORD_DATA).length > 0) listDiv.innerHTML += "<p>No items you can currently smith (check level & materials).</p>";
            else if (Object.keys(SWORD_DATA).length === 0) listDiv.innerHTML += "<p>No item recipes known for smithing.</p>";
            
            showSection('smithing-section');
        }
        
        function selectItemForSmithing(itemName) {
            if (isAutoSmithing && currentSmithingTarget === itemName) {
                stopAutoSmithing(); // If clicking the currently auto-smithing item, stop it.
            } else {
                if (isAutoSmithing) { // If auto-smithing something else, stop that first.
                    stopAutoSmithing();
                }
                startAutoSmithing(itemName); // Start (or restart) auto-smithing for the selected item.
            }
        }

        function startAutoSmithing(itemName) {
            if(!itemName) { logMessage("No item selected to smith.", "fore-red", ""); return false; }
            document.querySelectorAll('.active-smithing-item').forEach(el => el.classList.remove('active-smithing-item'));
            currentSmithingTarget = itemName; 
            
            const itemData = SWORD_DATA[currentSmithingTarget]; 
            const currentBsLvl = getLevelFromXp(playerData.blacksmithing_xp);
            if(currentBsLvl < itemData.smith_level_req) {
                logMessage(`BS Lvl (${currentBsLvl}) too low for ${titleCase(currentSmithingTarget)}. Req: ${itemData.smith_level_req}`, "fore-red", "");
                currentSmithingTarget = null; return false;
            }

            if (calculateMaxCraftableForSword(currentSmithingTarget) <= 0) {
                logMessage(`Not enough materials to smith any ${titleCase(currentSmithingTarget)}.`, "fore-red", "");
                currentSmithingTarget = null; return false;
            }
 
            isAutoSmithing = true;
            const smithListItem = document.getElementById(`smithable-item-div-${currentSmithingTarget.replace(/\s+/g, '-')}`);
            if (smithListItem) smithListItem.classList.add('active-smithing-item');
            logMessage(`Auto-smithing ${titleCase(currentSmithingTarget)}...`, "fore-cyan");

            let interval = BASE_CRAFT_INTERVAL;
            if (playerData.built_structures.shed && STRUCTURE_DATA.shed.perk_effect.type === "crafting_speed_boost") { // Specific check for shed
                interval *= (1 - STRUCTURE_DATA.shed.perk_effect.value);
            }
            if (playerData.built_structures.stronghold) {
                const speedPerk = STRUCTURE_DATA.stronghold.perks.find(p => p.type === "global_skill_speed_boost");
                if (speedPerk) interval *= (1 - speedPerk.value);
            }
            if(autoSmithingInterval) clearInterval(autoSmithingInterval);
            autoSmithingInterval = setInterval(singleSmithAction, interval);
            return true;
        }

        function stopAutoSmithing() {
            if(isAutoSmithing) {
                isAutoSmithing = false;
                clearInterval(autoSmithingInterval);
                autoSmithingInterval = null;
                if(currentSmithingTarget) {
                    const smithListItem = document.getElementById(`smithable-item-div-${currentSmithingTarget.replace(/\s+/g, '-')}`);
                    if (smithListItem) { // Check if the element exists
                        smithListItem.classList.remove('active-smithing-item');
                    }
                }
                logMessage("Auto-smithing stopped.", "fore-yellow", "");
            }
        }

        function singleSmithAction() {
            if(!isAutoSmithing || !currentSmithingTarget) { stopAutoSmithing(); return; }
            
            const itemData = SWORD_DATA[currentSmithingTarget]; 
            if (calculateMaxCraftableForSword(currentSmithingTarget) <= 0) {
                logMessage(`Ran out of materials for ${titleCase(currentSmithingTarget)}. Stopping.`, "fore-red", "");
                stopAutoSmithing();
                showSmithingMenu(); // Refresh the menu to show updated counts and disable if needed
                return;
            }

            for(const bar in itemData.recipe) {
                const requiredAmount = isPerkActive("masterSmith") && itemData.recipe[bar] > 1 ? 
                                      Math.max(1, itemData.recipe[bar] - PERK_DATA.masterSmith.value) : 
                                      itemData.recipe[bar];
                playerData.inventory[bar] -= requiredAmount;
            }
            
            playerData.inventory[currentSmithingTarget] = (playerData.inventory[currentSmithingTarget] || 0) + 1;
            
            let xpGainRaw = itemData.smith_level_req * 5; 
            let xpGainedDisplay = xpGainRaw; 
            if (playerData.built_structures.house) {
                const houseXpPerk = STRUCTURE_DATA.house.perks.find(p => p.type === "global_xp_boost");
                if(houseXpPerk) xpGainedDisplay *= (1 + houseXpPerk.value);
            }
            xpGainedDisplay = Math.floor(xpGainedDisplay);

            const oldLevel = getLevelFromXp(playerData.blacksmithing_xp);
            playerData.blacksmithing_xp += xpGainedDisplay;
            grantUniversalXP(xpGainRaw); 

            logMessage(`Smithed 1 ${titleCase(currentSmithingTarget)}! (+${xpGainedDisplay} BS XP)`, itemData.color, "");
            playSound(skillRoundSound);

            // Store oldLevel before handleLevelUp modifies transientLevelUpInfo potentially
            const leveledUp = handleLevelUp("blacksmithing_xp", oldLevel); // handleLevelUp returns true if leveled up

            if (leveledUp) {
                if (playerData.permits && playerData.permits.blacksmith) {
                    logMessage("Blacksmithing Level up! Royal Charter allows continuous smithing!", "fore-green", "");
                    // Action continues
                } else {
                    logMessage("Blacksmithing level up! Action stopped. Get a Blacksmith's Royal Charter to continue.", "fore-blue", "");
                    stopAutoSmithing(); // This will log "Auto-smithing stopped."
                                        // handleLevelUp already logs "Congrats!"
                    return; // Exit early, stopAutoSmithing handles saving and HUD
                }
            }
            // If not leveled up, or leveled up with permit, continue to savePlayerData etc.
            savePlayerData();
            updateHud();
            // Instead of full refresh, update the specific item in the list
            updateSmithableItemDisplay(currentSmithingTarget);
            if (!checkCanStillSmith(currentSmithingTarget)) { // If materials run out
                stopAutoSmithing();
            }
        }

        // --- Action: Combat (Modified for Monster Gold Drop & Mansion Perk) --- 
        function showCombat() {
            stopAllAutoActions();
            const monsterListDiv = document.getElementById('available-monsters');
            monsterListDiv.innerHTML = '<div class="section-title">Attackable Monsters</div>';
            document.getElementById('combat-arena').classList.add('hidden');

            // Display Combat Permit Status
            const combatPermitStatusDiv = document.getElementById('combat-permit-status');
            combatPermitStatusDiv.innerHTML = ''; // Clear previous
            if (playerData.permits && playerData.permits.hunter) {
                combatPermitStatusDiv.innerHTML = " Hunter's Permit Active: Continuous combat through Attack level ups!";
            }

            const atkLvl = getLevelFromXp(playerData.attack_xp);
            let available = false;
            ALL_MONSTER_NAMES.forEach(monsterName => {
                const monster = MONSTER_DATA[monsterName];
                if (atkLvl >= monster.level_req) {
                    available = true;
                    const monsterDiv = document.createElement('div');
                    monsterDiv.className = `item ${monster.color}`; 
                    monsterDiv.id = `monster-list-item-${monsterName.replace(/\s+/g, '-').toLowerCase()}`;
                    monsterDiv.innerHTML = `${monster.emoji} ${titleCase(monsterName)} (Lvl: ${monster.level_req}, HP: ${monster.hp})`;
                    monsterDiv.onclick = () => selectMonsterForCombat(monsterName);
                    monsterListDiv.appendChild(monsterDiv);
                }
            });
            if (!available) monsterListDiv.innerHTML += "<p>No monsters available at your level.</p>";
            showSection('combat-section');
        }

        function selectMonsterForCombat(monsterName) {
            if (isAutoAttacking && currentMonsterTarget === monsterName) {
                stopAutoAttack(); 
            } else {
                if (isAutoAttacking) {
                    stopAutoAttack(); 
                }
                // currentMonsterTarget = monsterName; // This is set inside startAutoAttack
                startAutoAttack(monsterName); 
            }
        }
        
        function stopCombatAndReturn() {
            stopAutoAttack(); 
            showActionsMenu();
        }
        
        function startAutoAttack(monsterName) { 
            if (playerData.hp <= 0) { logMessage("You are too weak to fight. Heal up!", "fore-red", ""); return; }
            if (!monsterName) { logMessage("No monster target specified for auto-attack.", "fore-red", ""); return; }
            currentMonsterTarget = monsterName; // Set target here

            isAutoAttacking = true;
            logMessage(`Auto-attacking ${titleCase(currentMonsterTarget)}...`, "fore-red");
            
            // Visually update the monster list
            const monsterListContainer = document.getElementById('available-monsters');
            if (monsterListContainer) {
                const monsterItems = monsterListContainer.querySelectorAll('.item');
                const targetMonsterId = `monster-list-item-${currentMonsterTarget.replace(/\s+/g, '-').toLowerCase()}`;
                for (let item of monsterItems) {
                    if (item.id === targetMonsterId) {
                        item.classList.remove('hidden'); // Ensure it's visible
                        item.classList.add('attacking-monster-list-item');
                    } else {
                        item.classList.add('hidden'); // Hide other monsters
                        item.classList.remove('attacking-monster-list-item'); 
                    }
                }
            }

            prepareCombatArena(currentMonsterTarget); 
            if(autoAttackInterval) clearInterval(autoAttackInterval);
            autoAttackInterval = setInterval(singleCombatRound, BASE_COMBAT_INTERVAL); 
        }

        function stopAutoAttack() {
            if (isAutoAttacking) { // Only proceed if it was actually attacking
                isAutoAttacking = false;
                clearInterval(autoAttackInterval);
                autoAttackInterval = null;
                
                if (currentMonsterTarget) { 
                    const monsterListItem = document.getElementById(`monster-list-item-${currentMonsterTarget.replace(/\s+/g, '-').toLowerCase()}`);
                    if (monsterListItem) monsterListItem.classList.remove('attacking-monster-list-item');
                }
                logMessage("Auto-attack stopped.", "fore-yellow", ""); // Log that it stopped

                const monsterListContainer = document.getElementById('available-monsters');
                if (monsterListContainer) { // Added null check
                    const monsterItems = monsterListContainer.querySelectorAll('.item');
                    for (let item of monsterItems) {
                        item.classList.remove('hidden');
                    }
                }
            }
        }
        
        function prepareCombatArena(monsterName, isRespawn = false) {
            if (!MONSTER_DATA[monsterName]) { console.error("Invalid monster name for arena:", monsterName); return; }
            const monster = MONSTER_DATA[monsterName];
            currentMonsterHP = monster.hp;

            const monsterDisplayEl = document.getElementById('monster-display-combat');
            monsterDisplayEl.innerHTML = ''; // Clear previous content (e.g., if it wasn't a bar before)

            const barFillDiv = document.createElement('div');
            barFillDiv.className = 'monster-hp-bar-fill';
            monsterDisplayEl.appendChild(barFillDiv);

            const barTextDiv = document.createElement('div');
            barTextDiv.className = 'monster-hp-bar-text';
            monsterDisplayEl.appendChild(barTextDiv);

            if (isRespawn) {
                barTextDiv.innerHTML = `<span class="emoji"></span> Spawning ${titleCase(monsterName)}...`;
                barFillDiv.style.width = '0%'; // Start empty for respawn
                // Optional: change fill color during spawn animation
                // barFillDiv.style.backgroundColor = '#ffc107'; // A yellow/orange for spawning

                setTimeout(() => {
                    barTextDiv.innerHTML = `<span class="emoji">${monster.emoji}</span> ${titleCase(monsterName)} (${currentMonsterHP}/${monster.hp} HP)`;
                    barFillDiv.style.width = '100%';
                    // barFillDiv.style.backgroundColor = '#28a745'; // Back to green
                }, 750); 
            } else {
                barTextDiv.innerHTML = `<span class="emoji">${monster.emoji}</span> ${titleCase(monsterName)} (${currentMonsterHP}/${monster.hp} HP)`;
                barFillDiv.style.width = '100%';
            }
            
            // Ensure the container has the correct base class if it was removed or changed
            // monsterDisplayEl.className = 'monster-display'; // This might re-apply flex, be careful. The specific ID CSS should handle it.

            document.getElementById('player-hp-combat').textContent = `${playerData.hp}/${getMaxHp(getLevelFromXp(playerData.attack_xp))}`;
            document.getElementById('combat-arena').classList.remove('hidden');
        }
        
        function singleCombatRound() {
            if (!currentMonsterTarget || playerData.hp <= 0) {
                stopAutoAttack();
                if (playerData.hp <= 0 && currentMonsterTarget) {
                    logMessage("Player defeated. Combat ended.", "fore-red", "");
                    playSound(playerDieSound); 
                }
                else if (!currentMonsterTarget && isAutoAttacking) logMessage("Auto-attack stopped: No target.", "fore-yellow", "");
                return;
            }

            const monster = MONSTER_DATA[currentMonsterTarget];
            let playerAtkLvl = getLevelFromXp(playerData.attack_xp); // Use let for oldAtkLvl later
            
            const monsterDisplayEl = document.getElementById('monster-display-combat');
            const barFillDiv = monsterDisplayEl.querySelector('.monster-hp-bar-fill');
            const barTextDiv = monsterDisplayEl.querySelector('.monster-hp-bar-text');
            const playerMaxHp = getMaxHp(playerAtkLvl);

            let weaponName = "fists";
            let weaponStats = TOOL_DATA.axe.fists; 
            
            const equippedWeapon = playerData.inventory.weapon;
            const equippedAxe = playerData.inventory.axe;
            const equippedPickaxe = playerData.inventory.pickaxe;

            if (equippedWeapon !== "none" && SWORD_DATA[equippedWeapon]) {
                weaponName = equippedWeapon;
                weaponStats = SWORD_DATA[equippedWeapon];
            } else if (equippedAxe !== "none" && TOOL_DATA.axe[equippedAxe]) {
                weaponName = equippedAxe;
                weaponStats = TOOL_DATA.axe[equippedAxe];
            } else if (equippedPickaxe !== "none" && TOOL_DATA.pickaxe[equippedPickaxe]) {
                weaponName = equippedPickaxe;
                weaponStats = TOOL_DATA.pickaxe[equippedPickaxe];
            }
            
            let playerDmg = Math.floor(Math.random() * (weaponStats.max_dmg - weaponStats.min_dmg + 1)) + weaponStats.min_dmg;
            
            let finalPlayerDmg = playerDmg;
            if (weaponName.includes("2h sword")) { 
                if(isPerkActive("weaponMaster1")) {
                    finalPlayerDmg *= (1 + PERK_DATA.weaponMaster1.value);
                }
            }
            // Apply Stronghold global damage boost
            if (playerData.built_structures.stronghold) {
                const damagePerk = STRUCTURE_DATA.stronghold.perks.find(p => p.type === "global_damage_boost");
                if (damagePerk) finalPlayerDmg *= (1 + damagePerk.value);
            }

            let critMultiplier = 1.0;
            if(isPerkActive("preciseStrikes1") && Math.random() < PERK_DATA.preciseStrikes1.value) {
                critMultiplier = PERK_DATA.preciseStrikes1.crit_multiplier;
                logMessage("CRITICAL HIT!", "fore-lightred_ex", "");
            }
            playerDmg = Math.floor(finalPlayerDmg * critMultiplier);


            let hitChance = 0.80 + Math.max(0, (playerAtkLvl - monster.level_req) * 0.001);
            hitChance = Math.min(0.95, hitChance);

            if (Math.random() < hitChance) {
                currentMonsterHP -= playerDmg;
                logMessage(`You hit ${titleCase(currentMonsterTarget)} with ${titleCase(weaponName)} for ${playerDmg} damage!`, "fore-yellow", "");
                
                let effectiveLifestealChance = weaponStats.lifesteal_chance || 0;
                let effectiveLifestealAmount = weaponStats.lifesteal_amount || 0;

                if (weaponName.includes("2h sword")) { 
                    if(isPerkActive("vampiricEdge1")) {
                        effectiveLifestealChance += PERK_DATA.vampiricEdge1.value;
                    }
                }

                if (effectiveLifestealChance > 0 && Math.random() < effectiveLifestealChance) {
                    let stolenHp = 0;
                    if (Array.isArray(effectiveLifestealAmount)) {
                        stolenHp = Math.floor(Math.random() * (effectiveLifestealAmount[1] - effectiveLifestealAmount[0] + 1)) + effectiveLifestealAmount[0];
                    } else {
                        stolenHp = effectiveLifestealAmount;
                    }
                    const oldHp = playerData.hp;
                    playerData.hp = Math.min(playerMaxHp, playerData.hp + stolenHp);
                    if (playerData.hp > oldHp) {
                        logMessage(`Lifesteal! +${playerData.hp - oldHp} HP.`, "fore-green", "");
                    }
                }

            } else {
                logMessage(`You missed ${titleCase(currentMonsterTarget)}!`, "fore-blue", "");
            }
            
            if (barFillDiv && barTextDiv) {
                const hpPercent = (currentMonsterHP / monster.hp) * 100;
                barFillDiv.style.width = Math.max(0, hpPercent) + '%';
                barTextDiv.innerHTML = `<span class="emoji">${monster.emoji}</span> ${titleCase(currentMonsterTarget)} (${Math.max(0, currentMonsterHP)}/${monster.hp} HP)`;
            }

            if (currentMonsterHP <= 0) {
                logMessage(`${titleCase(currentMonsterTarget)} defeated!`, monster.color, "");
                playSound(monsterKillSound);

                if (barTextDiv) {
                    barTextDiv.innerHTML = `<span class="emoji"></span> ${titleCase(currentMonsterTarget)} Defeated!`;
                }
                // barFillDiv width is already handled by the hpPercent calculation above, will be 0%
                const oldAtkLvl = playerAtkLvl;
                let xpGainedRaw = monster.attack_xp;
                let xpGainedDisplay = xpGainedRaw; 

                if (playerData.built_structures.house) {
                    const houseXpPerk = STRUCTURE_DATA.house.perks.find(p => p.type === "global_xp_boost");
                    if (houseXpPerk) {
                        xpGainedDisplay *= (1 + houseXpPerk.value);
                    }
                }
                playerData.attack_xp += Math.floor(xpGainedDisplay);
                grantUniversalXP(xpGainedRaw); 

                logMessage(`Gained ${Math.floor(xpGainedDisplay)} Attack XP!`, "fore-green", "");
                
                handleLevelUp("attack_xp", oldAtkLvl);
                playerAtkLvl = getLevelFromXp(playerData.attack_xp); 

                // --- GOLD DROP LOGIC ---
                if (monster.gold_drop && monster.gold_drop[1] > 0) { 
                    let goldDropped = Math.floor(Math.random() * (monster.gold_drop[1] - monster.gold_drop[0] + 1)) + monster.gold_drop[0];
                    
                    if (playerData.built_structures.mansion) {
                        const mansionGoldPerk = STRUCTURE_DATA.mansion.perks.find(p => p.type === "monster_gold_drop_multiplier_chance");
                        if (mansionGoldPerk && Math.random() < mansionGoldPerk.value) {
                            goldDropped *= mansionGoldPerk.multiplier;
                            logMessage("Lavish Lifestyle proc! Gold drop doubled!", "fore-magenta", "");
                        }
                    }

                    if (goldDropped > 0) {
                        playerData.gold += goldDropped;
                        logMessage(`The ${titleCase(currentMonsterTarget)} dropped ${goldDropped} gold!`, "fore-yellow", "");
                    }
                }

                if (playerData.built_structures.house && currentMonsterTarget !== "chicken") {
                    const houseScaledGoldPerk = STRUCTURE_DATA.house.perks.find(p => p.type === "scaled_bonus_mob_gold_drop_chance");
                    if (houseScaledGoldPerk && monster.gold_drop && monster.gold_drop[1] > 0 && Math.random() < houseScaledGoldPerk.value) {
                        const baseGoldForScaling = Math.floor(Math.random() * (monster.gold_drop[1] - monster.gold_drop[0] + 1)) + monster.gold_drop[0];
                        const bonusScaledGold = Math.floor(baseGoldForScaling * houseScaledGoldPerk.bonus_gold_percentage_of_base);
                        if (bonusScaledGold > 0) {
                            playerData.gold += bonusScaledGold;
                            logMessage(`House bonus! +${bonusScaledGold} extra gold from ${titleCase(currentMonsterTarget)}!`, "fore-yellow", "");
                        }
                    }
                }

                monster.drops.forEach(drop => {
                    const isRare = drop.item_name.includes("gem") || drop.item_name.includes("heart") || ARMOR_DATA[drop.item_name];
                    const bonus = (playerAtkLvl * (isRare ? 0.001 : 0.005));
                    const capBonus = isRare ? 0.05 : 0.20;
                    const effBonus = Math.min(bonus, capBonus);
                    const dropChance = Math.min(0.95, drop.base_chance + effBonus);

                    if (Math.random() < dropChance || drop.always_drop_one) {
                        const quantity = Math.floor(Math.random() * (drop.quantity[1] - drop.quantity[0] + 1)) + drop.quantity[0];
                        if ( ARMOR_DATA[drop.item_name] && (playerData.inventory[drop.item_name] > 0 || playerData.inventory.chestplate === drop.item_name) ) {
                             return; 
                        }
                        playerData.inventory[drop.item_name] = (playerData.inventory[drop.item_name] || 0) + quantity;
                        logMessage(`Received ${quantity} ${titleCase(drop.item_name)}!`, "fore-magenta", "");
                    }
                });

                if (playerData.built_structures.stronghold) {
                    const healPerk = STRUCTURE_DATA.stronghold.perks.find(p => p.type === "heal_on_kill_percent");
                    if (healPerk) {
                        const healAmount = Math.floor(playerMaxHp * healPerk.value);
                        if(playerData.hp < playerMaxHp && healAmount > 0) { // Only heal if not full and healAmount > 0
                            const oldPlayerHpForHeal = playerData.hp;
                            playerData.hp = Math.min(playerMaxHp, playerData.hp + healAmount);
                            if (playerData.hp > oldPlayerHpForHeal) { // Check if actual healing occurred
                                logMessage(`Stronghold's Blessing! Healed ${playerData.hp - oldPlayerHpForHeal} HP.`, "fore-green", "");
                            }
                        }
                    }
                }

                savePlayerData();
                updateHud();

                if (!isAutoAttacking) { 
                    currentMonsterTarget = null; 
                    const monsterNameForID = monster.name ? monster.name : currentMonsterTarget; // Fallback if monster.name isn't defined for some reason
                    const defeatedMonsterListItem = document.getElementById(`monster-list-item-${monsterNameForID.replace(/\s+/g, '-').toLowerCase()}`);
                    if (defeatedMonsterListItem) defeatedMonsterListItem.classList.remove('attacking-monster-list-item');
                    setTimeout(() => {
                        document.getElementById('combat-arena').classList.add('hidden'); 
                        showCombat(); 
                    }, 1200); 
                } else {
                    setTimeout(() => {
                         prepareCombatArena(currentMonsterTarget, true); 
                    }, 1200); 
                }
                return; 
            }

            let monsterDmg;
            if (currentMonsterTarget === "chicken") { 
                monsterDmg = (Math.random() < 0.125) ? 2 : 1; 
            } else {
                const monsterMinDmg = Math.max(1, Math.floor(monster.level_req / 4));
                const monsterMaxDmg = Math.max(monsterMinDmg + 1, Math.floor(monster.level_req / 2));
                monsterDmg = Math.floor(Math.random() * (monsterMaxDmg - monsterMinDmg + 1)) + monsterMinDmg;
            }

            let monsterHitChance = 0.70 + Math.max(0, (monster.level_req - playerAtkLvl) * 0.01);
            const equippedChestplate = playerData.inventory.chestplate;
            if (equippedChestplate !== "none" && ARMOR_DATA[equippedChestplate]) {
                monsterHitChance -= ARMOR_DATA[equippedChestplate].defense;
            }
            monsterHitChance = Math.max(0.05, Math.min(0.95, monsterHitChance));
            
            if (Math.random() < monsterHitChance) {
                playerData.hp -= monsterDmg;
                logMessage(`${titleCase(currentMonsterTarget)} hits you for ${monsterDmg} damage!`, "fore-red", "");
            } else {
                logMessage(`${titleCase(currentMonsterTarget)} missed!`, "fore-blue", "");
            }
            document.getElementById('player-hp-combat').textContent = `${Math.max(0,playerData.hp)}/${playerMaxHp}`;

            if (playerData.hp <= 0) {
                logMessage("YOU DIED!", "fore-red", "");
                playSound(playerDieSound); 
                playerData.hp = Math.floor(playerMaxHp / 2); 
                playerData.gold = Math.max(0, playerData.gold - Math.floor(playerData.gold / 10) - 10); 
                logMessage("Respawned with penalty.", "fore-yellow", "");
                stopAutoAttack();
                savePlayerData();
                updateHud();
                currentMonsterTarget = null; 
                showCombat(); 
                return;
            }
            
            savePlayerData();
            updateHud();
        }
        
        
        function attemptAutoEat() {
            const playerMaxHp = getMaxHp(getLevelFromXp(playerData.attack_xp));
            if (playerData.hp >= playerMaxHp) return false; 

            let bestFood = null;
            let bestHealAmount = 0;

            for (const itemName in playerData.inventory) {
                if (FOOD_DATA[itemName] && playerData.inventory[itemName] > 0) {
                    if (FOOD_DATA[itemName].heal_amount > bestHealAmount) {
                        bestHealAmount = FOOD_DATA[itemName].heal_amount;
                        bestFood = itemName;
                    }
                }
            }

            if (bestFood) {
                logMessage(`HP critical! Auto-eating ${titleCase(bestFood)}...`, "fore-magenta", "");
                eatFoodItem(bestFood); 
                return true;
            }
            logMessage("HP critical, but no food to auto-eat!", "fore-red", "");
            return false;
        }

        // --- Action: Eat Food ---
        function showEatFood() {
            const foodListDiv = document.getElementById('available-food-list');
            foodListDiv.innerHTML = '<div class="section-title">Your Food</div>';
            const playerMaxHp = getMaxHp(getLevelFromXp(playerData.attack_xp));

            if (playerData.hp >= playerMaxHp) {
                foodListDiv.innerHTML += "<p class='fore-green'>HP is full!</p>";
                showSection('eat-food-section');
                return;
            }
            
            let hasFood = false;
            for (const itemName in playerData.inventory) {
                if (FOOD_DATA[itemName] && playerData.inventory[itemName] > 0) {
                    hasFood = true;
                    const food = FOOD_DATA[itemName];
                    const foodDiv = document.createElement('div');
                    foodDiv.className = 'food-item-list item'; 
                    foodDiv.innerHTML = `${food.emoji || ''} ${titleCase(itemName)} (x${playerData.inventory[itemName]}) - Heals: ${food.heal_amount}HP`;
                    foodDiv.onclick = () => eatFoodItem(itemName);
                    foodListDiv.appendChild(foodDiv);
                }
            }
            if (!hasFood) foodListDiv.innerHTML += "<p>You have no food.</p>";
            showSection('eat-food-section');
        }

        function eatFoodItem(itemName) {
            const food = FOOD_DATA[itemName];
            const playerMaxHp = getMaxHp(getLevelFromXp(playerData.attack_xp));
            
            if (playerData.hp >= playerMaxHp) {
                logMessage("HP is already full.", "fore-green", "");
                return;
            }
            if (playerData.inventory[itemName] > 0) {
                const oldHp = playerData.hp;
                playerData.hp = Math.min(playerMaxHp, playerData.hp + food.heal_amount);
                const actualHealed = playerData.hp - oldHp;
                playerData.inventory[itemName]--;
                
                logMessage(`Ate ${titleCase(itemName)}, +${actualHealed}HP. Current HP: ${playerData.hp}/${playerMaxHp}`, "fore-green", "");
                savePlayerData();
                updateHud();
                showEatFood(); 
            }
        }
        
        // --- Action: Cook Food (Modified for Shed Perk & new interaction) ---
        function showCookFood() {
            stopAllAutoActions();
            const cookListDiv = document.getElementById('cookable-items-list');
            cookListDiv.innerHTML = '<div class="section-title">Cookable Items</div>';
            currentCookingTarget = null;

            const ckLvl = getLevelFromXp(playerData.cooking_xp);
            let hasCookable = false;
            for (const rawItemName in COOKABLE_ITEMS) {
                if (playerData.inventory[rawItemName] > 0) {
                    hasCookable = true;
                    const cookDetails = COOKABLE_ITEMS[rawItemName];
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'cookable-item-list item'; 
                    const canCook = ckLvl >= cookDetails.level_req;
                    const reqColor = canCook ? 'fore-green' : 'fore-red';

                    itemDiv.innerHTML = `${cookDetails.emoji || ''} ${titleCase(rawItemName)} (x${playerData.inventory[rawItemName]}) 
                                         - <span class="${reqColor}">Req Lvl: ${cookDetails.level_req}</span>`;
                    itemDiv.id = `cookable-list-item-${rawItemName.replace(/\s+/g, '-')}`;
                    if (isAutoCooking && currentCookingTarget === rawItemName) {
                        itemDiv.classList.add('active-cooking-item');
                    }
                    if (canCook) {
                        itemDiv.onclick = () => selectRawItemForCooking(rawItemName);
                    } else {
                        itemDiv.style.cursor = 'not-allowed';
                        itemDiv.title = 'Cooking level too low';
                    }
                    cookListDiv.appendChild(itemDiv);
                }
            }
            if (!hasCookable) cookListDiv.innerHTML += "<p>You have nothing to cook.</p>";
            showSection('cook-food-section');
        }
        
        function selectRawItemForCooking(rawItemName) {
             if (isAutoCooking && currentCookingTarget === rawItemName) {
                stopAutoCooking();
            } else {
                if (isAutoCooking) {
                    stopAutoCooking();
                }
                startAutoCooking(rawItemName);
            }
        }
        
        function startAutoCooking(rawItemName) {
            if (!rawItemName) { logMessage("No item selected for cooking.", "fore-red"); return false; }
            document.querySelectorAll('.active-cooking-item').forEach(el => el.classList.remove('active-cooking-item'));
            currentCookingTarget = rawItemName; 

            if (playerData.inventory[currentCookingTarget] <= 0) { 
                logMessage(`No ${titleCase(currentCookingTarget)} to cook.`, "fore-red", "");
                stopAutoCooking(); currentCookingTarget = null; return false;
            }
            const cookDetails = COOKABLE_ITEMS[currentCookingTarget];
            const currentCookLvl = getLevelFromXp(playerData.cooking_xp);
            if (currentCookLvl < cookDetails.level_req) {
                 logMessage(`Cooking Lvl (${currentCookLvl}) too low for ${titleCase(currentCookingTarget)}. Req: ${cookDetails.level_req}`, "fore-red", "");
                currentCookingTarget = null; return false;
            }

            isAutoCooking = true;
            const cookListItem = document.getElementById(`cookable-list-item-${currentCookingTarget.replace(/\s+/g, '-')}`);
            if (cookListItem) cookListItem.classList.add('active-cooking-item'); 
            logMessage(`Auto-cooking ${titleCase(currentCookingTarget)}...`, "fore-cyan");
            
            let interval = BASE_CRAFT_INTERVAL;
            if (playerData.built_structures.shed && STRUCTURE_DATA.shed.perk_effect.type === "crafting_speed_boost") {
                interval *= (1 - STRUCTURE_DATA.shed.perk_effect.value);
            }
            if (playerData.built_structures.stronghold) {
                const speedPerk = STRUCTURE_DATA.stronghold.perks.find(p => p.type === "global_skill_speed_boost");
                if (speedPerk) interval *= (1 - speedPerk.value);
            }
            if(autoCookingInterval) clearInterval(autoCookingInterval);
            autoCookingInterval = setInterval(singleCookAction, interval);
            return true;
        }

        function stopAutoCooking() {
            if (isAutoCooking) {
                isAutoCooking = false;
                clearInterval(autoCookingInterval);
                autoCookingInterval = null;
                if (currentCookingTarget) {
                    const cookListItem = document.getElementById(`cookable-list-item-${currentCookingTarget.replace(/\s+/g, '-')}`);
                    if (cookListItem) { // Check if the element exists
                        cookListItem.classList.remove('active-cooking-item');
                    }
                }
                logMessage("Auto-cooking stopped.", "fore-yellow", "");
            }
        }

        function singleCookAction() {
            if (!isAutoCooking || !currentCookingTarget) { stopAutoCooking(); return; }
            if (playerData.inventory[currentCookingTarget] <= 0) {
                logMessage(`Ran out of ${titleCase(currentCookingTarget)} to cook. Stopping.`, "fore-yellow", "");
                stopAutoCooking();
                showCookFood(); 
                return;
            }

            const cookDetails = COOKABLE_ITEMS[currentCookingTarget];
            playerData.inventory[currentCookingTarget]--;
            const oldLevel = getLevelFromXp(playerData.cooking_xp);
            
            const currentCookLvlForThisItem = getLevelFromXp(playerData.cooking_xp); 
            let successChance = 0.60 + (currentCookLvlForThisItem - cookDetails.difficulty_level) * 0.02;
            successChance = Math.max(0.10, Math.min(0.98, successChance));

            if (Math.random() < successChance) {
                playerData.inventory[cookDetails.cooked_item] = (playerData.inventory[cookDetails.cooked_item] || 0) + 1;
                
                let xpGainedRaw = cookDetails.xp_gain;
                let xpGainedDisplay = xpGainedRaw; 
                if (playerData.built_structures.house) {
                    const houseXpPerk = STRUCTURE_DATA.house.perks.find(p => p.type === "global_xp_boost");
                    if(houseXpPerk) xpGainedDisplay *= (1 + houseXpPerk.value);
                }
                xpGainedDisplay = Math.floor(xpGainedDisplay);

                playerData.cooking_xp += xpGainedDisplay; 
                grantUniversalXP(xpGainedRaw);
                logMessage(`Cooked 1 ${titleCase(cookDetails.cooked_item)}! (+${xpGainedDisplay} Cook XP)`, "fore-green", "");
                if (currentCookLvlForThisItem >= cookDetails.difficulty_level + 15 && Math.random() < 0.10) {
                    playerData.inventory[cookDetails.cooked_item]++;
                    logMessage(`Bonus! Extra ${titleCase(cookDetails.cooked_item)}!`, "fore-yellow", "");
                }
            } else {
                playerData.inventory[cookDetails.burnt_item] = (playerData.inventory[cookDetails.burnt_item] || 0) + 1;
                logMessage(`Burnt the ${titleCase(currentCookingTarget)}.`, "fore-red", "");
            }
             
            playSound(skillRoundSound); 
            handleLevelUp("cooking_xp", oldLevel); 
            savePlayerData();
            updateHud();
            
            // Update UI for the cooked item count in its list
            if (currentCookingTarget) { 
                 const cookListDiv = document.getElementById('cookable-items-list');
                 const items = cookListDiv.getElementsByClassName('cookable-item-list');
                 for(let itemDiv of items) {
                     if (itemDiv.id === `cookable-list-item-${currentCookingTarget.replace(/\s+/g, '-')}`) {
                         const newQuantity = playerData.inventory[currentCookingTarget] || 0;
                         const canCook = getLevelFromXp(playerData.cooking_xp) >= cookDetails.level_req;
                         const reqColor = canCook ? 'fore-green' : 'fore-red';
                         itemDiv.innerHTML = `${cookDetails.emoji || ''} ${titleCase(currentCookingTarget)} (x${newQuantity}) 
                                         - <span class="${reqColor}">Req Lvl: ${cookDetails.level_req}</span>`;
                         if (newQuantity === 0 || !canCook) {
                            itemDiv.onclick = null; 
                            itemDiv.style.cursor = 'not-allowed';
                            itemDiv.style.opacity = "0.6";
                         } else { 
                            itemDiv.onclick = () => selectRawItemForCooking(currentCookingTarget);
                            itemDiv.style.cursor = 'pointer';
                            itemDiv.style.opacity = "1";
                         }
                         break;
                     }
                 }
            }
             if (playerData.inventory[currentCookingTarget] <= 0) {
                logMessage(`Ran out of ${titleCase(currentCookingTarget)} to cook. Auto-cooking stopped.`, "fore-yellow", "");
                stopAutoCooking();
            }
        }
        
        // --- NEW: Build Structures ---
        function showBuildStructuresMenu() {
            stopAllAutoActions();
            const listDiv = document.getElementById('available-structures-list');
            listDiv.innerHTML = ''; 

            let canBuildSomething = false;
            let allBuilt = true; 
            for (const structureId in STRUCTURE_DATA) {
                const structure = STRUCTURE_DATA[structureId];
                const cardDiv = document.createElement('div');
                cardDiv.className = 'structure-item-card';
                if (playerData.built_structures[structureId]) {
                    cardDiv.classList.add('built-structure-card');
                }

                const requirementsMet = !structure.requires_structure || playerData.built_structures[structure.requires_structure];
                const isAlreadyBuilt = playerData.built_structures[structureId];
                if (!isAlreadyBuilt) allBuilt = false;

                let resourcesMet = true; // Still needed for button logic if not built
                let costDisplayHtml = "";
                let prerequisiteDisplayHtml = "";

                if (!isAlreadyBuilt) {
                    costDisplayHtml = "<h4>Cost:</h4>";
                    for (const resourceName in structure.cost) {
                        const needed = structure.cost[resourceName];
                        const possessed = playerData.inventory[resourceName] || 0;
                        const color = possessed >= needed ? 'fore-green' : 'fore-red';
                        costDisplayHtml += `<p><span class="cost-item-name">${titleCase(resourceName)}:</span> ${needed.toLocaleString()} (<span class="${color}">${possessed.toLocaleString()}</span>)</p>`;
                        if (possessed < needed) {
                            resourcesMet = false;
                        }
                    }

                    if (structure.requires_structure) {
                        const reqStruct = STRUCTURE_DATA[structure.requires_structure];
                        const reqStatusText = playerData.built_structures[structure.requires_structure] ? "<span class='fore-green'>(Built)</span>" : "<span class='fore-red'>(Not Built)</span>";
                        prerequisiteDisplayHtml = `<h4>Prerequisite:</h4><p>${reqStruct.name} ${reqStatusText}</p>`;
                    }
                }

                // Set up the main card structure first, without the actions part
                cardDiv.innerHTML = `
                    <h3>
                        <span class="emoji">${structure.emoji}</span>
                        ${structure.name}
                        ${isAlreadyBuilt ? "<span class='built-status fore-green'>(Built)</span>" : ""}
                    </h3>
                    <p class="description">${structure.perk_desc}</p>
                    ${(!isAlreadyBuilt && (costDisplayHtml || prerequisiteDisplayHtml)) ? `
                    <div class="requirements-block">
                        ${costDisplayHtml}
                        ${prerequisiteDisplayHtml}
                    </div>` : ''}
                `;

                // Create a separate container for actions and append elements to it
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'actions';

                if (!isAlreadyBuilt && requirementsMet) {
                    const buildButton = document.createElement('button');
                    buildButton.textContent = `Build ${structure.name}`;
                    if (resourcesMet) {
                        buildButton.onclick = () => buildStructure(structureId);
                    } else {
                        buildButton.disabled = true;
                        buildButton.title = "Not enough resources.";
                    }
                    actionsDiv.appendChild(buildButton); // Append the button element
                    canBuildSomething = true;
                } else if (!isAlreadyBuilt && !requirementsMet) {
                    const lockedText = document.createElement('p');
                    lockedText.className = 'fore-red';
                    lockedText.textContent = `Locked. Build ${STRUCTURE_DATA[structure.requires_structure].name} first.`;
                    actionsDiv.appendChild(lockedText); // Append the paragraph element
                }

                cardDiv.appendChild(actionsDiv); // Append the actionsDiv to the card
                listDiv.appendChild(cardDiv);
            }
            if (!canBuildSomething && !allBuilt) {
                listDiv.innerHTML += "<p>No new structures available to build at this time (check resources and requirements).</p>";
            } else if (allBuilt) {
                listDiv.innerHTML += "<p class='fore-green'>Congratulations! You've built all available structures!</p>";
            }
            showSection('build-structures-section');
        }

        function buildStructure(structureId) {
            const structure = STRUCTURE_DATA[structureId];
            if (playerData.built_structures[structureId]) {
                logMessage(`${structure.name} is already built.`, "fore-yellow", "");
                return;
            }
            if (structure.requires_structure && !playerData.built_structures[structure.requires_structure]) {
                logMessage(`You must build ${STRUCTURE_DATA[structure.requires_structure].name} first.`, "fore-red", "");
                return;
            }
            for (const resourceName in structure.cost) {
                if ((playerData.inventory[resourceName] || 0) < structure.cost[resourceName]) {
                    logMessage(`Not enough ${titleCase(resourceName)} to build ${structure.name}.`, "fore-red", "");
                    return;
                }
            }
            for (const resourceName in structure.cost) {
                playerData.inventory[resourceName] -= structure.cost[resourceName];
            } 

            playerData.built_structures[structureId] = true;
            logMessage(`Successfully built ${structure.emoji} ${structure.name}! Perk activated.`, "fore-green", structure.emoji || "");
            // playSound(buildStructureSound); // Add a sound effect if you have one

            // Special handling for Cabin HP bonus
            if (structure.perk_effect && structure.perk_effect.type === "max_hp_bonus") {
                playerData.hp += structure.perk_effect.value; // Give the HP
                playerData.hp = Math.min(playerData.hp, getMaxHp(getLevelFromXp(playerData.attack_xp))); // Cap it
            }
            // Special handling for Stronghold HP bonus
            if (structureId === "stronghold" && structure.perks) {
                const hpPerk = structure.perks.find(p => p.type === "max_hp_bonus_flat");
                if (hpPerk) playerData.hp += hpPerk.value;
                playerData.hp = Math.min(playerData.hp, getMaxHp(getLevelFromXp(playerData.attack_xp)));
            }
            
            startRentCollection(); // Check if rent system needs to start/update

            savePlayerData();
            updateHud();
            showBuildStructuresMenu(); 
            if (currentSection === 'inventory-section') populateEquipmentDisplay(); // If Max HP changes, equipment display might too
        }

        // --- Rent Collection System ---
        function startRentCollection() {
            if (rentInterval) clearInterval(rentInterval); 
            
            // Start collecting rent if the Shed is built (as Camp becomes rentable then)
            // Or if any structure that *causes* rent is built.
            // A simpler check: if any structure is built that itself offers rent for a previous one.
            let shouldCollectRent = false;
            for (const structId in STRUCTURE_DATA) {
                if (playerData.built_structures[structId] && STRUCTURE_DATA[structId].rent_value > 0 && STRUCTURE_DATA[structId].requires_structure && playerData.built_structures[STRUCTURE_DATA[structId].requires_structure]) {
                    shouldCollectRent = true;
                    break;
                }
                 // Special case for shed: if shed is built, camp is rentable
                if (structId === "shed" && playerData.built_structures.shed && playerData.built_structures.camp) {
                    shouldCollectRent = true;
                    break;
                }
            }


            if (shouldCollectRent) {
                 logMessage("Rent collection system active.", "fore-blue", "");
                rentInterval = setInterval(collectRent, RENT_COLLECTION_INTERVAL);
                // Optional: collect rent immediately if enough time has passed since last load
                const timeSinceLastCollection = Date.now() - (playerData.last_rent_collection_time || 0);
                if (playerData.last_rent_collection_time > 0 && timeSinceLastCollection >= RENT_COLLECTION_INTERVAL) {
                    collectRent(); 
                } else if (playerData.last_rent_collection_time === 0) { // First time after building shed
                    playerData.last_rent_collection_time = Date.now(); // Set baseline
                }
            }
        }

        function collectRent() {
            if (!playerData || !playerData.built_structures) return; 

            let totalRentCollected = 0;
            let rentMessages = [];

            // Rent logic: The PREVIOUS structure provides rent once the CURRENT one is built
            // The rent_value in STRUCTURE_DATA[current_structure] is for STRUCTURE_DATA[previous_structure]
            if (playerData.built_structures.shed && playerData.built_structures.camp) { 
                totalRentCollected += STRUCTURE_DATA.shed.rent_value; 
                if (STRUCTURE_DATA.shed.rent_value > 0) rentMessages.push(`${STRUCTURE_DATA.camp.name}: ${STRUCTURE_DATA.shed.rent_value}g`);
            }
            if (playerData.built_structures.cabin && playerData.built_structures.shed) { 
                totalRentCollected += STRUCTURE_DATA.cabin.rent_value;
                if (STRUCTURE_DATA.cabin.rent_value > 0) rentMessages.push(`${STRUCTURE_DATA.shed.name}: ${STRUCTURE_DATA.cabin.rent_value}g`);
            }
            if (playerData.built_structures.house && playerData.built_structures.cabin) { 
                totalRentCollected += STRUCTURE_DATA.house.rent_value;
                if (STRUCTURE_DATA.house.rent_value > 0) rentMessages.push(`${STRUCTURE_DATA.cabin.name}: ${STRUCTURE_DATA.house.rent_value}g`);
            }
            if (playerData.built_structures.mansion && playerData.built_structures.house) { 
                totalRentCollected += STRUCTURE_DATA.mansion.rent_value;
                if (STRUCTURE_DATA.mansion.rent_value > 0) rentMessages.push(`${STRUCTURE_DATA.house.name}: ${STRUCTURE_DATA.mansion.rent_value}g`);
            }
            if (playerData.built_structures.castle && playerData.built_structures.mansion) { 
                totalRentCollected += STRUCTURE_DATA.castle.rent_value;
                if (STRUCTURE_DATA.castle.rent_value > 0) rentMessages.push(`${STRUCTURE_DATA.mansion.name}: ${STRUCTURE_DATA.castle.rent_value}g`);
            }
            if (playerData.built_structures.stronghold && playerData.built_structures.castle) { 
                totalRentCollected += STRUCTURE_DATA.stronghold.rent_value;
                if (STRUCTURE_DATA.stronghold.rent_value > 0) rentMessages.push(`${STRUCTURE_DATA.castle.name}: ${STRUCTURE_DATA.stronghold.rent_value}g`);
            }
            // Rent for House via Lumber Mill
            if (playerData.built_structures.lumberMill && playerData.built_structures.house) {
                totalRentCollected += STRUCTURE_DATA.lumberMill.rent_value;
                if (STRUCTURE_DATA.lumberMill.rent_value > 0) {
                    rentMessages.push(`${STRUCTURE_DATA.house.name} (via Lumber Mill): ${STRUCTURE_DATA.lumberMill.rent_value}g`);
                }
            }

            if (totalRentCollected > 0) {
                playerData.gold += totalRentCollected;
                logMessage(`Collected ${totalRentCollected} gold from rent! (${rentMessages.join(', ')})`, "fore-yellow", "");
                updateHud();
                savePlayerData(); 
            }
            playerData.last_rent_collection_time = Date.now();
        }


        // --- Perk Tree ---
        function showPerkTreeMenu() {
            stopAllAutoActions();
            const perkListDiv = document.getElementById('perk-list');
            perkListDiv.innerHTML = "";
            const availablePoints = (playerData.perk_points_earned || 0) - (playerData.perk_points_spent || 0);
            document.getElementById('available-perk-points').textContent = availablePoints;

            for (const perkId in PERK_DATA) {
                const perk = PERK_DATA[perkId];
                const cardDiv = document.createElement('div');
                cardDiv.className = 'perk-item-card';

                // Create header and description elements
                const perkHeaderDiv = document.createElement('div');
                perkHeaderDiv.className = 'perk-header';
                perkHeaderDiv.innerHTML = `
                    <span class="perk-name">${perk.name}</span>
                    <span class="perk-cost-display">Cost: ${perk.cost} PP</span>
                `;

                const perkDescriptionP = document.createElement('p');
                perkDescriptionP.className = 'perk-description';
                perkDescriptionP.textContent = perk.description;

                const perkStatusActionDiv = document.createElement('div');
                perkStatusActionDiv.className = 'perk-status-action';

                const isUnlocked = playerData.active_perks[perkId];
                const canAfford = availablePoints >= perk.cost;
                const reqsMet = perk.requires.every(reqId => playerData.active_perks[reqId]);

                if (isUnlocked) {
                    cardDiv.classList.add('activated-perk-card');
                    const statusTextP = document.createElement('p');
                    statusTextP.className = 'status-text fore-green';
                    statusTextP.textContent = 'Activated';
                    perkStatusActionDiv.appendChild(statusTextP);
                } else if (!reqsMet) {
                    cardDiv.classList.add('disabled-perk-card');
                    const reqNames = perk.requires.map(r => PERK_DATA[r] ? PERK_DATA[r].name : r).join(', ');
                    const statusTextP = document.createElement('p');
                    statusTextP.className = 'status-text fore-red';
                    statusTextP.textContent = `Locked. Requires: ${reqNames}`;
                    perkStatusActionDiv.appendChild(statusTextP);
                } else if (!canAfford) {
                    cardDiv.classList.add('disabled-perk-card');
                    const statusTextP = document.createElement('p');
                    statusTextP.className = 'status-text fore-yellow';
                    statusTextP.textContent = 'Locked. Not enough Perk Points.';
                    perkStatusActionDiv.appendChild(statusTextP);
                } else {
                    const activateButton = document.createElement('button');
                    activateButton.textContent = `Activate (${perk.cost} PP)`;
                    activateButton.onclick = () => activatePerk(perkId);
                    perkStatusActionDiv.appendChild(activateButton); // Append the button element directly
                }

                cardDiv.appendChild(perkHeaderDiv);
                cardDiv.appendChild(perkDescriptionP);
                cardDiv.appendChild(perkStatusActionDiv);
                perkListDiv.appendChild(cardDiv);
            }
            showSection('perk-tree-section');
        }

        function activatePerk(perkId) {
            stopAllAutoActions(); // Good practice to stop actions if a perk might affect them
            const perk = PERK_DATA[perkId];
            const availablePoints = (playerData.perk_points_earned || 0) - (playerData.perk_points_spent || 0);

            if (playerData.active_perks[perkId] && perk.type !== "master_guild_charter") { // Charter can be "activated" multiple times if conditions met
                logMessage("Perk already activated.", "fore-yellow", "");
                return;
            }
            if (availablePoints < perk.cost) {
                logMessage("Not enough perk points.", "fore-red", "");
                return;
            }
            if (!perk.requires.every(reqId => playerData.active_perks[reqId])) {
                const missingReqs = perk.requires.filter(reqId => !playerData.active_perks[reqId]).map(reqId => PERK_DATA[reqId].name).join(', ');
                logMessage(`Prerequisites not met. Requires: ${missingReqs}.`, "fore-red", "");
                return;
            }

            if (perk.type === "master_guild_charter") {
                if (activateMasterGuildCharter()) { // This function now returns true on success
                    playerData.active_perks[perkId] = true; // Mark the charter perk as "learned"
                    playerData.perk_points_spent += perk.cost;
                    // activateMasterGuildCharter handles its own logging, saving, and UI updates (like reload or showMainMenu)
                    playSound(levelUpSound); // Sound for "learning" the charter
                }
                // If activateMasterGuildCharter returns false, it means conditions weren't met or user cancelled.
                // Perk point is not spent, perk not marked active. Log messages handled within.
            } else {
                // Regular perk activation
                playerData.active_perks[perkId] = true;
                playerData.perk_points_spent += perk.cost;
                logMessage(`Activated Perk: ${perk.name}! (${perk.cost} PP spent)`, "fore-magenta", "");
                playSound(levelUpSound);
                savePlayerData();
                updateHud();
                populateEquipmentDisplay(); // Some perks might affect equipment display
            }
            
            showPerkTreeMenu(); // Refresh the perk tree menu in all cases (unless page reloaded by charter)
        }

        function checkCanStillSmith(itemName) {
            if (!itemName || !SWORD_DATA[itemName]) return false;
            const itemData = SWORD_DATA[itemName];
            for (const bar in itemData.recipe) {
                const requiredAmount = isPerkActive("masterSmith") && itemData.recipe[bar] > 1 ?
                                      Math.max(1, itemData.recipe[bar] - PERK_DATA.masterSmith.value) :
                                      itemData.recipe[bar];
                if ((playerData.inventory[bar] || 0) < requiredAmount) {
                    return false;
                }
            }
            return true;
        }

        function updateSmithableItemDisplay(itemName) {
            const itemDiv = document.getElementById(`smithable-item-div-${itemName.replace(/\s+/g, '-')}`);
            if (!itemDiv || !SWORD_DATA[itemName]) return;

            const itemData = SWORD_DATA[itemName];
            let recipeString = "";
            for (const bar in itemData.recipe) {
                const requiredAmount = isPerkActive("masterSmith") && itemData.recipe[bar] > 1 ?
                                      Math.max(1, itemData.recipe[bar] - PERK_DATA.masterSmith.value) :
                                      itemData.recipe[bar];
                recipeString += `${requiredAmount} ${titleCase(bar)} (${playerData.inventory[bar] || 0}), `;
            }
            recipeString = recipeString.slice(0, -2);
            const bsLvl = getLevelFromXp(playerData.blacksmithing_xp);
            const levelReqColor = bsLvl >= itemData.smith_level_req ? 'fore-green' : 'fore-red';
            const newMaxCraftableDisplay = calculateMaxCraftableForSword(itemName);
            
            // Update the "Requires" part within the left details span
            const detailsSpan = itemDiv.querySelector('.item-details-left');
            if (detailsSpan) {
                const smallReqSpan = detailsSpan.querySelector('small'); // Assuming the "Requires" is the first/primary small tag
                if (smallReqSpan) {
                    // Find existing lifesteal info to preserve it
                    let lifestealInfoHTML = "";
                    const lifestealSpans = detailsSpan.querySelectorAll('small.fore-magenta'); // More specific selector if needed
                    lifestealSpans.forEach(lsSpan => {
                        if (lsSpan.textContent.includes("Lifesteal")) {
                            lifestealInfoHTML = `<br>${lsSpan.outerHTML}`; // Keep the <br> if it was there
                        }
                    });
                    smallReqSpan.innerHTML = `Requires: ${recipeString} - <span class="${levelReqColor}">Lvl: ${itemData.smith_level_req} BS</span> - Max: <span id="max-craftable-smith-${itemName.replace(/\s+/g, '-')}">${newMaxCraftableDisplay}</span>`;
                    // Re-append lifesteal info if it existed
                    if (lifestealInfoHTML) {
                        detailsSpan.innerHTML = detailsSpan.innerHTML.replace(/<\/small>(<br><small class="fore-magenta">Lifesteal:.*?<\/small>)?/, `</small>${lifestealInfoHTML}`);
                    }
                }
            }
            // Update the "In Stock" count
            const stockCountSpan = itemDiv.querySelector(`#inv-count-smith-${itemName.replace(/\s+/g, '-')}`);
            if (stockCountSpan) {
                stockCountSpan.textContent = playerData.inventory[itemName] || 0;
            }
        }

        function updateSmithableItemDisplay(itemName) {
            const itemDiv = document.getElementById(`smithable-item-div-${itemName.replace(/\s+/g, '-')}`);
            if (!itemDiv || !SWORD_DATA[itemName]) return;

            // For simplicity and to ensure all parts (recipe, max craftable, stock) are updated correctly,
            // we can just call showSmithingMenu() which rebuilds the whole list.
            // This is less efficient if the list is very long, but safer for now.
            // If performance becomes an issue, a more targeted update like in singleSmeltAction can be implemented.
            showSmithingMenu();
        }

        // --- Level Up ---
        function handleLevelUp(skillXpField, oldLevel) {
            const newLevel = getLevelFromXp(playerData[skillXpField]);
            if (newLevel > oldLevel) {
                const skillName = titleCase(skillXpField.replace('_xp', ''));
                logMessage(`Congrats! ${skillName} Level ${newLevel}!`, "fore-yellow", "");
                playSound(levelUpSound); 
                if (skillName === "Attack") {
                    const oldMaxHpVal = getMaxHp(oldLevel); // Max HP before level up
                    const newMaxHpVal = getMaxHp(newLevel); // Max HP after level up (considers Cabin)
                    playerData.hp += (newMaxHpVal - oldMaxHpVal); // Add the difference 
                    playerData.hp = Math.min(playerData.hp, newMaxHpVal); // Cap at new max
                    logMessage("HP increased and restored!", "fore-green");
                }
                updateHud(); 
                
                // Refresh current screen if it displays level-gated content
                if (currentSection === 'woodcutting-section') showWoodcutting();
                else if (currentSection === 'mining-section') showMining();
                else if (currentSection === 'cook-food-section') showCookFood();
                else if (currentSection === 'smelting-section') showSmeltingMenu();
                else if (currentSection === 'smithing-section') showSmithingMenu();
                else if (currentSection === 'combat-section') showCombat();
                else if (currentSection === 'build-structures-section') showBuildStructuresMenu(); 
                
                return true;
            }
            return false;
        }

        // --- NEW GAME PLUS (GUILD SYSTEM) ---

        function checkAllSkillsLevel75() {
            const skills = ["woodcutting_xp", "mining_xp", "attack_xp", "cooking_xp", "blacksmithing_xp"];
            for (const skill_xp_field of skills) {
                if (getLevelFromXp(playerData[skill_xp_field]) < 75) {
                    return false;
                }
            }
            return true;
        }

        function activateMasterGuildCharter() {
            // 1. Check requirements
            if (playerData.gold < 1000000 || !checkAllSkillsLevel75()) {
                let missingReqs = [];
                if (playerData.gold < 1000000) missingReqs.push("1,000,000 Gold");
                if (!checkAllSkillsLevel75()) missingReqs.push("Level 75 in all core skills");
                logMessage(`Requirements not met for Master Guild Charter. Missing: ${missingReqs.join(', ')}.`, "fore-red", "");
                return false; // Indicate failure
            }

            // 2. Confirmation Dialog
            if (!confirm("Activating the Master Guild Charter will reset your current progress (skills, inventory, gold, structures) but you will keep all earned Perk Points and become a Guild Leader. This is a New Game+! Are you sure you wish to proceed? This cannot be undone.")) {
                logMessage("Master Guild Charter activation cancelled.", "fore-yellow", "");
                return false; // Indicate cancellation
            }

            // 3. Deduct Gold Cost
            playerData.gold -= 1000000;

            // 4. Preserve Perk Points
            const totalPerkPointsEarned = playerData.perk_points_earned || 0;

            // 5. Full Player Data Reset (based on existing DEFAULT_PLAYER structure)
            let freshPlayerData = JSON.parse(JSON.stringify(DEFAULT_PLAYER));

            playerData.woodcutting_xp = freshPlayerData.woodcutting_xp;
            playerData.mining_xp = freshPlayerData.mining_xp;
            playerData.attack_xp = freshPlayerData.attack_xp;
            playerData.cooking_xp = freshPlayerData.cooking_xp;
            playerData.blacksmithing_xp = freshPlayerData.blacksmithing_xp;
            playerData.total_skill_xp = 0; // Reset total skill XP as individual skills are reset

            playerData.inventory = freshPlayerData.inventory; // Resets items and sets slots to "none"
            playerData.gold = freshPlayerData.gold; // Starting gold
            playerData.built_structures = freshPlayerData.built_structures;
            playerData.last_rent_collection_time = 0; // Reset rent timer
            // Permits are also reset as they are part of the progression
            playerData.permits = JSON.parse(JSON.stringify(DEFAULT_PLAYER.permits));


            // 6. Restore/Set NG+ Specific Data
            playerData.perk_points_earned = totalPerkPointsEarned; // Restore the earned points
            playerData.perk_points_spent = 0; // Reset spent points

            playerData.guild_unlocked = true;
            playerData.guild_level = 1;
            playerData.guild_xp = 0;
            playerData.guild_name = (playerData.name || "PlayerOne") + "'s Guild"; // Use current player name if set
            playerData.guild_members = []; // Start with no members
            playerData.guild_stash = JSON.parse(JSON.stringify(DEFAULT_PLAYER.inventory)); // Empty stash, like player inventory
            playerData.guild_member_capacity = 1; // Initial capacity
            playerData.guild_hall_upgrades = { barracks_level: 0, forge_level: 0, mission_board_level: 0 };

            // 7. Recalculate HP for level 1
            playerData.hp = getMaxHp(1); // getLevelFromXp(0) is 1

            // 8. Finalize
            logMessage("Master Guild Charter activated! You are now a Guild Leader. Your journey begins anew, with wisdom and perk points as your guide!", "fore-magenta", "");
            
            stopAllAutoActions(); // Stop any ongoing actions
            if(rentInterval) clearInterval(rentInterval); // Stop old rent timer
            
            savePlayerData();
            updateHud(); // Will reflect reset stats and 0 spent perk points
            showMainMenu();
            // Potentially call initGame() or parts of it if deeper re-initialization is needed,
            // but for now, save/updateHud/showMainMenu should cover most UI.
            // Re-initialize perk points display as they are now available again
            if (currentSection === 'perk-tree-section') showPerkTreeMenu();
            return true; // Indicate success
        }

        // --- Guild Management Function Stubs ---

        function assignMissionToMember(memberId, missionDetails) {
            if (!playerData.guild_unlocked) { logMessage("Guild not yet unlocked.", "fore-red"); return; }
            logMessage(`Assigning mission to member ${memberId} (Not fully implemented).`, "fore-cyan");
        }

        function processReturnedMission(memberId) {
            if (!playerData.guild_unlocked) { logMessage("Guild not yet unlocked.", "fore-red"); return; }
            logMessage(`Processing returned mission for member ${memberId} (Not fully implemented).`, "fore-cyan");
        }

        function upgradeGuildMemberSkill(memberId, skillName, cost) {
            if (!playerData.guild_unlocked) { logMessage("Guild not yet unlocked.", "fore-red"); return; }
            logMessage(`Upgrading ${skillName} for member ${memberId} (Not fully implemented).`, "fore-cyan");
        }

        function manageGuildUpkeep() {
            if (!playerData.guild_unlocked) { return; } // No log if guild not unlocked, as this might be called by a timer
            // logMessage("Managing guild upkeep (Not fully implemented).", "fore-cyan");
        }

        function upgradeGuildHall(upgrade_type) {
            if (!playerData.guild_unlocked) { logMessage("Guild not yet unlocked.", "fore-red"); return; }
            logMessage(`Upgrading Guild Hall: ${upgrade_type} (Not fully implemented).`, "fore-cyan");
        }

        function grantGuildXP(amount) {
            if (!playerData.guild_unlocked) { return; }
            playerData.guild_xp += amount;
            logMessage(`Guild gained ${amount} XP. Total: ${playerData.guild_xp}. (Level up not implemented).`, "fore-magenta");
            // Check for guild level up here
        }

        function showGuildMenu() {
            if (!playerData.guild_unlocked) {
                logMessage("Access denied. Guild not yet unlocked.", "fore-red", "");
                showMainMenu(); // Redirect to main menu if somehow accessed
                return;
            }
            stopAllAutoActions();
            document.getElementById('guild-master-name').textContent = playerData.name || "Adventurer";
            document.getElementById('guild-name-display').textContent = playerData.guild_name || "Player's Guild";
            document.getElementById('guild-level-display').textContent = playerData.guild_level || 1;
            document.getElementById('guild-xp-display').textContent = (playerData.guild_xp || 0).toLocaleString();
            document.getElementById('guild-member-count').textContent = (playerData.guild_members || []).length;
            document.getElementById('guild-member-capacity-display').textContent = playerData.guild_member_capacity || 1;
            showSection('guild-menu-section');
        }

        function showGuildMembersScreen() {
            if (!playerData.guild_unlocked) {
                logMessage("Access denied. Guild not yet unlocked.", "fore-red", "");
                showGuildMenu();
                return;
            }
            stopAllAutoActions();

            document.getElementById('current-member-display-count').textContent = playerData.guild_members.length;
            document.getElementById('current-member-display-capacity').textContent = playerData.guild_member_capacity;

            const memberListDiv = document.getElementById('guild-member-list');
            memberListDiv.innerHTML = '<h4>Current Roster:</h4>';
            if (playerData.guild_members.length === 0) {
                memberListDiv.innerHTML += '<p><i>No members recruited yet.</i></p>';
            } else {
                playerData.guild_members.forEach(member => renderMemberCard(memberListDiv, member));
            }

            const recruitArea = document.getElementById('recruit-member-area');
            recruitArea.innerHTML = '';
            // Ensure all member task intervals are cleared if they were somehow orphaned
            // This is a safety net; proper clearing should happen on task completion/cancellation
            playerData.guild_members.forEach(member => {
                if (member.current_task && member.current_task.intervalId) {
                    const now = Date.now();
                    if (now > member.current_task.startTime + member.current_task.durationMs + 5000) { // 5s grace
                        console.warn(`Orphaned task found for ${member.name}, attempting to clear.`);
                        clearInterval(member.current_task.intervalId);
                        // Optionally, complete the task here if it should have finished
                        // completeMemberTask(member.id); // Be careful with calling this directly without UI context
                    }
                }
            });

            // Start any active task progress bars
            playerData.guild_members.forEach(member => {
                if (member.current_task && !member.current_task.intervalId) {
                    // Task was active but interval was lost (e.g. page reload)
                    // Re-evaluate if task is complete or restart interval
                    const elapsedMs = Date.now() - member.current_task.startTime;
                    if (elapsedMs >= member.current_task.durationMs) {
                        completeMemberTask(member.id);
                    } else {
                        member.current_task.intervalId = setInterval(() => processMemberTaskTick(member.id), GUILD_MEMBER_TASK_TICK_INTERVAL_MS);
                        // Update UI for this member
                        const cardElement = document.getElementById(`member-card-${member.id}`);
                        if (cardElement) {
                            const actionPanel = cardElement.querySelector(`#member-action-panel-${member.id}`);
                            const progressContainer = cardElement.querySelector(`#member-progress-container-${member.id}`);
                            const taskControls = cardElement.querySelector(`#member-task-controls-${member.id}`);
                            const statusSpan = cardElement.querySelector(`#member-status-${member.id}`);

                            actionPanel.classList.add('hidden');
                            progressContainer.classList.remove('hidden');
                            taskControls.classList.remove('hidden');
                            statusSpan.textContent = `Task: ${titleCase(member.current_task.type)}`;
                            updateMemberProgressDisplay(member); // Initial update
                        }
                    }
                }
            });

            if (playerData.guild_members.length < playerData.guild_member_capacity && playerData.guild_members.length < MAX_GUILD_MEMBERS) {
                const nextRecruitDetails = getNextRecruitDetails();
                const recruitButton = document.createElement('button');
                recruitButton.innerHTML = `Recruit ${nextRecruitDetails.name} (Cost: ${nextRecruitDetails.cost.toLocaleString()} Gold)`;
                console.log("Setting onclick for recruit button to recruitNewGuildMember"); // DEBUG
                recruitButton.onclick = () => recruitNewGuildMember();
                
                const detailsP = document.createElement('p');
                detailsP.innerHTML = `<small>Next recruit will start at Level ${nextRecruitDetails.startLevel} (Max ${nextRecruitDetails.maxLevel}).</small>`;
                console.log("Recruit button and details created for:", nextRecruitDetails.name); // DEBUG
                
                recruitArea.appendChild(recruitButton); // Button first
                recruitArea.appendChild(detailsP);      // Then details paragraph
            } else if (playerData.guild_members.length >= MAX_GUILD_MEMBERS) {
                recruitArea.innerHTML = '<p><i>Your guild roster is full (Max 10 members).</i></p>';
            } else {
                recruitArea.innerHTML = '<p><i>Increase Guild Member Capacity (e.g., upgrade Barracks) to recruit more members.</i></p>';
            }

            showSection('guild-members-section');
        }

        function getNextRecruitDetails() {
            const currentMemberCount = playerData.guild_members.length;
            const recruitIndex = currentMemberCount; // 0-indexed for GUILD_MEMBER_NAMES

            let cost = 1000;
            if (recruitIndex > 0) { // For 2nd member onwards
                cost = 1000 * Math.pow(10, recruitIndex);
            }

            const startLevel = (recruitIndex === 0) ? 1 : recruitIndex * 10;
            const maxLevel = recruitIndex * 10 + 20;
            const name = GUILD_MEMBER_NAMES[recruitIndex] || `Guild Member ${recruitIndex + 1}`;

            return { name, cost, startLevel, maxLevel, recruitOrder: recruitIndex + 1 };
        }

        function recruitNewGuildMember() {
            if (playerData.guild_members.length >= playerData.guild_member_capacity) {
                logMessage("Cannot recruit: Guild member capacity reached.", "fore-red", "");
                return;
            }
            if (playerData.guild_members.length >= MAX_GUILD_MEMBERS) {
                logMessage("Cannot recruit: Maximum of 10 guild members reached.", "fore-red", "");
                return;
            }

            const details = getNextRecruitDetails();

            if (playerData.gold < details.cost) {
                logMessage(`Not enough gold to recruit ${details.name}. Need ${details.cost.toLocaleString()} Gold.`, "fore-red", "");
                return;
            }

            playerData.gold -= details.cost;
            const newMember = {
                id: `member_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`,
                name: details.name,
                recruitOrder: details.recruitOrder,
                level: details.startLevel,
                xp: GUILD_MEMBER_LEVEL_PROGRESSION[details.startLevel -1] || 0, // XP for their starting level
                startLevel: details.startLevel,
                maxLevel: details.maxLevel,
                // Add other fields like assigned_mission: null, equipment: {} later
                current_task: null, // Initialize current_task
                accumulated_loot: {} // Already initialized in original code, ensure it's here
            };
            playerData.guild_members.push(newMember);

            logMessage(`Successfully recruited ${newMember.name} (Lvl ${newMember.level}) for ${details.cost.toLocaleString()} Gold!`, "fore-magenta", "");
            savePlayerData();
            updateHud();
            showGuildMembersScreen(); // Refresh the member screen
        }

        function renderMemberCard(container, member) {
            const cardId = `member-card-${member.id}`;
            let cardElement = document.getElementById(cardId);
            if (!cardElement) {
                cardElement = document.createElement('div');
                cardElement.className = 'guild-member-card item'; // Using 'item' for some base styling
                cardElement.id = cardId;
                container.appendChild(cardElement);
            }
            cardElement.innerHTML = ''; // Clear previous content before re-rendering

            const memberInfoDiv = document.createElement('div');
            memberInfoDiv.className = 'member-info';

            let statusText;
            if (member.current_task) {
                cardElement.classList.add('on-task');
                const fillDiv = document.createElement('div');
                fillDiv.className = 'member-task-progress-bar-fill'; // Fill for the card itself
                fillDiv.id = `member-progress-fill-${member.id}`;
                cardElement.appendChild(fillDiv); // Fill is appended first, behind info

                const elapsedMs = Date.now() - member.current_task.startTime;
                const timeLeftSec = Math.max(0, Math.ceil((member.current_task.durationMs - elapsedMs) / 1000));
                const formattedTimeLeft = formatDurationHHMMSS(timeLeftSec);
                statusText = `Task: ${titleCase(member.current_task.type)} - ${formattedTimeLeft}`;
            } else {
                cardElement.classList.remove('on-task');
                statusText = 'Idle';
                memberInfoDiv.onclick = () => toggleMemberActions(member.id); // Only clickable if idle
            }

            memberInfoDiv.innerHTML = `
                <div class="member-details">
                    <strong>${member.name}</strong> (Lvl: ${member.level})
                    <br><small>XP: ${member.xp}/${GUILD_MEMBER_LEVEL_PROGRESSION[member.level] || 'Max'}, Max Lvl: ${member.maxLevel}</small>
                </div>
                <span id="member-status-${member.id}" class="member-status">${statusText}</span>
            `;
            cardElement.appendChild(memberInfoDiv);

            if (member.current_task) {
                const taskControlsDiv = document.createElement('div');
                taskControlsDiv.className = 'member-task-controls'; // No longer hidden by default
                taskControlsDiv.id = `member-task-controls-${member.id}`;
                taskControlsDiv.innerHTML = `
                    <button class="member-action-button red" onclick="returnMemberFromTaskEarly('${member.id}')">Return Early & Collect</button>
                `;
                cardElement.appendChild(taskControlsDiv);
                updateMemberProgressDisplay(member);
            } else {
                const actionPanelDiv = document.createElement('div');
                actionPanelDiv.className = 'member-action-panel hidden'; // Start hidden
                actionPanelDiv.id = `member-action-panel-${member.id}`;
                actionPanelDiv.innerHTML = `
                    <button class="member-action-button" onclick="assignMemberTask('${member.id}', 'wood')">Gather Wood</button>
                    <button class="member-action-button" onclick="assignMemberTask('${member.id}', 'mining')">Go Mining</button>
                    <button class="member-action-button" onclick="assignMemberTask('${member.id}', 'hunting')">Go Hunting</button>
                `;
                cardElement.appendChild(actionPanelDiv);
            }
        }

        function toggleMemberActions(memberId) {
            const member = playerData.guild_members.find(m => m.id === memberId);
            if (!member || member.current_task) return; // Don't toggle if on task or member not found

            const actionPanel = document.getElementById(`member-action-panel-${memberId}`);
            if (actionPanel) {
                actionPanel.classList.toggle('hidden');
            }
        }

        function assignMemberTask(memberId, taskType) {
            const member = playerData.guild_members.find(m => m.id === memberId);
            if (!member) { logMessage("Error: Member not found.", "fore-red"); return; }
            if (member.current_task) { logMessage(`${member.name} is already on a task.`, "fore-yellow"); return; }

            member.current_task = {
                type: taskType,
                startTime: Date.now(),
                durationMs: GUILD_MEMBER_TASK_DURATION_MS, // Corrected constant name
                loot: {},
                intervalId: setInterval(() => processMemberTaskTick(memberId), GUILD_MEMBER_TASK_TICK_INTERVAL_MS)
            };

            logMessage(`${member.name} started ${titleCase(taskType)} task.`, "fore-cyan");
            const cardElement = document.getElementById(`member-card-${member.id}`);
            if (cardElement) {
                renderMemberCard(cardElement.parentNode, member); // Re-render the card
            }
            savePlayerData();
        }

        function processMemberTaskTick(memberId) {
            const member = playerData.guild_members.find(m => m.id === memberId);
            if (!member || !member.current_task) {
                // Task might have been cleared by another process, try to stop interval if it exists
                const orphanedTask = playerData.guild_members.find(m => m.id === memberId && m.current_task && m.current_task.intervalId);
                if (orphanedTask) clearInterval(orphanedTask.current_task.intervalId);
                return;
            }

            const task = member.current_task;
            const elapsedMs = Date.now() - task.startTime;

            // Loot roll
            const lootTableCategory = GUILD_MEMBER_LOOT_TABLES[task.type];
            if (lootTableCategory) {
                // Simplified loot: 30% chance to get any item from a valid category per tick
                if (Math.random() < 0.3) {
                    const possibleCategories = lootTableCategory.categories.filter(cat => member.level >= cat.minMemberLevel);
                    if (possibleCategories.length > 0) {
                        const chosenCategory = possibleCategories[Math.floor(Math.random() * possibleCategories.length)];
                        const chosenItemEntry = chosenCategory.items[Math.floor(Math.random() * chosenCategory.items.length)];
                        
                        if (!chosenItemEntry.minLevelReqForDrop || member.level >= chosenItemEntry.minLevelReqForDrop) {
                            const qty = Math.floor(Math.random() * (chosenItemEntry.maxQty - chosenItemEntry.minQty + 1)) + chosenItemEntry.minQty;
                            task.loot[chosenItemEntry.item] = (task.loot[chosenItemEntry.item] || 0) + qty;
                            // console.log(`${member.name} found ${qty} ${chosenItemEntry.item}`); // Optional debug
                        }
                    }
                }
            }

            if (elapsedMs >= task.durationMs) {
                completeMemberTask(memberId);
            } else {
                updateMemberProgressDisplay(member);
            }
        }
        
        function updateMemberProgressDisplay(member) {
            if (!member.current_task) return;
            const task = member.current_task;
            const elapsedMs = Date.now() - task.startTime;
            // Calculate remaining progress for a depleting bar
            const progressPercent = Math.max(0, ((task.durationMs - elapsedMs) / task.durationMs) * 100);

            const fillDiv = document.getElementById(`member-progress-fill-${member.id}`);
            const statusSpan = document.getElementById(`member-status-${member.id}`); // Target the status span in member-info

            if (fillDiv) {
                fillDiv.style.width = `${progressPercent}%`;
                // No .full class needed for this fill, card handles overall shape
            }
            if (statusSpan) { // Update the status text with time remaining
                const timeLeftSec = Math.max(0, Math.ceil((task.durationMs - elapsedMs) / 1000));
                const formattedTimeLeft = formatDurationHHMMSS(timeLeftSec);
                statusSpan.textContent = `Task: ${titleCase(task.type)} - ${formattedTimeLeft}`;
            }
        }

        function completeMemberTask(memberId, isEarlyReturn = false) {
            const member = playerData.guild_members.find(m => m.id === memberId);
            if (!member || !member.current_task) return;

            const task = member.current_task;
            clearInterval(task.intervalId);

            let lootSummary = [];
            for (const item in task.loot) {
                if (task.loot[item] > 0) {
                    playerData.guild_stash[item] = (playerData.guild_stash[item] || 0) + task.loot[item];
                    lootSummary.push(`${task.loot[item]} ${titleCase(item)}`);
                }
            }

            const messageAction = isEarlyReturn ? "returned early from" : "completed";
            if (lootSummary.length > 0) {
                logMessage(`${member.name} ${messageAction} ${titleCase(task.type)} task. Collected: ${lootSummary.join(', ')}. (Sent to Guild Stash)`, "fore-magenta", "");
            } else {
                logMessage(`${member.name} ${messageAction} ${titleCase(task.type)} task, but found nothing.`, "fore-yellow");
            }

            // Grant member XP
            const baseXpPerFullTask = 1000; // Adjusted Base XP for a full 8-hour task
            const bonusXpPerMemberLevel = 10; // Adjusted Additional XP per member level
            let xpGained = baseXpPerFullTask + (member.level * bonusXpPerMemberLevel);
            if (isEarlyReturn) {
                xpGained = Math.floor(xpGained * 0.3); // Penalize early return significantly (e.g., 30% of full XP)
            }
            const oldMemberLevel = member.level;
            member.xp += xpGained;
            
            // Check member level up
            while (member.level < member.maxLevel && member.xp >= GUILD_MEMBER_LEVEL_PROGRESSION[member.level]) {
                member.level++;
            }
            if (member.level > oldMemberLevel) {
                logMessage(`${member.name} leveled up to Level ${member.level}!`, "fore-yellow", "");
            }

            grantGuildXP(Math.floor(xpGained / 2)); // Grant some XP to the guild

            member.current_task = null;
            const cardElement = document.getElementById(`member-card-${member.id}`);
            if (cardElement) {
                renderMemberCard(cardElement.parentNode, member); // Re-render the card
            }
            savePlayerData();
            updateHud();
            // showGuildMembersScreen(); // Removed: This was causing player tasks to stop. renderMemberCard handles UI update.
        }

        function trainGuildMember(memberId) { // Stub
            logMessage(`Training for member ${memberId} - Not yet implemented.`, "fore-blue");
        }

        function returnMemberFromTaskEarly(memberId) {
            completeMemberTask(memberId, true);
        }

        function showGuildUpgradesScreen() {
            logMessage("Guild Hall Upgrades screen - Not yet implemented.", "fore-blue");
        }
        function showGuildMissionsScreen() {
            logMessage("Missions screen - Not yet implemented.", "fore-blue");
        }

        function showGuildStashScreen() {
            if (!playerData.guild_unlocked) {
                logMessage("Access denied. Guild not yet unlocked.", "fore-red", "");
                showGuildMenu();
                return;
            }
            stopAllAutoActions();
            populateGuildStashDisplay();
            showSection('guild-stash-section');
        }

        function populateGuildStashDisplay() {
            const listDiv = document.getElementById('guild-stash-list');
            listDiv.innerHTML = ''; // Clear previous content

            let hasItems = false;
            const itemsToDisplay = [];

            for (const itemName in playerData.guild_stash) {
                const quantity = playerData.guild_stash[itemName];
                // Skip "none" slots or items with 0 quantity
                if (typeof quantity === 'string' || quantity <= 0) {
                    continue;
                }

                hasItems = true;
                let emoji = "&nbsp;";
                let displayItemName = titleCase(itemName);
                let itemColorClass = "fore-white"; // Default color

                // Logic to determine emoji and color (similar to player inventory)
                if (SWORD_DATA[itemName]) { emoji = SWORD_DATA[itemName].emoji; itemColorClass = SWORD_DATA[itemName].color; }
                else if (ARMOR_DATA[itemName]) { emoji = ARMOR_DATA[itemName].emoji; itemColorClass = ARMOR_DATA[itemName].color; }
                else if (itemName === "egg") { emoji = ""; }
                else if (itemName === "goblin beads") { emoji = ""; }
                else if (itemName === "dragon gem") { emoji = "<span class='fore-red'></span>"; }
                else if (itemName === "demon heart") { emoji = "<span class='fore-magenta'></span>"; }
                else if (itemName === "burnt meat") { emoji = "  "; itemColorClass = "fore-dark-grey"; }
                else if (itemName.endsWith(" ore")) {
                    const baseName = itemName.split(" ")[0];
                    if (ORE_DATA[baseName]) { emoji = ORE_DATA[baseName].emoji; itemColorClass = ORE_DATA[baseName].color; }
                } else if (itemName.endsWith(" logs")) {
                    const baseName = itemName.split(" ")[0];
                    if (TREE_DATA[baseName]) { emoji = TREE_DATA[baseName].emoji; itemColorClass = (TREE_DATA[baseName].color || "fore-green"); }
                } else if (FOOD_DATA[itemName]) {
                    emoji = FOOD_DATA[itemName].emoji; itemColorClass = (FOOD_DATA[itemName].color || "fore-green");
                } else if (COOKABLE_ITEMS[itemName.replace(/s$/, '')]) {
                    const cookableBase = itemName.replace(/s$/, '');
                    if (COOKABLE_ITEMS[cookableBase]) { emoji = COOKABLE_ITEMS[cookableBase].emoji; itemColorClass = (COOKABLE_ITEMS[cookableBase].color || "fore-white");}
                } else if (BAR_DATA[itemName]) {
                    emoji = BAR_DATA[itemName].emoji; itemColorClass = BAR_DATA[itemName].color;
                } else if (TOOL_DATA.axe[itemName] || TOOL_DATA.pickaxe[itemName]) { // For unequipped tools by material name
                    const toolType = TOOL_DATA.axe[itemName] ? 'axe' : 'pickaxe';
                    const toolData = TOOL_DATA[toolType][itemName];
                    emoji = toolData.emoji; displayItemName = titleCase(itemName + " " + toolType); itemColorClass = toolData.color;
                }
                if (emoji === "&nbsp;") emoji = `<span class='${itemColorClass}'></span>`;

                itemsToDisplay.push({ originalName: itemName, displayName: displayItemName, emoji, itemColorClass, quantity });
            }

            if (!hasItems) {
                listDiv.innerHTML = "<p><i>The guild stash is currently empty. Send your members on tasks!</i></p>";
            } else {
                // Sort items alphabetically for consistent display
                itemsToDisplay.sort((a, b) => a.displayName.localeCompare(b.displayName));
                itemsToDisplay.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'item-entry item'; // Re-use player inventory styling, add .item for justify-content

                    const itemInfoWrapper = document.createElement('div'); // Wrapper for text content
                    itemInfoWrapper.style.display = 'flex';
                    itemInfoWrapper.style.alignItems = 'center';

                    const emojiSpan = document.createElement('span');
                    emojiSpan.className = 'inv-item-emoji';
                    emojiSpan.innerHTML = item.emoji;
                    itemInfoWrapper.appendChild(emojiSpan);

                    const nameSpan = document.createElement('span');
                    nameSpan.className = `item-name ${item.itemColorClass}`;
                    nameSpan.textContent = `${item.displayName}:`;
                    itemInfoWrapper.appendChild(nameSpan);

                    const quantitySpan = document.createElement('span');
                    quantitySpan.className = 'item-quantity';
                    quantitySpan.style.marginLeft = '5px'; // Add a little space after the colon
                    quantitySpan.textContent = item.quantity.toLocaleString();
                    itemInfoWrapper.appendChild(quantitySpan);
                    itemDiv.appendChild(itemInfoWrapper);

                    const transferButton = document.createElement('button');
                    transferButton.textContent = 'Transfer';
                    transferButton.title = 'Transfer specific quantity to Player Inventory';
                    transferButton.className = 'transfer-button'; // New class for styling if needed, or reuse member-action-button
                    transferButton.onclick = () => transferFromGuildStashToPlayer(item.originalName);
                    itemDiv.appendChild(transferButton);
                    // Removed individual transferAllButton

                    listDiv.appendChild(itemDiv);
                });
            }
        }

        // --- Cheats ---
        function applyCheat() {
            const cheatInput = document.getElementById('cheat-input');
            const cheatCode = cheatInput.value.trim();
            cheatInput.value = ''; 

            if (cheatCode === "rosebud") {
                playerData.gold += 50000;
                logMessage("+50,000 Gold! Shhh...", "fore-magenta", "");
            } else if (cheatCode === "rosebud-") {
                playerData.gold -= 50000;
                logMessage("-50,000 Gold! That's too bad", "fore-magenta", "");
            } else if (cheatCode === "xpboost") {
                const xpToAdd = 10000; 
                const skillsToBoost = ["attack_xp", "woodcutting_xp", "mining_xp", "cooking_xp", "blacksmithing_xp"];
                
                skillsToBoost.forEach(skillField => {
                    const oldLevel = getLevelFromXp(playerData[skillField]);
                    playerData[skillField] += xpToAdd;
                    grantUniversalXP(xpToAdd); 
                    handleLevelUp(skillField, oldLevel); 
                });
                logMessage("XP Boost applied to all skills!", "fore-magenta", "");
            } else if (cheatCode === "xpboost+") {
                const xpToAdd = 1000000;
                const skillsToBoost = ["attack_xp", "woodcutting_xp", "mining_xp", "cooking_xp", "blacksmithing_xp"];

                skillsToBoost.forEach(skillField => {
                    const oldLevel = getLevelFromXp(playerData[skillField]);
                    playerData[skillField] += xpToAdd;
                    grantUniversalXP(xpToAdd);
                    handleLevelUp(skillField, oldLevel);
                });
                logMessage("MEGA XP Boost applied to all skills! Whoa!", "fore-magenta", "");


            } else if (cheatCode === "perkmeup") {
                playerData.perk_points_earned += 5;
                 logMessage("+5 Perk Points! Total XP may not reflect this.", "fore-magenta", "");
            }
             else if (cheatCode === "buildall") { // Cheat to build all structures
                for (const structId in STRUCTURE_DATA) {
                    playerData.built_structures[structId] = true; 
                }
                logMessage("All structures magically built! Perks activated.", "fore-magenta");
                if (playerData.built_structures.cabin) { // Adjust HP for cabin
                     playerData.hp = getMaxHp(getLevelFromXp(playerData.attack_xp));
                }
                if (playerData.built_structures.stronghold) { // Adjust HP for stronghold
                     playerData.hp = getMaxHp(getLevelFromXp(playerData.attack_xp));
                }
                startRentCollection(); // Ensure rent starts
            }
            else {
                logMessage("Invalid cheat code.", "fore-red", "");
                return; 
            }
            savePlayerData();
            updateHud();
        }

        function transferFromGuildStashToPlayer(itemName) {
            if (!playerData.guild_stash || playerData.guild_stash[itemName] === undefined || playerData.guild_stash[itemName] <= 0) {
                logMessage(`Item "${titleCase(itemName)}" not found in guild stash or has 0 quantity.`, "fore-red", "");
                populateGuildStashDisplay(); // Refresh display in case of race condition
                return;
            }

            const maxQuantity = playerData.guild_stash[itemName];
            const transferAmountStr = prompt(`How many ${titleCase(itemName)} to transfer to your inventory? (Max: ${maxQuantity})`, maxQuantity);

            if (transferAmountStr === null) { // User cancelled
                logMessage("Transfer cancelled.", "fore-yellow");
                return;
            }

            const transferAmount = parseInt(transferAmountStr);

            if (isNaN(transferAmount) || transferAmount <= 0) {
                logMessage("Invalid transfer amount. Please enter a positive number.", "fore-red", "");
                return;
            }
            if (transferAmount > maxQuantity) {
                logMessage(`Cannot transfer ${transferAmount}. Only ${maxQuantity} ${titleCase(itemName)} available in stash.`, "fore-red", "");
                return;
            }

            playerData.guild_stash[itemName] -= transferAmount;
            playerData.inventory[itemName] = (playerData.inventory[itemName] || 0) + transferAmount;

            logMessage(`Transferred ${transferAmount} ${titleCase(itemName)} from Guild Stash to your inventory.`, "fore-magenta", "");
            savePlayerData();
            populateGuildStashDisplay(); // Refresh the stash display
            updateHud(); // Update HUD in case gold or other tracked items change (though not directly here)
        }

        function transferAllItemsFromGuildStashToPlayer() {
            let itemsToTransferCount = 0;
            for (const itemName in playerData.guild_stash) {
                if (typeof playerData.guild_stash[itemName] === 'number' && playerData.guild_stash[itemName] > 0) {
                    itemsToTransferCount++;
                }
            }

            if (itemsToTransferCount === 0) {
                logMessage("Guild Stash is empty. Nothing to transfer.", "fore-yellow", "");
                return;
            }

            if (!confirm("Are you sure you want to transfer ALL items from the Guild Stash to your inventory?")) {
                logMessage("Transfer All operation cancelled.", "fore-yellow");
                return;
            }

            let transferredItemsSummary = [];
            for (const itemName in playerData.guild_stash) {
                const quantity = playerData.guild_stash[itemName];
                if (typeof quantity === 'number' && quantity > 0) {
                    playerData.inventory[itemName] = (playerData.inventory[itemName] || 0) + quantity;
                    playerData.guild_stash[itemName] = 0;
                    transferredItemsSummary.push(`${quantity.toLocaleString()} ${titleCase(itemName)}`);
                }
            }
            logMessage(`Transferred all items from Guild Stash to your inventory: ${transferredItemsSummary.join(', ')}.`, "fore-magenta", "");
            savePlayerData();
            populateGuildStashDisplay(); // Refresh the stash display
            updateHud();
        }

        // --- Game Control ---
        function quitGame() { // Not explicitly called by a button, but good practice to have
            stopAllAutoActions(); 
            if (rentInterval) clearInterval(rentInterval);
            savePlayerData();
            logMessage("Game saved. Thanks for playing!", "fore-blue", "");
        }
        window.addEventListener('beforeunload', quitGame); // Auto-save on closing tab/browser

        // --- Initialization ---
        function initGame() {
            console.log("initGame: Starting game initialization.");
            loadPlayerData(); 
            // console.log("initGame: playerData state after loadPlayerData:", JSON.parse(JSON.stringify(playerData)));

            const isFirstTimeCheckValue = localStorage.getItem('textAdventurePlayerData');
            // console.log("initGame: Value from localStorage for isFirstTime check (isFirstTimeCheckValue):", isFirstTimeCheckValue);
            const isFirstTime = !isFirstTimeCheckValue; 
            const playerDataKeyCount = Object.keys(playerData).length;
            if (isFirstTime || playerDataKeyCount < 5) {
                console.log(`initGame: Condition for reset met. isFirstTime: ${isFirstTime}, playerData keys: ${playerDataKeyCount}. Resetting to DEFAULT_PLAYER.`);
                playerData = JSON.parse(JSON.stringify(DEFAULT_PLAYER)); 
                savePlayerData();  
                logMessage("Welcome to the Adventure! New game started.", "fore-blue", "");
            } else {
                console.log("initGame: Game data seems valid, proceeding with loaded data."); 
                logMessage("Game loaded. Welcome back, " + (playerData.name || "Adventurer") + "!", "fore-blue");
            }
            
            // Ensure getMaxHp is called AFTER playerData (and its built_structures) is loaded
            playerData.hp = Math.min(playerData.hp, getMaxHp(getLevelFromXp(playerData.attack_xp)));


            const savedMuteState = localStorage.getItem('textAdventureSoundsMuted');
            if (savedMuteState !== null) {
                soundsMuted = savedMuteState === 'true';
            }
            const muteButton = document.getElementById('mute-toggle-btn');
            muteButton.textContent = soundsMuted ? "Unmute Sounds" : "Mute Sounds";
            muteButton.onclick = toggleMute;

            // Load saved inventory sort preference
            const savedInventorySort = localStorage.getItem('textAdventureInventorySort');
            if (savedInventorySort) {
                currentInventorySort = savedInventorySort;
            }
            
            updatePerkPoints(); // Call this to calculate initial perk points from total_skill_xp
            updateHud(); // Now updateHud can use fully initialized playerData including perk points and maxHP
            startRentCollection(); // Start rent timer if applicable based on loaded save
            
            // Set initial active sort button
            const initialSortButton = document.getElementById(`sort-inv-${currentInventorySort}`);
            if (initialSortButton) {
                initialSortButton.classList.add('active-sort');
            }
            showMainMenu(); // This will eventually call populateInventoryDisplay if user navigates there
            adjustButtonLabels(); // Initial check for all buttons
            window.addEventListener('resize', debounce(adjustButtonLabels, 150));
        }

        document.addEventListener('DOMContentLoaded', initGame);

    </script>
</body>
</html>