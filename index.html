<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Adventure Game</title>
    <style>
        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: #1e1e1e;
            color: #d4d4d4;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background-color: #252526;
            border: 1px solid #333;
            padding: 20px;
            width: 90%;
            max-width: 800px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            position: relative;
        }

        .top-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 5px;
            z-index: 1000;
        }
        .top-controls button {
            padding: 7px 12px; 
            font-size: 0.9em;
        }
         .top-right-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
        }
        #mute-toggle-btn {
            padding: 7px 12px; 
            font-size: 0.9em;
        }


        .hud {
            background-color: #2a2a2d;
            border: 1px solid #444;
            padding: 10px;
            margin-bottom: 15px;
            margin-top: 50px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        .hud-column { display: flex; flex-direction: column; gap: 3px; }
        .section {
            border: 1px solid #444;
            padding: 10px;
            margin-bottom: 15px;
        }

        .section-title { font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid #555; padding-bottom: 5px; }

        button {
            background-color: #0e639c;
            color: #222; 
            border: 1px solid #1c7abb;
            padding: 10px 18px; 
            margin: 5px;
            cursor: pointer;
            font-family: inherit;
            border-radius: 3px;
            font-size: 1.05em; 
            font-weight: bold; 
        }
        button:hover { background-color: #1177bb; }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
            border-color: #666;
        }
        button.red { background-color: #9c0e0e; }
        button.red:hover { background-color: #bb1111; }
        button.green { background-color: #0e9c18; }
        button.green:hover { background-color: #11bb1a; }
        button.yellow {
            background-color: #b4a61a;
        }
        button.yellow:hover {
            background-color: #d4c62a;
        }


        .log-area {
            background-color: #1c1c1c;
            border: 1px dashed #555;
            padding: 10px;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
            white-space: pre-wrap;
        }

        .item, .monster-display, .skill-resource, .perk-entry {
            border: 1px solid #383838;
            padding: 8px;
            margin: 5px 0;
            background-color: #2d2d30;
            cursor: pointer; /* Existing */
            display: flex; /* New: for layout */
            justify-content: space-between; /* New: pushes count to the right */
            align-items: center; /* New: vertically aligns text and count */
        }
        .item:hover, .skill-resource:hover, .perk-entry:hover:not(.disabled-perk):not(.activated-perk) {
             background-color: #3a3d41;
        }
        .resource-inventory-count { /* New style for the count itself */
            background-color: #1c1c1c; padding: 2px 6px; border-radius: 4px; margin-left: 10px; font-weight: bold;
        }
        .monster-display .emoji { font-size: 2em; }
        .perk-entry.disabled-perk { cursor: not-allowed; background-color: #444; color: #888; }
        .perk-entry.activated-perk { cursor: default; background-color: #0e9c18; color: white; }
        .attacking-monster-list-item {
            background-color: #5e0000 !important; 
            border: 1px solid #ff4444 !important; 
            color: #fff !important;
        }
        .perk-entry .perk-cost { float: right; color: #dcdcaa;}
        .perk-entry .perk-desc { font-size: 0.9em; color: #aaa; margin-top: 3px;}
        
        .active-woodcutting-item, .active-mining-item, 
        .active-cooking-item, .active-smelting-item, .active-smithing-item {
            background-color: #004d00 !important; 
            border: 2px solid #33cc33 !important; 
            color: #fff !important;
            box-shadow: 0 0 8px #33cc33;
        }
        .active-mining-item {
            background-color: #33334d !important;
            border: 2px solid #6666cc !important;
            box-shadow: 0 0 8px #6666cc;
        }
        .active-smelting-item, .active-smithing-item {
            background-color: #502d00 !important;
            border: 2px solid #ff8c1a !important;
            box-shadow: 0 0 8px #ff8c1a;
        }
        .active-cooking-item {
            background-color: #665200 !important;
            border: 2px solid #ffcc00 !important;
            box-shadow: 0 0 8px #ffcc00;
        }

        .button-icon {
            display: inline-block; 
            transition: transform 0.2s ease-out, filter 0.2s ease-out;
            margin-right: 4px; 
        }
        button:hover .button-icon {
            transform: scale(1.3);
            filter: drop-shadow(0 0 5px #fff);
        }

        /* Color classes */
        .fore-blue { color: #569cd6; }
        .fore-green { color: #6a9955; }
        .fore-lightblack_ex { color: #999999; }
        .fore-yellow { color: #dcdcaa; }
        .fore-cyan { color: #4ec9b0; }
        .fore-red { color: #f44747; }
        .fore-lightred_ex { color: #ff7f7f; }
        .fore-magenta { color: #c586c0; }
        .fore-white { color: #d4d4d4; }
        .fore-orange { color: #ce9178; }
        .fore-dark-grey { color: #666666; }


        .hidden { display: none; }
        .inline-block { display: inline-block; }

        #equipment-display .slot { margin-bottom: 10px;}
        #equipment-display .slot-name { font-weight: bold; display: inline-block; width: 80px;}
        #equipment-display .item-name { margin-left: 10px; }
        #equipment-display .item-art { font-size: 1.5em; margin-left: 10px;}
        
        #inventory-list .item-entry {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        #inventory-list .inv-item-emoji {
            display: inline-block;
            width: 2.2em; 
            text-align: left;
            margin-right: 5px;
        }
        #inventory-list .item-name { 
            margin-right: 10px; 
        }
        #inventory-list .item-quantity { font-weight: bold; }

        #char-info-details p { margin: 5px 0; }
        .char-info-label { display: inline-block; width: 180px; font-weight: normal; color: #a0a0a0; }
        .char-info-value { font-weight: bold; }
        .char-info-xp { font-size: 0.9em; color: #b0b0b0; }


        .shop-item, .inv-item-equip, .cookable-item-list, .food-item-list, .smeltable-item-list, .smithable-item-list {
            cursor: pointer;
            padding: 5px;
        }
        .shop-item:hover, .inv-item-equip:hover, .cookable-item-list:hover, .food-item-list:hover, .smeltable-item-list:hover, .smithable-item-list:hover {
            background-color: #3a3d41;
        }
        .shop-item .price { float: right; color: #dcdcaa; }
        .shop-item .req { font-size: 0.9em; color: #888; }

        .hud-item {
            display: flex;
            align-items: center;
        }
        .hud-icon {
            font-size: 1.2em;
            margin-right: 8px;
            display: inline-block;
            transition: transform 0.2s ease-out, filter 0.2s ease-out;
            position: relative;
            cursor: default;
        }
        .hud-icon:hover {
            transform: scale(1.3);
            filter: drop-shadow(0 0 5px #fff);
        }
        .hud-icon .tooltip-text {
            visibility: hidden;
            width: max-content;
            max-width: 150px;
            background-color: #111;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%; 
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8em;
            pointer-events: none;
        }
        .hud-icon:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        .main-menu-buttons-container {
            display: flex;
            gap: 5px; 
            margin-bottom: 10px; 
        }
        .main-menu-buttons-container button {
            flex: 1; 
            margin: 0; 
            padding: 10px 12px; 
            text-align: center; 
            min-width: 0; /* Allow buttons to shrink */
        }
        #main-menu-section .btn-actions { background-color: #0e9c18; border-color: #0c8314; }
        #main-menu-section .btn-actions:hover { background-color: #11bb1a; }
        #main-menu-section .btn-shop {
            background-color: #b4a61a;
            border-color: #a09417;
        }
        #main-menu-section .btn-shop:hover { background-color: #d4c62a; }
        #main-menu-section .btn-perks { background-color: #c586c0; border-color: #b373ac; }
        #main-menu-section .btn-perks:hover { background-color: #d993d3; }

        .submenu-buttons-container {
            display: flex;
            gap: 5px; 
            margin-bottom: 10px; 
        }
        .submenu-buttons-container button {
            flex: 1; 
            margin: 0; 
            padding: 10px 12px; 
            text-align: center; 
            min-width: 0; /* Allow buttons to shrink */
        }

        #actions-menu-section .btn-woodcutting { background-color: #588f46; border-color: #4a7a3a; }
        #actions-menu-section .btn-woodcutting:hover { background-color: #6aab55; }
        #actions-menu-section .btn-mining { background-color: #6c757d; border-color: #5a6268; }
        #actions-menu-section .btn-mining:hover { background-color: #808890; }
        #actions-menu-section .btn-blacksmithing { background-color: #d66f2e; border-color: #c06021; }
        #actions-menu-section .btn-blacksmithing:hover { background-color: #e8823f; }
        #actions-menu-section .btn-combat { background-color: #c9302c; border-color: #ac2925; }
        #actions-menu-section .btn-combat:hover { background-color: #e04440; }
        #actions-menu-section .btn-eat { background-color: #4cae4c; border-color: #459c45; }
        #actions-menu-section .btn-eat:hover { background-color: #5cb85c; }
        #actions-menu-section .btn-cook {
            background-color: #eea236;
            border-color: #d58d20;
        }
        #actions-menu-section .btn-cook:hover { background-color: #f0ad4e; }
        #actions-menu-section .btn-build-structures { background-color: #795548; border-color: #6a4a3e; }
        #actions-menu-section .btn-build-structures:hover { background-color: #8d6e63; }

        #shop-menu-section .btn-buy-tools {
            background-color: #d4af37;
            /* color: #3e300b; Inherited */
            border-color: #c09d31;
        }
        #shop-menu-section .btn-buy-tools:hover { background-color: #e6c350; }
        #shop-menu-section .btn-sell-items {
            background-color: #a7b0b9;
            /* color: #2a2d30; Inherited */
            border-color: #979fa6;
        }
        #shop-menu-section .btn-sell-items:hover { background-color: #c1c8cf; }

        #blacksmithing-menu-section .btn-smelt-bars { background-color: #e07a5f; border-color: #ca6b50; }
        #blacksmithing-menu-section .btn-smelt-bars:hover { background-color: #f28c70; }
        #blacksmithing-menu-section .btn-smith-weapons { background-color: #8d6e63; border-color: #7b5f55; }
        #blacksmithing-menu-section .btn-smith-weapons:hover { background-color: #a18278; }

        #available-structures-list .item {
            border-left: 5px solid #569cd6;
        }
        #available-structures-list .item h3 {
            margin-top: 0;
            color: #569cd6;
        }
        #available-structures-list .item p em {
            color: #6a9955; 
        }
        .glow-green-temp {
            background-color: #0e9c18 !important; /* Strong green */
            border-color: #33ff33 !important;
            box-shadow: 0 0 15px #33ff33, 0 0 8px #33ff33 inset !important; /* Green glow */
            color: white !important;
            transition: background-color 0.1s ease-out, box-shadow 0.1s ease-out, border-color 0.1s ease-out;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="top-controls">
            <button onclick="exportSaveData()" title="Download current game progress to a file">Save Game</button>
            <input type="file" id="import-file-input" accept=".json,.txt" style="display: none;" onchange="handleImportFile(event)">
            <button onclick="document.getElementById('import-file-input').click()" title="Load game progress from a previously saved file">Load Game</button>
        </div>
        <div class="top-right-controls">
             <button id="mute-toggle-btn">Mute Sounds</button>
        </div>

        <div class="hud" id="hud">
            <div class="hud-column" id="hud-left-skills">
                <div id="hud-wc" class="hud-item"><span class="hud-icon" title="Woodcutting Skill">🌲<span class="tooltip-text">Woodcutting</span></span>Woodcutting: 1 (XP: 0/0)</div>
                <div id="hud-mn" class="hud-item"><span class="hud-icon" title="Mining Skill">⛏️<span class="tooltip-text">Mining</span></span>Mining: 1 (XP: 0/0)</div>
                <div id="hud-ck" class="hud-item"><span class="hud-icon" title="Cooking Skill">🍳<span class="tooltip-text">Cooking</span></span>Cooking: 1 (XP: 0/0)</div>
                <div id="hud-bs" class="hud-item"><span class="hud-icon" title="Blacksmithing Skill">🛠️<span class="tooltip-text">Blacksmithing</span></span>Blacksmithing: 1 (XP: 0/0)</div>
            </div>
            <div class="hud-column" id="hud-right-stats">
                <div id="hud-atk" class="hud-item"><span class="hud-icon" title="Attack Skill">⚔️<span class="tooltip-text">Attack</span></span>Attack: 1 (XP: 0/0)</div>
                <div id="hud-hp" class="hud-item fore-lightred_ex"><span class="hud-icon" title="Health Points">❤️<span class="tooltip-text">Health</span></span>HP: 10/10</div>
                <div id="hud-gold" class="hud-item fore-yellow"><span class="hud-icon" title="Your Gold">💰<span class="tooltip-text">Gold</span></span>Gold: 10</div>
                <div id="hud-perk-points" class="hud-item fore-magenta"><span class="hud-icon" title="Perk Points">✨<span class="tooltip-text">Perk Points</span></span>Perk Points: 0</div>
            </div>
        </div>

        <div id="main-menu-section" class="section">
            <div class="section-title">Main Menu</div>
            <div class="main-menu-buttons-container">
                <button class="btn-char-info" onclick="showCharacterInfo()"><span class="button-icon">📜</span>Character Info</button>
                <button class="btn-inventory" onclick="showInventory()"><span class="button-icon">🎒</span>Inventory & Equipment</button>
                <button class="btn-actions" onclick="showActionsMenu()"><span class="button-icon">▶️</span>Actions</button>
                <button class="btn-shop" onclick="showShopMenu()"><span class="button-icon">🛒</span>Shop</button>
                <button class="btn-perks" onclick="showPerkTreeMenu()"><span class="button-icon">🌟</span>Perks</button>
            </div>
            <div><input type="text" id="cheat-input" placeholder="Cheat code"><button onclick="applyCheat()">Apply</button></div>
        </div>

        <div id="character-info-section" class="section hidden">
            <div class="section-title fore-cyan">Character Information</div>
            <div id="char-info-details"></div>
            <p>Total XP Gained (All Skills): <span id="total-xp-all-skills" class="fore-magenta">0</span></p>
            <button onclick="showMainMenu()"><span class="button-icon">⬅️</span> Back</button>
        </div>
        
        <div id="inventory-section" class="section hidden">
            <div class="section-title fore-magenta">Inventory</div>
            <div id="inventory-list"></div>
            <hr>
            <div class="section-title fore-cyan">Equipped Gear</div>
            <div id="equipment-display">
                <div class="slot"><span class="slot-name">Weapon:</span><span class="item-name" id="eq-weapon-name">None</span><span class="item-art" id="eq-weapon-art"></span> <span id="eq-weapon-stats" style="font-size:0.9em; color:#aaa;"></span></div>
                <div class="slot"><span class="slot-name">Axe:</span><span class="item-name" id="eq-axe-name">None</span><span class="item-art" id="eq-axe-art"></span></div>
                <div class="slot"><span class="slot-name">Pickaxe:</span><span class="item-name" id="eq-pickaxe-name">None</span><span class="item-art" id="eq-pickaxe-art"></span></div>
                <div class="slot"><span class="slot-name">Chestplate:</span><span class="item-name" id="eq-chestplate-name">None</span><span class="item-art" id="eq-chestplate-art"></span></div>
            </div>
            <div id="equip-options-section">
                <div class="submenu-buttons-container">
                    <button onclick="showEquipSelection('weapon')">Equip Weapon</button>
                    <button onclick="showEquipSelection('axe')">Equip Axe</button>
                </div>
                <div class="submenu-buttons-container">
                    <button onclick="showEquipSelection('pickaxe')">Equip Pickaxe</button>
                    <button onclick="showEquipSelection('chestplate')">Equip Chestplate</button>
                </div>
            </div>
            <div id="item-selection-for-equip" class="hidden">
                <div class="section-title" id="equip-item-type-title">Equip Item</div>
                <div id="equip-item-list"></div>
                <button onclick="hideEquipSelection()">Cancel</button>
            </div>
            <button onclick="showMainMenu()"><span class="button-icon">⬅️</span> Back to Main Menu</button>
        </div>

        <div id="actions-menu-section" class="section hidden">
            <div class="section-title">Actions Menu</div>
            <div class="submenu-buttons-container"> 
                <button class="btn-woodcutting" onclick="showWoodcutting()"><span class="button-icon">🌲</span>Woodcutting</button>
                <button class="btn-mining" onclick="showMining()"><span class="button-icon">⛏️</span> Mining</button>
            </div>
            <div class="submenu-buttons-container"> 
                <button class="btn-blacksmithing" onclick="showBlacksmithingMenu()"><span class="button-icon">🛠️</span> Blacksmithing</button>
                <button class="btn-combat" onclick="showCombat()"><span class="button-icon">⚔️</span> Attack Monsters</button>
            </div>
            <div class="submenu-buttons-container"> 
                <button class="btn-eat" onclick="showEatFood()"><span class="button-icon">🍖</span> Eat Food</button>
                <button class="btn-cook" onclick="showCookFood()"><span class="button-icon">🍳</span> Cook Food</button>
                <button class="btn-build-structures" onclick="showBuildStructuresMenu()"><span class="button-icon">🏗️</span> Build Structures</button>
            </div>
            <button onclick="showMainMenu()"><span class="button-icon">⬅️</span> Back to Main Menu</button>
        </div>

        <div id="shop-menu-section" class="section hidden">
            <div class="section-title fore-green">Store</div>
            <div id="shop-gold-display" class="fore-yellow"></div>
            <div class="submenu-buttons-container">
                <button class="btn-buy-tools" onclick="showBuyMenu()">1. Buy Tools</button>
                <button class="btn-sell-items" onclick="showSellMenu()">2. Sell Items</button>
            </div>
            <button onclick="showMainMenu()"><span class="button-icon">⬅️</span> Back to Main Menu</button>
        </div>
        
        <div id="buy-menu-section" class="section hidden">
            <div class="section-title fore-green">Buy Items</div>
            <div id="buy-category-selection" class="submenu-buttons-container">
                 <button onclick="populateShopItems('axe', 'Axes')">Axes</button>
                 <button onclick="populateShopItems('pickaxe', 'Pickaxes')">Pickaxes</button>
            </div>
            <div id="shop-items-list"></div>
            <button onclick="showShopMenu()"><span class="button-icon">⬅️</span> Back to Shop</button>
        </div>

        <div id="sell-menu-section" class="section hidden">
            <div class="section-title fore-green">Sell Items</div>
            <div id="sellable-items-list"></div>
            <button onclick="showShopMenu()">Back to Shop</button>
        </div>

        <div id="woodcutting-section" class="section hidden">
            <div class="section-title fore-green">Woodcutting</div>
            <div id="available-trees"></div>
            <button onclick="showActionsMenu()"><span class="button-icon">⬅️</span> Back to Actions</button>
        </div>
        
        <div id="mining-section" class="section hidden">
            <div class="section-title fore-lightblack_ex">Mining</div>
            <div id="available-ores"></div>
            <button onclick="showActionsMenu()"><span class="button-icon">⬅️</span> Back to Actions</button>
        </div>
        
        <div id="blacksmithing-menu-section" class="section hidden">
            <div class="section-title fore-orange">Blacksmithing</div>
            <div class="submenu-buttons-container">
                <button class="btn-smelt-bars" onclick="showSmeltingMenu()">1. Smelt Bars</button>
                <button class="btn-smith-weapons" onclick="showSmithingMenu()">2. Smith Weapons</button>
            </div>
            <button onclick="showActionsMenu()"><span class="button-icon">⬅️</span> Back to Actions</button>
        </div>

        <div id="smelting-section" class="section hidden">
            <div class="section-title fore-orange">Smelt Bars</div>
            <div id="available-bars-to-smelt"></div>
            <button onclick="showBlacksmithingMenu()"><span class="button-icon">⬅️</span> Back to Blacksmithing</button>
        </div>

        <div id="smithing-section" class="section hidden">
            <div class="section-title fore-orange">Smith Items</div>
            <div id="available-items-to-smith"></div>
            <button onclick="showBlacksmithingMenu()"><span class="button-icon">⬅️</span> Back to Blacksmithing</button>
        </div>

        <div id="build-structures-section" class="section hidden">
            <div class="section-title fore-blue">Build Structures</div>
            <div id="available-structures-list"></div>
            <button onclick="showActionsMenu()"><span class="button-icon">⬅️</span> Back to Actions</button>
        </div>

        <div id="combat-section" class="section hidden">
            <div class="section-title fore-red">Combat</div>
            <div id="available-monsters"></div>
            <div id="combat-arena" class="hidden">
                <div id="monster-display-combat" class="monster-display"></div>
                <div>Player HP: <span id="player-hp-combat" class="fore-green"></span></div>
                <div>Monster HP: <span id="monster-hp-combat" class="fore-red"></span></div>
            </div>
            <button onclick="stopCombatAndReturn()"><span class="button-icon">⬅️</span> Back to Actions</button>
        </div>
        
        <div id="eat-food-section" class="section hidden">
             <div class="section-title fore-green">Eat Food</div>
             <div id="available-food-list"></div>
             <button onclick="showActionsMenu()"><span class="button-icon">⬅️</span> Back to Actions</button>
        </div>

        <div id="cook-food-section" class="section hidden">
            <div class="section-title fore-yellow">Cook Food</div>
            <div id="cookable-items-list"></div>
            <button onclick="showActionsMenu()"><span class="button-icon">⬅️</span> Back to Actions</button>
        </div>

        <div id="perk-tree-section" class="section hidden">
            <div class="section-title fore-magenta">Perk Tree</div>
            <p>Available Perk Points: <span id="available-perk-points" class="fore-magenta">0</span></p>
            <div id="perk-list"></div>
            <button onclick="showMainMenu()"><span class="button-icon">⬅️</span> Back to Main Menu</button>
        </div>

        <div class="log-area" id="log-area">Welcome to the Adventure!</div>

        <div style="text-align: center; padding-top: 20px; border-top: 1px solid #444; margin-top:20px;">
            <button class="red" onclick="confirmResetGame()">Reset All Progress</button>
        </div>
    </div>

    <script>
        // --- Sound Effects ---
        const monsterKillSound = new Audio('sounds/attack.Hard.mp3'); 
        monsterKillSound.volume = 0.1;
        const playerDieSound = new Audio('sounds/backround1.mp3'); 
        playerDieSound.volume = 0.5;
        const sellItemSound = new Audio('sounds/sell_item.wav'); 
        const skillRoundSound = new Audio('sounds/chop.mp3'); 
        skillRoundSound.volume = 0.1;
        const levelUpSound = new Audio('sounds/ding.mp3'); 
        // const buildStructureSound = new Audio('sounds/build_structure.wav'); // Example

        let soundsMuted = false;

        function playSound(sound) {
            if (soundsMuted) return;
            if (sound && typeof sound.play === 'function') {
                sound.currentTime = 0;
                sound.play().catch(e => console.warn("Sound play prevented:", e));
            }
        }

        function toggleMute() {
            soundsMuted = !soundsMuted;
            const muteButton = document.getElementById('mute-toggle-btn');
            muteButton.textContent = soundsMuted ? "Unmute Sounds" : "Mute Sounds";
            localStorage.setItem('textAdventureSoundsMuted', soundsMuted.toString());
            logMessage(soundsMuted ? "Sounds Muted" : "Sounds Unmuted", "fore-cyan");
        }


        // --- Data Structures ---
        const BASE_GATHER_INTERVAL = 1200; 
        const BASE_CRAFT_INTERVAL = 1000; 
        const BASE_COMBAT_INTERVAL = 2000;


        const LEVEL_PROGRESSION = [0];
        let _points = 0;
        for (let _lvl_idx = 1; _lvl_idx < 99; _lvl_idx++) {
            _points += Math.floor(_lvl_idx * 1.5 + 300 * (2**(_lvl_idx / 6.5)));
            const _xp_to_reach_level = Math.floor(_points / 4);
            LEVEL_PROGRESSION.push(_xp_to_reach_level);
        }

        const TOOL_DATA = {
            "axe": {
                "fists":   {"emoji": "👊",    "price":0,     "level_req":1,  "min_dmg":1,  "max_dmg":1,  "skill_type":"attack",      "color":"fore-white", "tier": "fists",
                    "yield_config": { "base": 0, "bonuses_by_tree": {"normal":[], "oak":[], "willow":[]} }
                },
                "bronze":  {"emoji": "🪓",    "price":15,    "level_req":1,  "min_dmg":1,  "max_dmg":2,  "skill_type":"woodcutting", "color":"fore-yellow", "tier": "bronze",
                    "yield_config": { "base": 1, "bonuses_by_tree": {
                        "normal": [{ "chance": 0.20, "amount": 1 }],
                        "oak":    [{ "chance": 0.05, "amount": 1 }],
                        "willow": [{ "chance": 0.01, "amount": 1 }]
                    }}
                },
                "iron":    {"emoji": "🪓",    "price":50,    "level_req":15, "min_dmg":2,  "max_dmg":3,  "skill_type":"woodcutting", "color":"fore-lightblack_ex", "tier": "iron",
                    "yield_config": { "base": 1, "bonuses_by_tree": {
                        "normal": [{ "chance": 0.70, "amount": 1 }],
                        "oak":    [{ "chance": 0.25, "amount": 1 }],
                        "willow": [{ "chance": 0.05, "amount": 1 }]
                    }}
                },
                "steel":   {"emoji": "🪓",    "price":120,   "level_req":30, "min_dmg":3,  "max_dmg":5,  "skill_type":"woodcutting", "color":"fore-cyan", "tier": "steel",
                    "yield_config": { "base": 1, "bonuses_by_tree": {
                        "normal": [{ "chance": 0.85, "amount": 1 }, { "chance": 0.35, "amount": 1 }],
                        "oak":    [{ "chance": 0.80, "amount": 1 }, { "chance": 0.30, "amount": 1 }],
                        "willow": [{ "chance": 0.75, "amount": 1 }, { "chance": 0.25, "amount": 1 }]
                    }}
                },
                "mithril": {"emoji": "🪓",    "price":300,   "level_req":45, "min_dmg":5,  "max_dmg":8,  "skill_type":"woodcutting", "color":"fore-blue", "tier": "mithril",
                    "yield_config": { "base": 2, "bonuses_by_tree": {
                        "normal": [{ "chance": 0.80, "amount": 1 }],
                        "oak":    [{ "chance": 0.70, "amount": 1 }],
                        "willow": [{ "chance": 0.60, "amount": 1 }]
                    }}
                },
                "adamant": {"emoji": "🪓",    "price":750,   "level_req":60, "min_dmg":8,  "max_dmg":12, "skill_type":"woodcutting", "color":"fore-green", "tier": "adamant",
                    "yield_config": { "base": 2, "bonuses_by_tree": {
                        "normal": [{ "chance": 0.90, "amount": 1 }, { "chance": 0.50, "amount": 1 }],
                        "oak":    [{ "chance": 0.85, "amount": 1 }, { "chance": 0.45, "amount": 1 }],
                        "willow": [{ "chance": 0.80, "amount": 1 }, { "chance": 0.40, "amount": 1 }]
                    }}
                },
                "rune":    {"emoji": "🪓",    "price":2000,  "level_req":75, "min_dmg":12, "max_dmg":18, "skill_type":"woodcutting", "color":"fore-magenta", "tier": "rune",
                    "yield_config": { "base": 2, "bonuses_by_tree": {
                        "normal": [{ "chance": 0.95, "amount": 1 }, { "chance": 0.75, "amount": 1 }],
                        "oak":    [{ "chance": 0.90, "amount": 1 }, { "chance": 0.70, "amount": 1 }],
                        "willow": [{ "chance": 0.85, "amount": 1 }, { "chance": 0.65, "amount": 1 }]
                    }}
                },
                "dragon":  {"emoji": "🪓🔥",  "price":10000, "level_req":90, "min_dmg":18, "max_dmg":25, "skill_type":"woodcutting", "color":"fore-red", "tier": "dragon",
                    "yield_config": { "base": 3, "bonuses_by_tree": {
                        "normal": [{ "chance": 0.90, "amount": 1 }, { "chance": 0.60, "amount": 1 }],
                        "oak":    [{ "chance": 0.85, "amount": 1 }, { "chance": 0.55, "amount": 1 }],
                        "willow": [{ "chance": 0.80, "amount": 1 }, { "chance": 0.50, "amount": 1 }]
                    }}
                }
            },
            "pickaxe": {
                "bronze":  {"emoji": "⛏️",    "price":10,    "level_req":1,  "min_dmg":1,  "max_dmg":2,  "skill_type":"mining", "color":"fore-yellow",        "tier": "bronze",  "yield_config": { "base": 1, "bonuses": [{ "chance": 0.15, "amount": 1 }] } },
                "iron":    {"emoji": "⛏️",    "price":40,    "level_req":15, "min_dmg":2,  "max_dmg":3,  "skill_type":"mining", "color":"fore-lightblack_ex", "tier": "iron",    "yield_config": { "base": 1, "bonuses": [{ "chance": 0.60, "amount": 1 }] } },
                "steel":   {"emoji": "⛏️",    "price":100,   "level_req":30, "min_dmg":3,  "max_dmg":5,  "skill_type":"mining", "color":"fore-cyan",          "tier": "steel",   "yield_config": { "base": 1, "bonuses": [{ "chance": 0.75, "amount": 1 }, { "chance": 0.25, "amount": 1 }] } },
                "mithril": {"emoji": "⛏️",    "price":280,   "level_req":45, "min_dmg":5,  "max_dmg":8,  "skill_type":"mining", "color":"fore-blue",          "tier": "mithril", "yield_config": { "base": 2, "bonuses": [{ "chance": 0.50, "amount": 1 }] } },
                "adamant": {"emoji": "⛏️",    "price":700,   "level_req":60, "min_dmg":8,  "max_dmg":12, "skill_type":"mining", "color":"fore-green",         "tier": "adamant", "yield_config": { "base": 2, "bonuses": [{ "chance": 0.70, "amount": 1 }, { "chance": 0.35, "amount": 1 }] } },
                "rune":    {"emoji": "⛏️",    "price":1900,  "level_req":75, "min_dmg":12, "max_dmg":18, "skill_type":"mining", "color":"fore-magenta",       "tier": "rune",    "yield_config": { "base": 2, "bonuses": [{ "chance": 0.85, "amount": 1 }, { "chance": 0.65, "amount": 1 }] } },
                "dragon":  {"emoji": "⛏️🔥",  "price":9500,  "level_req":90, "min_dmg":18, "max_dmg":25, "skill_type":"mining", "color":"fore-red",           "tier": "dragon",  "yield_config": { "base": 3, "bonuses": [{ "chance": 0.75, "amount": 1 }, { "chance": 0.45, "amount": 1 }] } }
            }
        };
        
        const SWORD_DATA = {
            "bronze 2h sword":   {"emoji": "🗡️",   "smith_level_req":1,  "wield_level_req":1,  "min_dmg":5,   "max_dmg":8,   "skill_type":"attack", "color":"fore-yellow",        "lifesteal_chance": 0.02, "lifesteal_amount": 1,     "recipe": {"bronze bar": 5}},
            "iron 2h sword":     {"emoji": "🗡️",   "smith_level_req":15, "wield_level_req":15, "min_dmg":10,  "max_dmg":16,  "skill_type":"attack", "color":"fore-lightblack_ex", "lifesteal_chance": 0.03, "lifesteal_amount": [1,2], "recipe": {"iron bar": 5}},
            "steel 2h sword":    {"emoji": "🗡️",   "smith_level_req":30, "wield_level_req":30, "min_dmg":18,  "max_dmg":28,  "skill_type":"attack", "color":"fore-cyan",          "lifesteal_chance": 0.04, "lifesteal_amount": [2,3], "recipe": {"steel bar": 5}},
            "mithril 2h sword":  {"emoji": "🗡️",   "smith_level_req":45, "wield_level_req":45, "min_dmg":30,  "max_dmg":45,  "skill_type":"attack", "color":"fore-blue",          "lifesteal_chance": 0.05, "lifesteal_amount": [2,4], "recipe": {"mithril bar": 5}},
            "adamant 2h sword":  {"emoji": "🗡️",   "smith_level_req":60, "wield_level_req":60, "min_dmg":48,  "max_dmg":70,  "skill_type":"attack", "color":"fore-green",         "lifesteal_chance": 0.06, "lifesteal_amount": [3,5], "recipe": {"adamantite bar": 5}},
            "rune 2h sword":     {"emoji": "🗡️",   "smith_level_req":75, "wield_level_req":75, "min_dmg":72,  "max_dmg":100, "skill_type":"attack", "color":"fore-magenta",       "lifesteal_chance": 0.07, "lifesteal_amount": [4,6], "recipe": {"runite bar": 5}},
            "dragon 2h sword":   {"emoji": "🗡️🔥", "smith_level_req":90, "wield_level_req":90, "min_dmg":100, "max_dmg":140, "skill_type":"attack", "color":"fore-red",           "lifesteal_chance": 0.08, "lifesteal_amount": [5,8], "recipe": {"dragon bar": 5}}
        };


        const FOOD_DATA = {
            "cooked meat":       {"heal_amount": 5,  "sell_price": 2, "emoji": "🍖"}, 
            "bread":             {"heal_amount": 3,  "sell_price": 1, "emoji": "🍞"},
            "health potion (s)": {"heal_amount": 15, "sell_price": 10, "emoji": "🧪"}
        };

        const COOKABLE_ITEMS = {
            "raw meat": {"cooked_item":"cooked meat", "burnt_item":"burnt meat", "xp_gain":10, "level_req":1, "difficulty_level":1, "emoji": "🥩"},
        };
        
        const ARMOR_DATA = {
            "bronze chestplate":  {"defense":0.03, "price":40,    "level_req":5,  "color":"fore-yellow",        "emoji":"🛡️"},
            "iron chestplate":    {"defense":0.06, "price":100,   "level_req":15, "color":"fore-lightblack_ex", "emoji":"🛡️"},
            "steel chestplate":   {"defense":0.09, "price":250,   "level_req":30, "color":"fore-cyan",          "emoji":"🛡️"},
            "mithril chestplate": {"defense":0.12, "price":600,   "level_req":45, "color":"fore-blue",          "emoji":"🛡️"},
            "adamant chestplate": {"defense":0.15, "price":1500,  "level_req":60, "color":"fore-green",         "emoji":"🛡️"},
            "rune chestplate":    {"defense":0.18, "price":5000,  "level_req":75, "color":"fore-magenta",       "emoji":"🛡️"},
            "dragon chestplate":  {"defense":0.22, "price":20000, "level_req":90, "color":"fore-red",           "emoji":"🛡️🔥"}
        };
        
        const BAR_DATA = {
            "bronze bar":     {"emoji": "<span class='fore-yellow'>🟧</span>",   "level_req": 1,  "xp_gain": 10,  "color": "fore-yellow",        "recipe": {"copper ore": 1, "tin ore": 1}},
            "iron bar":       {"emoji": "<span class='fore-lightblack_ex'>⬜</span>",   "level_req": 15, "xp_gain": 20,  "color": "fore-lightblack_ex", "recipe": {"iron ore": 1}},
            "steel bar":      {"emoji": "<span class='fore-white'>🔳</span>",   "level_req": 30, "xp_gain": 30,  "color": "fore-cyan",          "recipe": {"iron ore": 1, "coal": 2}},
            "mithril bar":    {"emoji": "<span class='fore-blue'>🟦</span>",   "level_req": 45, "xp_gain": 50,  "color": "fore-blue",          "recipe": {"mithril ore": 1, "coal": 4}},
            "adamantite bar": {"emoji": "<span class='fore-green'>🟩</span>",   "level_req": 60, "xp_gain": 70,  "color": "fore-green",         "recipe": {"adamantite ore": 1, "coal": 6}},
            "runite bar":     {"emoji": "<span class='fore-magenta'>🟪</span>",   "level_req": 75, "xp_gain": 100, "color": "fore-magenta",       "recipe": {"runite ore": 1, "coal": 8}},
            "dragon bar":     {"emoji": "<span class='fore-red'>🟥</span>🔥", "level_req": 90, "xp_gain": 150, "color": "fore-red",           "recipe": {"special dragon ore": 1, "coal": 10}}
        };

        const ORE_DATA = { 
            "copper":    {"level_req": 1,  "xp": 15,  "item_name": "copper ore",     "color": "fore-orange", "emoji": "<span class='fore-orange'>🟠</span>"},
            "tin":       {"level_req": 1,  "xp": 15,  "item_name": "tin ore",        "color": "fore-lightblack_ex", "emoji": "<span class='fore-lightblack_ex'>🪨</span>"},
            "iron":      {"level_req": 15, "xp": 35,  "item_name": "iron ore",       "color": "fore-white",  "emoji": "<span class='fore-white'>⚪</span>"},
            "coal":      {"level_req": 30, "xp": 40,  "item_name": "coal",           "color": "fore-lightblack_ex", "emoji": "<span class='fore-lightblack_ex'>⚫</span>", "required_pickaxe_tier": "steel"},
            "mithril":   {"level_req": 45, "xp": 80,  "item_name": "mithril ore",    "color": "fore-blue",   "emoji": "<span class='fore-blue'>🔵</span>", "required_pickaxe_tier": "steel"},
            "adamantite":{"level_req": 60, "xp": 120, "item_name": "adamantite ore", "color": "fore-green",  "emoji": "<span class='fore-green'>🟢</span>", "required_pickaxe_tier": "steel"},
            "runite":    {"level_req": 75, "xp": 200, "item_name": "runite ore",     "color": "fore-magenta","emoji": "<span class='fore-magenta'>🟣</span>", "required_pickaxe_tier": "steel"},
            "special dragon ore": {"level_req": 90, "xp":300,"item_name":"special dragon ore","color":"fore-red","emoji":"<span class='fore-red'>🔴</span>🔥", "required_pickaxe_tier": "steel"}
        };
        
        const STRUCTURE_DATA = {
            "camp": {
                name: "Camp", emoji: "⛺️",
                cost: { "normal logs": 100 },
                perk_desc: "+5% chance for an extra base log/ore from Woodcutting/Mining.",
                perk_effect: { type: "base_gather_yield_bonus", value: 0.05 },
                requires_structure: null, 
                rent_value: 0 
            },
            "shed": {
                name: "Shed", emoji: "🛖",
                cost: { "normal logs": 500, "oak logs": 100 },
                perk_desc: "All crafting actions (Cooking, Smelting, Smithing) are 5% faster.",
                perk_effect: { type: "crafting_speed_boost", value: 0.05 },
                requires_structure: "camp",
                rent_value: 1 
            },
            "cabin": {
                name: "Cabin", emoji: "🏡",
                cost: { "oak logs": 1000, "willow logs": 200, "bronze bar": 50 },
                perk_desc: "Increases Max HP by +10.",
                perk_effect: { type: "max_hp_bonus", value: 10 },
                requires_structure: "shed",
                rent_value: 5 
            },
            "house": {
                name: "House", emoji: "🏠",
                cost: { "willow logs": 2500, "iron bar": 300, "bronze bar": 100 },
                perk_desc: "Increases all Skill XP gain by +2%. Also grants a 5% chance for non-chicken monsters to drop bonus gold equal to 10% of their base gold drop (stacks with Mansion).",
                perks: [ 
                    { type: "global_xp_boost", value: 0.02 },
                    { type: "scaled_bonus_mob_gold_drop_chance", value: 0.05, bonus_gold_percentage_of_base: 0.10 }
                ],
                requires_structure: "cabin",
                rent_value: 15 
            },
            "mansion": {
                name: "Mansion", emoji: "🏯",
                cost: { "willow logs": 5000, "steel bar": 200, "coal": 100 },
                perk_desc: "Grants a 10% chance for monster kills to drop double their normal gold amount.",
                perks: [
                    { type: "monster_gold_drop_multiplier_chance", value: 0.10, multiplier: 2 }
                ],
                requires_structure: "house",
                rent_value: 40 
            },
            "castle": {
                name: "Castle", emoji: "🏰",
                cost: { "willow logs": 10000, "mithril bar": 300, "adamantite bar": 100 },
                perk_desc: "Shop purchase prices -5%, item sell prices +5%.",
                perk_effect: { type: "shop_price_modifier", buy_mod: -0.05, sell_mod: 0.05 },
                requires_structure: "mansion",
                rent_value: 100 
            },
            "stronghold": {
                name: "The Stronghold", emoji: "🧱🏰🛡️",
                cost: {
                    "willow logs": 25000, 
                    "oak logs": 10000,
                    "normal logs": 5000,
                    "bronze bar": 500,
                    "iron bar": 400,
                    "steel bar": 300,
                    "mithril bar": 250,
                    "adamantite bar": 200,
                    "runite bar": 150,
                    "dragon bar": 100,
                    "dragon gem": 5, 
                    "demon heart": 10 
                },
                perk_desc: "A bastion of ultimate power. Grants +10% to all damage dealt, +25 Max HP, heals 5% of Max HP on monster kill, and all skill actions are 5% faster.",
                perks: [
                    { type: "global_damage_boost", value: 0.10 },
                    { type: "max_hp_bonus_flat", value: 25 }, 
                    { type: "heal_on_kill_percent", value: 0.05 },
                    { type: "global_skill_speed_boost", value: 0.05 }
                ],
                requires_structure: "castle", 
                rent_value: 250 
            }
        };
        const RENT_COLLECTION_INTERVAL = 5 * 60 * 1000; // 5 minutes

        const DEFAULT_PLAYER = {
            "name":"PlayerOne","woodcutting_xp":0,"attack_xp":0,"mining_xp":0,"cooking_xp":0, "blacksmithing_xp":0,
            "hp":10,"gold":10, "total_skill_xp": 0, "perk_points_earned": 0, "perk_points_spent": 0, "active_perks": {},
            "inventory": {
                "weapon":"none","axe":"none","pickaxe":"none","chestplate":"none", 
                "normal logs":0,"oak logs":0,"willow logs":0,
                "copper ore":0,"tin ore":0,"iron ore":0,"coal":0,"mithril ore":0,"adamantite ore":0,"runite ore":0,"special dragon ore":0,
                "bronze bar":0,"iron bar":0, "steel bar":0, "mithril bar":0, "adamantite bar":0, "runite bar":0, "dragon bar":0,
                "egg":0,"goblin beads":0,"dragon gem":0,
                "raw meat":0,"cooked meat":0,"bread":0,"burnt meat":0,"health potion (s)":0,
                "wolf fang":0,"bear claw":0,"ogre club fragment":0,"troll hide":0,"giant's toe":0,"demon heart":0,
            },
            "built_structures": {
                "camp": false, "shed": false, "cabin": false, "house": false, "mansion": false, "castle": false, "stronghold": false
            },
            "last_rent_collection_time": 0,
        };
        Object.keys(ARMOR_DATA).forEach(armor_name => {
            if (!(armor_name in DEFAULT_PLAYER.inventory)) DEFAULT_PLAYER.inventory[armor_name] = 0;
        });
        Object.keys(SWORD_DATA).forEach(sword_name => {
            if (!(sword_name in DEFAULT_PLAYER.inventory)) DEFAULT_PLAYER.inventory[sword_name] = 0;
        });


        const ITEM_SELL_PRICES = {
            "normal logs":1,"oak logs":3,"willow logs":5,
            "copper ore":2,"tin ore":3,"iron ore":5,"coal":4,"mithril ore":10,"adamantite ore":20,"runite ore":50,"special dragon ore":100,
            "bronze bar": 8, "iron bar": 15, "steel bar": 30, "mithril bar": 70, "adamantite bar": 150, "runite bar": 300, "dragon bar": 750,
            "egg":1,"goblin beads":10,"dragon gem":30000,
            "raw meat":1,"burnt meat":0,
            "wolf fang":15,"bear claw":30,"ogre club fragment":70,"troll hide":120,"giant's toe":250,"demon heart":500,
        };
        for (const food_name in FOOD_DATA) ITEM_SELL_PRICES[food_name] = FOOD_DATA[food_name].sell_price;
        for (const armor_name in ARMOR_DATA) ITEM_SELL_PRICES[armor_name] = Math.floor(ARMOR_DATA[armor_name].price*0.4);
        for (const sword_name in SWORD_DATA) { 
            let totalBarCost = 0;
            for(const bar in SWORD_DATA[sword_name].recipe){
                totalBarCost += (ITEM_SELL_PRICES[bar] || (BAR_DATA[bar] ? BAR_DATA[bar].level_req * 5 : 0) ) * SWORD_DATA[sword_name].recipe[bar];
            }
            ITEM_SELL_PRICES[sword_name] = Math.floor(totalBarCost * 0.8); 
        }
        
        const MONSTER_DATA = { 
            "chicken":     {"name":"Chicken", "level_req":1,  "hp":5,    "attack_xp":5,   "gold_drop": [0,1], "color":"fore-white", "emoji":"🐔", "drops":[{"item_name":"egg","base_chance":0.9, "quantity":[1,2], "always_drop_one":true},{"item_name":"raw meat","base_chance":0.7, "quantity":[1,1]}]},
            "goblin":      {"name":"Goblin", "level_req":5,  "hp":20,   "attack_xp":15,  "gold_drop": [1,5], "color":"fore-green", "emoji":"👺", "drops":[{"item_name":"goblin beads","base_chance":0.5, "quantity":[1,1]},{"item_name":"bread","base_chance":0.2, "quantity":[1,1]}, {"item_name":"bronze chestplate",  "base_chance":0.02, "quantity":[1,1]}]},
            "wolf":        {"name":"Wolf", "level_req":10, "hp":35,   "attack_xp":25,  "gold_drop": [3,8], "color":"fore-lightblack_ex", "emoji":"🐺", "drops":[{"item_name":"raw meat","base_chance":0.8, "quantity":[1,2]},{"item_name":"wolf fang","base_chance":0.3, "quantity":[1,1]}]},
            "bear":        {"name":"Bear", "level_req":20, "hp":70,   "attack_xp":50,  "gold_drop": [10,25],"color":"fore-yellow","emoji":"🐻", "drops":[{"item_name":"raw meat","base_chance":0.9, "quantity":[2,3]},{"item_name":"bear claw","base_chance":0.25, "quantity":[1,1]},{"item_name":"cooked meat","base_chance":0.1, "quantity":[1,1]}, {"item_name":"iron chestplate",    "base_chance":0.025, "quantity":[1,1]}]},
            "ogre":        {"name":"Ogre", "level_req":30, "hp":120,  "attack_xp":90,  "gold_drop": [20,50],"color":"fore-green", "emoji":"👹", "drops":[{"item_name":"ogre club fragment","base_chance":0.4, "quantity":[1,1]},{"item_name":"cooked meat","base_chance":0.3, "quantity":[1,2]}, {"item_name":"steel chestplate",   "base_chance":0.03, "quantity":[1,1]}]},
            "troll":       {"name":"Troll", "level_req":40, "hp":200,  "attack_xp":150, "gold_drop": [40,100],"color":"fore-cyan","emoji":"🧌", "drops":[{"item_name":"troll hide","base_chance":0.35, "quantity":[1,1]},{"item_name":"health potion (s)","base_chance":0.15, "quantity":[1,1]}, {"item_name":"mithril chestplate", "base_chance":0.02, "quantity":[1,1]}]},
            "giant":       {"name":"Giant", "level_req":55, "hp":350,  "attack_xp":280, "gold_drop": [75,150],"color":"fore-blue","emoji":"🗿", "drops":[{"item_name":"giant's toe","base_chance":0.2, "quantity":[1,1]},{"item_name":"cooked meat","base_chance":0.5, "quantity":[2,4]}, {"item_name":"adamant chestplate", "base_chance":0.025, "quantity":[1,1]}]},
            "demon":       {"name":"Demon", "level_req":70, "hp":500,  "attack_xp":500, "gold_drop": [150,300],"color":"fore-magenta","emoji":"😈", "drops":[{"item_name":"demon heart","base_chance":0.04, "quantity":[1,1]},{"item_name":"health potion (s)","base_chance":0.3, "quantity":[1,2]}, {"item_name":"rune chestplate",    "base_chance":0.015, "quantity":[1,1]}]},
            "dark_dragon": {"name":"Dark Dragon", "level_req":85, "hp":1200, "attack_xp":2500,"gold_drop": [500,2000],"color":"fore-red","emoji":"🐉", "drops":[{"item_name":"dragon gem","base_chance":0.02, "quantity":[1,1]},{"item_name":"health potion (s)","base_chance":0.5, "quantity":[2,3]}, {"item_name":"dragon chestplate",  "base_chance":0.01, "quantity":[1,1]}, {"item_name":"special dragon ore", "base_chance":0.1, "quantity":[1,2]}]}
        };
        const ALL_MONSTER_NAMES = Object.keys(MONSTER_DATA);
        const ALL_ORE_NAMES = Object.keys(ORE_DATA);

        const PICKAXE_TIER_ORDER = ["bronze", "iron", "steel", "mithril", "adamant", "rune", "dragon"];
        const AXE_TIER_ORDER = ["fists", "bronze", "iron", "steel", "mithril", "adamant", "rune", "dragon"];
        const TREE_DATA = { 
            "normal": {"exp":10, "log":"normal logs", "level":1,  "emoji": "🌲"},
            "oak":    {"exp":25, "log":"oak logs",    "level":15, "emoji": "🌳"},
            "willow": {"exp":55, "log":"willow logs", "level":30, "emoji": "🌿", "required_axe_tier": "steel"}
        };
        
        const MAX_PERK_POINTS = 25;
        const PERK_POINT_XP_THRESHOLDS = []; 
        function calculateCumulativeXpThresholds() {
            let current_cumulative_xp = 0;
            for (let i = 0; i < MAX_PERK_POINTS; i++) {
                let increment;
                if (i === 0) increment = 1000;
                else if (i === 1) increment = 2500;
                else increment = 2500 + (i - 1) * 1000; 
                
                current_cumulative_xp += increment;
                PERK_POINT_XP_THRESHOLDS.push(current_cumulative_xp);
            }
        }
        calculateCumulativeXpThresholds(); 

        const PERK_DATA = {
            "efficientGatherer1": {
                id: "efficientGatherer1", name: "Efficient Gatherer I",
                description: "Woodcutting and Mining actions are 5% faster.",
                cost: 1, tier: 1, type: "gathering_speed_boost", value: 0.05, requires: []
            },
            "weaponMaster1": {
                id: "weaponMaster1", name: "Weapon Master I",
                description: "2H Swords you wield deal +10% damage.",
                cost: 1, tier: 1, type: "sword_damage_boost", value: 0.10, requires: []
            },
            "preciseStrikes1": {
                id: "preciseStrikes1", name: "Precise Strikes I",
                description: "Gain a 5% chance to deal 1.5x damage in combat.",
                cost: 1, tier: 1, type: "crit_chance_boost", value: 0.05, crit_multiplier: 1.5, requires: []
            },
            "vampiricEdge1": {
                id: "vampiricEdge1", name: "Vampiric Edge I",
                description: "2H Swords you wield gain +1% lifesteal chance.",
                cost: 2, tier: 2, type: "sword_lifesteal_boost", value: 0.01, requires: ["weaponMaster1"]
            },
             "advancedSmelting": {
                id: "advancedSmelting", name: "Advanced Smelting",
                description: "10% chance to smelt an extra bar (doesn't consume extra ore).",
                cost: 2, tier: 2, type: "bonus_smelt_chance", value: 0.10, requires: []
            },
            "masterSmith": {
                id: "masterSmith", name: "Master Smith",
                description: "Smithing 2H swords requires 1 less bar (minimum 1 bar).",
                cost: 3, tier: 3, type: "smithing_bar_reduction", value: 1, requires: ["vampiricEdge1", "advancedSmelting"]
            },
            "combatSustenance": {
                id: "combatSustenance", name: "Combat Sustenance",
                description: "Automatically consumes the best available food when HP drops to 20% or below during combat.",
                cost: 5, tier: 3, type: "auto_eat_combat", value: 0.20, requires: ["vampiricEdge1"]
            }
        };


        // --- Global Game State ---
        let playerData = {};
        let currentSection = 'main-menu-section';
        
        let isAutoAttacking = false;
        let autoAttackInterval = null;
        let currentMonsterTarget = null;
        let currentMonsterHP = 0;
        
        let isAutoWoodcutting = false;
        let autoWoodcuttingInterval = null;
        let currentWoodcuttingTarget = null;

        let isAutoMining = false;
        let autoMiningInterval = null;
        let currentMiningTarget = null;

        let isAutoCooking = false;
        let autoCookingInterval = null;
        let currentCookingTarget = null;

        let isAutoSmelting = false;
        let autoSmeltingInterval = null;
        let currentSmeltingTarget = null; 
        let maxSmeltableForCurrentTarget = 0;


        let isAutoSmithing = false;
        let autoSmithingInterval = null;
        let currentSmithingTarget = null; 

        let rentInterval = null;


        // --- Utility Functions ---
        function getLevelFromXp(xp) {
            for (let i = LEVEL_PROGRESSION.length - 1; i >= 0; i--) {
                if (xp >= LEVEL_PROGRESSION[i]) return i + 1;
            }
            return 1;
        }

        function getXpForDisplay(totalXp, currentLevel) {
            if (currentLevel >= 99) {
                const xpAtLevelStart = LEVEL_PROGRESSION[98];
                const currentProgressInLevel = totalXp - xpAtLevelStart;
                return `${currentProgressInLevel} / --- (Max Level)`;
            }
            const xpAtLevelStart = LEVEL_PROGRESSION[currentLevel - 1];
            const xpForNextLevelTotal = LEVEL_PROGRESSION[currentLevel];
            const currentProgressInLevel = totalXp - xpAtLevelStart;
            const xpNeededForThisLevelUp = xpForNextLevelTotal - xpAtLevelStart;
            return `${currentProgressInLevel} / ${xpNeededForThisLevelUp}`;
        }

        function getMaxHp(attackLevel) {
            let baseMaxHp = 10 + (attackLevel - 1);
            if (playerData && playerData.built_structures && playerData.built_structures.cabin) {
                baseMaxHp += STRUCTURE_DATA.cabin.perk_effect.value;
            }
            if (playerData && playerData.built_structures && playerData.built_structures.stronghold) {
                const strongholdHpPerk = STRUCTURE_DATA.stronghold.perks.find(p => p.type === "max_hp_bonus_flat");
                if (strongholdHpPerk) {
                    baseMaxHp += strongholdHpPerk.value;
                }
            }

            return baseMaxHp;
        }


        function logMessage(message, colorClass = "fore-white") {
            const logArea = document.getElementById('log-area');
            const D = new Date();
            const timestamp = `${D.getHours().toString().padStart(2,'0')}:${D.getMinutes().toString().padStart(2,'0')}:${D.getSeconds().toString().padStart(2,'0')}`;
            logArea.innerHTML = `<span class="${colorClass}">${timestamp} - ${message}</span>\n` + logArea.innerHTML;
            if (logArea.children.length > 50) { 
                logArea.removeChild(logArea.lastChild);
            }
        }
        
        function capitalize(str) {
            if (!str) return '';
            return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
        }
        
        function titleCase(str) {
            if (!str) return '';
            return str.toLowerCase().split(' ').map(word => capitalize(word)).join(' ');
        }

        function grantUniversalXP(amount) {
            let actualAmount = amount;
            if (playerData && playerData.built_structures && playerData.built_structures.house && STRUCTURE_DATA.house.perks) {
                STRUCTURE_DATA.house.perks.forEach(perk => {
                    if (perk.type === "global_xp_boost") {
                        actualAmount *= (1 + perk.value);
                    }
                });
            }
            playerData.total_skill_xp = (playerData.total_skill_xp || 0) + Math.floor(actualAmount);
            updatePerkPoints();
        }


        function updatePerkPoints() {
            let new_points_earned = 0;
            for (const threshold of PERK_POINT_XP_THRESHOLDS) {
                if (playerData.total_skill_xp >= threshold) new_points_earned++;
                else break;
            }
            if (new_points_earned > playerData.perk_points_earned) {
                const gained = new_points_earned - playerData.perk_points_earned;
                logMessage(`You earned ${gained} new Perk Point(s)! (${playerData.total_skill_xp.toLocaleString()} total XP)`, "fore-magenta");
                playerData.perk_points_earned = new_points_earned;
            }
            // updateHud is usually called after this, or this calls updateHud. Let's ensure it's consistent.
            // No, updateHud is separate. This is fine.
        }
        
        function isPerkActive(perkId) {
            return !!playerData.active_perks[perkId];
        }


        // --- Player Data Management & Save/Load/Reset ---
        function migratePlayerData(data) {
            let dataChanged = false;
            const skills = ["woodcutting", "attack", "mining", "cooking", "blacksmithing"]; 
            skills.forEach(skill => {
                const xpField = `${skill}_xp`;
                if (!(xpField in data)) { data[xpField] = 0; dataChanged = true; }
            });
            
            if (!("total_skill_xp" in data)) { data.total_skill_xp = 0; dataChanged = true; }
            if (!("perk_points_earned" in data)) { data.perk_points_earned = 0; dataChanged = true; }
            if (!("perk_points_spent" in data)) { data.perk_points_spent = 0; dataChanged = true; }
            if (!("active_perks" in data) || typeof data.active_perks !== 'object') { data.active_perks = {}; dataChanged = true; }


            if (!("hp" in data)) { data.hp = getMaxHp(getLevelFromXp(data.attack_xp || 0)); dataChanged = true; }
            if (!("gold" in data)) { data.gold = DEFAULT_PLAYER.gold; dataChanged = true; }
            if (!("inventory" in data)) { data.inventory = JSON.parse(JSON.stringify(DEFAULT_PLAYER.inventory)); dataChanged = true; }
            else {
                for (const itemKey in DEFAULT_PLAYER.inventory) {
                    if (!(itemKey in data.inventory)) {
                        data.inventory[itemKey] = DEFAULT_PLAYER.inventory[itemKey];
                        dataChanged = true;
                    }
                }
                ["weapon", "axe", "pickaxe", "chestplate"].forEach(slot => {
                    if (data.inventory[slot] === null || data.inventory[slot] === undefined) {
                         data.inventory[slot] = "none"; dataChanged = true;
                    }
                });
                if (typeof data.inventory.fishing_rod === 'string') {
                    delete data.inventory.fishing_rod; dataChanged = true;
                }
                if ("fishing_xp" in data) { delete data.fishing_xp; dataChanged = true;}
            }
            
            if (!("built_structures" in data) || typeof data.built_structures !== 'object') {
                data.built_structures = JSON.parse(JSON.stringify(DEFAULT_PLAYER.built_structures));
                dataChanged = true;
            } else { 
                for (const structKey in DEFAULT_PLAYER.built_structures) { // Ensure all default structure keys exist
                    if (!(structKey in data.built_structures)) {
                        data.built_structures[structKey] = DEFAULT_PLAYER.built_structures[structKey];
                        dataChanged = true;
                    }
                }
            }
            if (!("last_rent_collection_time" in data)) {
                data.last_rent_collection_time = 0;
                dataChanged = true;
            }

            return { data, dataChanged };
        }

        function loadPlayerData() {
            const savedData = localStorage.getItem('textAdventurePlayerData');
            if (savedData) {
                try {
                    let parsedData = JSON.parse(savedData);
                    const migrationResult = migratePlayerData(parsedData);
                    playerData = migrationResult.data;
                    if (migrationResult.dataChanged) {
                        logMessage("Player data migrated to new format.", "fore-yellow");
                        savePlayerData(); 
                    }
                } catch (e) {
                    console.error("Error parsing player data:", e);
                    logMessage("Error loading saved data. Starting new game.", "fore-red");
                    playerData = JSON.parse(JSON.stringify(DEFAULT_PLAYER)); 
                    savePlayerData(); 
                }
            } else {
                playerData = JSON.parse(JSON.stringify(DEFAULT_PLAYER)); 
            }
        }

        function savePlayerData() {
            localStorage.setItem('textAdventurePlayerData', JSON.stringify(playerData));
        }

        function exportSaveData() {
            const saveDataString = localStorage.getItem('textAdventurePlayerData');
            if (!saveDataString) {
                logMessage("No save data found to export.", "fore-yellow");
                alert("No save data found to export.");
                return;
            }
            const blob = new Blob([saveDataString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'textAdventurePlayerData_' + new Date().toISOString().slice(0, 10) + '.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            logMessage("Game progress saved to " + a.download, "fore-green");
            alert("Game progress saved to " + a.download + "\nKeep this file safe to load your game later.");
        }

        function handleImportFile(event) {
            const file = event.target.files[0];
            if (!file) {
                logMessage("No file selected for import.", "fore-yellow");
                return;
            }
            const reader = new FileReader();
            reader.onload = function(e) {
                const fileContent = e.target.result;
                try {
                    const jsonData = JSON.parse(fileContent);
                    if (!jsonData || typeof jsonData.gold === 'undefined' || typeof jsonData.inventory === 'undefined' || typeof jsonData.attack_xp === 'undefined') {
                        throw new Error("File does not appear to be valid player data.");
                    }
                    if (confirm("Loading this save will OVERWRITE your current game in this browser. This cannot be undone. Are you sure?")) {
                        localStorage.setItem('textAdventurePlayerData', fileContent);
                        logMessage("Game data loaded successfully! Reloading game to apply changes...", "fore-green");
                        alert("Game data loaded successfully! The game will now reload.");
                        window.location.reload();
                    }
                } catch (error) {
                    logMessage("Load failed: Invalid save file. Error: " + error.message, "fore-red");
                    alert("Load failed: The selected file is not a valid save file.\nError: " + error.message);
                }
            };
            reader.onerror = function() {
                logMessage("Error reading the import file.", "fore-red");
                alert("Error reading the import file.");
            };
            reader.readAsText(file);
            event.target.value = null; 
        }

        function confirmResetGame() {
            if (confirm("Are you sure you want to ERASE ALL current game progress in this browser and start over? This cannot be undone.")) {
                resetGame();
            }
        }

        function resetGame() {
            stopAllAutoActions();
            if(rentInterval) clearInterval(rentInterval); // Stop rent timer
            localStorage.removeItem('textAdventurePlayerData');
            logMessage("All game data has been reset. Reloading to start fresh...", "fore-yellow");
            alert("All game data has been reset. The game will now reload.");
            window.location.reload();
        }

        // --- UI Update Functions ---
        function updateHud() {
            if (!playerData || playerData.attack_xp === undefined) { 
                console.warn("updateHud called before playerData is fully initialized or is malformed.");
                if (!playerData || Object.keys(playerData).length === 0) {
                    loadPlayerData(); 
                    if (!playerData || Object.keys(playerData).length === 0) { 
                        console.error("FATAL: playerData could not be initialized.");
                        alert("Error: Game data is corrupted. Please try resetting the game or importing a valid save.");
                        document.querySelectorAll('button:not(.red):not(#mute-toggle-btn)').forEach(btn => btn.disabled = true);
                        return;
                    }
                }
            }

            const atkLvl = getLevelFromXp(playerData.attack_xp);
            const maxHp = getMaxHp(atkLvl); // getMaxHp will now consider Cabin perk
            playerData.hp = Math.min(playerData.hp, maxHp); 

            const wcLvl = getLevelFromXp(playerData.woodcutting_xp);
            const mnLvl = getLevelFromXp(playerData.mining_xp);
            const ckLvl = getLevelFromXp(playerData.cooking_xp);
            const bsLvl = getLevelFromXp(playerData.blacksmithing_xp); 

            document.getElementById('hud-wc').innerHTML = `<span class="hud-icon" title="Woodcutting Skill">🌲<span class="tooltip-text">Woodcutting</span></span><span class="fore-green">Woodcutting: ${wcLvl} (XP: ${getXpForDisplay(playerData.woodcutting_xp, wcLvl)})</span>`;
            document.getElementById('hud-mn').innerHTML = `<span class="hud-icon" title="Mining Skill">⛏️<span class="tooltip-text">Mining</span></span><span class="fore-lightblack_ex">Mining: ${mnLvl} (XP: ${getXpForDisplay(playerData.mining_xp, mnLvl)})</span>`;
            document.getElementById('hud-ck').innerHTML = `<span class="hud-icon" title="Cooking Skill">🍳<span class="tooltip-text">Cooking</span></span><span class="fore-yellow">Cooking: ${ckLvl} (XP: ${getXpForDisplay(playerData.cooking_xp, ckLvl)})</span>`;
            document.getElementById('hud-bs').innerHTML = `<span class="hud-icon" title="Blacksmithing Skill">🛠️<span class="tooltip-text">Blacksmithing</span></span><span class="fore-orange">Blacksmithing: ${bsLvl} (XP: ${getXpForDisplay(playerData.blacksmithing_xp, bsLvl)})</span>`;
            document.getElementById('hud-atk').innerHTML = `<span class="hud-icon" title="Attack Skill">⚔️<span class="tooltip-text">Attack</span></span><span class="fore-red">Attack: ${atkLvl} (XP: ${getXpForDisplay(playerData.attack_xp, atkLvl)})</span>`;
            document.getElementById('hud-hp').innerHTML = `<span class="hud-icon" title="Health Points">❤️<span class="tooltip-text">Health</span></span><span class="fore-lightred_ex">HP: ${playerData.hp}/${maxHp}</span>`;
            document.getElementById('hud-gold').innerHTML = `<span class="hud-icon" title="Your Gold">💰<span class="tooltip-text">Gold</span></span><span class="fore-yellow">Gold: ${playerData.gold.toLocaleString()}</span>`;
            
            const availablePerkPoints = (playerData.perk_points_earned || 0) - (playerData.perk_points_spent || 0);
            document.getElementById('hud-perk-points').innerHTML = `<span class="hud-icon" title="Perk Points">✨<span class="tooltip-text">Perk Points</span></span><span class="fore-magenta">Perk Points: ${availablePerkPoints}</span>`;
        }

        function showSection(sectionId) {
            if(document.getElementById(currentSection)) { // Safety check
                document.getElementById(currentSection).classList.add('hidden');
            }
            if(document.getElementById(sectionId)) { // Safety check
                document.getElementById(sectionId).classList.remove('hidden');
                currentSection = sectionId;
            } else {
                console.error("Attempted to show non-existent section:", sectionId);
                showSection('main-menu-section'); // Fallback
            }
        }
        
        function hideAllActionSubsections() {
            ['woodcutting-section', 'mining-section', 'combat-section', 'eat-food-section', 'cook-food-section', 
             'blacksmithing-menu-section', 'smelting-section', 'smithing-section', 'perk-tree-section',
             'build-structures-section' // NEW
            ].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.classList.add('hidden');
            });
        }

        // --- Menu Navigation ---
        function stopAllAutoActions() { 
            stopAutoAttack();
            stopAutoWoodcutting();
            stopAutoMining();
            stopAutoCooking();
            stopAutoSmelting();
            stopAutoSmithing();
        }

        function showMainMenu() { 
            stopAllAutoActions();
            hideAllActionSubsections(); 
            showSection('main-menu-section'); 
        }
        function showCharacterInfo() { 
            const atkLvl = getLevelFromXp(playerData.attack_xp);
            const wcLvl = getLevelFromXp(playerData.woodcutting_xp);
            const mnLvl = getLevelFromXp(playerData.mining_xp);
            const ckLvl = getLevelFromXp(playerData.cooking_xp);
            const bsLvl = getLevelFromXp(playerData.blacksmithing_xp); 
            const maxHp = getMaxHp(atkLvl);
            const detailsDiv = document.getElementById('char-info-details');
            detailsDiv.innerHTML = `
                <p>Name: ${playerData.name}</p>
                <p><span class="char-info-label">Attack Level:</span> <span class="char-info-value fore-red">${atkLvl}</span> <span class="char-info-xp fore-red">(XP: ${getXpForDisplay(playerData.attack_xp, atkLvl)})</span></p>
                <p><span class="char-info-label">Woodcutting Level:</span> <span class="char-info-value fore-green">${wcLvl}</span> <span class="char-info-xp fore-green">(XP: ${getXpForDisplay(playerData.woodcutting_xp, wcLvl)})</span></p>
                <p><span class="char-info-label">Mining Level:</span> <span class="char-info-value fore-lightblack_ex">${mnLvl}</span> <span class="char-info-xp fore-lightblack_ex">(XP: ${getXpForDisplay(playerData.mining_xp, mnLvl)})</span></p>
                <p><span class="char-info-label">Cooking Level:</span> <span class="char-info-value fore-yellow">${ckLvl}</span> <span class="char-info-xp fore-yellow">(XP: ${getXpForDisplay(playerData.cooking_xp, ckLvl)})</span></p>
                <p><span class="char-info-label">Blacksmithing Level:</span> <span class="char-info-value fore-orange">${bsLvl}</span> <span class="char-info-xp fore-orange">(XP: ${getXpForDisplay(playerData.blacksmithing_xp, bsLvl)})</span></p>
                <p><span class="char-info-label">HP:</span> <span class="char-info-value fore-lightred_ex">${playerData.hp}/${maxHp}</span></p>
                <p class="fore-cyan" style="font-size:0.9em; margin-top:10px;">Max HP increases with Attack Level and Cabin/Stronghold. Heal by leveling Attack or eating food.</p>
            `;
            document.getElementById('total-xp-all-skills').textContent = (playerData.total_skill_xp || 0).toLocaleString();
            showSection('character-info-section');
        }
        
        function showInventory() {
            populateInventoryDisplay();
            populateEquipmentDisplay();
            showSection('inventory-section');
            hideEquipSelection(); 
        }

        function showActionsMenu() { 
            stopAllAutoActions();
            showSection('actions-menu-section'); 
        }

        function populateInventoryDisplay() {
            const listDiv = document.getElementById('inventory-list');
            listDiv.innerHTML = '';
            let hasItems = false;
            for (const itemName in playerData.inventory) {
                const quantity = playerData.inventory[itemName];
                const isEquippableSlot = ["weapon", "axe", "pickaxe", "chestplate"].includes(itemName);

                if (!isEquippableSlot && quantity > 0) {
                    hasItems = true;
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'item-entry';

                    let emoji = "&nbsp;";
                    let displayItemName = titleCase(itemName);
                    let itemColorClass = "fore-white";

                    // 1. Specific full names / unique items
                    if (SWORD_DATA[itemName]) {
                        emoji = SWORD_DATA[itemName].emoji || "&nbsp;";
                        itemColorClass = SWORD_DATA[itemName].color || "fore-white";
                    } else if (ARMOR_DATA[itemName]) {
                        emoji = ARMOR_DATA[itemName].emoji || "&nbsp;";
                        itemColorClass = ARMOR_DATA[itemName].color || "fore-white";
                    } else if (itemName === "egg") {
                        emoji = "🥚";
                    } else if (itemName === "goblin beads") {
                        emoji = "📿";
                    } else if (itemName === "dragon gem") {
                        emoji = "<span class='fore-red'>💎</span>";
                        itemColorClass = "fore-red";
                    } else if (itemName === "demon heart") {
                        emoji = "<span class='fore-magenta'>❤️‍🔥</span>";
                        itemColorClass = "fore-magenta";
                    } else if (itemName === "burnt meat") {
                        emoji = " ◍ "; // New emoji for burnt meat
                        itemColorClass = "fore-dark-grey";
                    }
                    // 2. Pattern-based (logs, ores)
                    else if (itemName.endsWith(" ore")) {
                        const nameParts = itemName.toLowerCase().split(" ");
                        const baseNameFromParts = nameParts[0]; // Use this for emoji logic if needed
                        if (ORE_DATA[baseNameFromParts]) {
                            emoji = ORE_DATA[baseNameFromParts].emoji || "&nbsp;";
                            itemColorClass = ORE_DATA[baseNameFromParts].color || "fore-white";
                        }
                    } else if (itemName.endsWith(" logs")) {
                        const nameParts = itemName.toLowerCase().split(" ");
                        const baseNameFromParts = nameParts[0];
                        if (TREE_DATA[baseNameFromParts]) {
                            emoji = TREE_DATA[baseNameFromParts].emoji || "&nbsp;";
                            itemColorClass = TREE_DATA[baseNameFromParts].color || "fore-green";
                        }
                    }
                    // 3. Food data
                    else if (FOOD_DATA[itemName]) {
                        emoji = FOOD_DATA[itemName].emoji || "&nbsp;";
                        itemColorClass = FOOD_DATA[itemName].color || "fore-green";
                    }
                    // 4. Cookable items (raw forms)
                    else if (COOKABLE_ITEMS[itemName.replace(/s$/, '')]) {
                        const cookableBase = itemName.replace(/s$/, '');
                        if (COOKABLE_ITEMS[cookableBase]) {
                             emoji = COOKABLE_ITEMS[cookableBase].emoji || "&nbsp;";
                             itemColorClass = COOKABLE_ITEMS[cookableBase].color || "fore-white";
                        }
                    }
                    // 5. Bar data
                    else if (BAR_DATA[itemName]) {
                        emoji = BAR_DATA[itemName].emoji || "&nbsp;";
                        itemColorClass = BAR_DATA[itemName].color || "fore-white";
                    }
                    // 6. Unequipped tools (inventory key is the material, e.g., "bronze")
                    else if (TOOL_DATA.axe[itemName]) { // itemName is "bronze", "iron" etc.
                        const toolData = TOOL_DATA.axe[itemName];
                        emoji = toolData.emoji || "&nbsp;";
                        displayItemName = titleCase(itemName + " Axe");
                        itemColorClass = toolData.color || "fore-white";
                    } else if (TOOL_DATA.pickaxe[itemName]) { // itemName is "bronze", "iron" etc.
                        const toolData = TOOL_DATA.pickaxe[itemName];
                        emoji = toolData.emoji || "&nbsp;";
                        displayItemName = titleCase(itemName + " Pickaxe");
                        itemColorClass = toolData.color || "fore-white";
                    }

                    // 7. Default fallback emoji if still not found
                    if (emoji === "&nbsp;") {
                        emoji = `<span class='${itemColorClass}'>●</span>`;
                    }

                    // Final override for burnt meat color for its text, if needed
                    if (itemName === "burnt meat") {
                        itemColorClass = "fore-dark-grey";
                    }

                    itemDiv.innerHTML = `<span class="inv-item-emoji">${emoji}</span><span class="item-name ${itemColorClass}">${displayItemName}:</span> <span class="item-quantity">${quantity.toLocaleString()}</span>`;
                    listDiv.appendChild(itemDiv);
                }
            }
            if (!hasItems) listDiv.innerHTML = "<p>Your inventory is empty.</p>";
        }


        function populateEquipmentDisplay() {
            const weaponKey = playerData.inventory.weapon;
            const weaponName = weaponKey === "none" ? "None" : titleCase(weaponKey);
            const weaponData = SWORD_DATA[weaponKey];
            const weaponColorClass = weaponData ? weaponData.color : 'fore-white';
            const weaponArt = weaponData ? (weaponData.emoji || "") : "";
            let weaponStatsDisplay = "";

            if (weaponData) {
                let minDmg = weaponData.min_dmg;
                let maxDmg = weaponData.max_dmg;

                // Apply Weapon Master I perk if active
                if (isPerkActive("weaponMaster1")) {
                    minDmg = Math.floor(minDmg * (1 + PERK_DATA.weaponMaster1.value));
                    maxDmg = Math.floor(maxDmg * (1 + PERK_DATA.weaponMaster1.value));
                }
                // Apply Stronghold global damage boost
                if (playerData.built_structures.stronghold) {
                    const strongholdDmgPerk = STRUCTURE_DATA.stronghold.perks.find(p => p.type === "global_damage_boost");
                    if (strongholdDmgPerk) {
                        minDmg = Math.floor(minDmg * (1 + strongholdDmgPerk.value));
                        maxDmg = Math.floor(maxDmg * (1 + strongholdDmgPerk.value));
                    }
                }
                weaponStatsDisplay += `(Dmg: ${minDmg}-${maxDmg}`;
                if (isPerkActive("weaponMaster1") || playerData.built_structures.stronghold) {
                     weaponStatsDisplay += "*"; // Indicate boosted damage
                }
                 weaponStatsDisplay += ")";


                let effectiveLifestealChance = weaponData.lifesteal_chance || 0;
                if (isPerkActive("vampiricEdge1")) {
                    effectiveLifestealChance += PERK_DATA.vampiricEdge1.value;
                }
                if (effectiveLifestealChance > 0) {
                    const lsAmount = Array.isArray(weaponData.lifesteal_amount) ? `${weaponData.lifesteal_amount[0]}-${weaponData.lifesteal_amount[1]}` : weaponData.lifesteal_amount;
                    weaponStatsDisplay += ` (LS: ${(effectiveLifestealChance * 100).toFixed(0)}% for ${lsAmount} HP)`;
                }
            }

            document.getElementById('eq-weapon-name').innerHTML = `<span class="${weaponColorClass}">${weaponName}</span>`;
            document.getElementById('eq-weapon-stats').textContent = weaponStatsDisplay.trim();
            document.getElementById('eq-weapon-art').innerHTML = weaponArt; // Use innerHTML for emojis with spans

            const axeKey = playerData.inventory.axe;
            const axeName = axeKey === "none" ? "None" : titleCase(axeKey);
            const axeData = TOOL_DATA.axe[axeKey];
            const axeColorClass = axeData ? axeData.color : 'fore-white';
            const axeArt = axeData ? (axeData.emoji || "") : "";
            document.getElementById('eq-axe-name').innerHTML = `<span class="${axeColorClass}">${axeName}</span>`;
            document.getElementById('eq-axe-art').innerHTML = axeArt;

            const pickaxeKey = playerData.inventory.pickaxe;
            const pickaxeName = pickaxeKey === "none" ? "None" : titleCase(pickaxeKey);
            const pickaxeData = TOOL_DATA.pickaxe[pickaxeKey];
            const pickaxeColorClass = pickaxeData ? pickaxeData.color : 'fore-white';
            const pickaxeArt = pickaxeData ? (pickaxeData.emoji || "") : "";
            document.getElementById('eq-pickaxe-name').innerHTML = `<span class="${pickaxeColorClass}">${pickaxeName}</span>`;
            document.getElementById('eq-pickaxe-art').innerHTML = pickaxeArt;

            const chestplateKey = playerData.inventory.chestplate;
            const chestplateName = chestplateKey === "none" ? "None" : titleCase(chestplateKey);
            const armorData = ARMOR_DATA[chestplateKey];
            const chestplateColorClass = armorData ? armorData.color : 'fore-white';
            const chestplateArt = armorData ? (armorData.emoji || "") : "";
            let defenseDisplay = "";
            if (armorData && armorData.defense) {
                defenseDisplay = ` (-${(armorData.defense * 100).toFixed(0)}% Mob Hit)`
            }
            document.getElementById('eq-chestplate-name').innerHTML = `<span class="${chestplateColorClass}">${chestplateName}</span> <span class="fore-cyan">${defenseDisplay}</span>`;
            document.getElementById('eq-chestplate-art').innerHTML = chestplateArt;
        }

        function showEquipSelection(slot) {
            const listDiv = document.getElementById('equip-item-list');
            listDiv.innerHTML = '';
            document.getElementById('equip-item-type-title').textContent = `Equip ${titleCase(slot)}`;
            let foundItems = false;

            for (const itemName in playerData.inventory) {
                if (playerData.inventory[itemName] > 0 || typeof playerData.inventory[itemName] === 'string') { // Check for items in inv or if it's an equipped string
                    let itemData;
                    let matchesSlot = false;

                    if (slot === 'weapon' && SWORD_DATA[itemName]) { itemData = SWORD_DATA[itemName]; matchesSlot = true; }
                    else if (slot === 'axe' && TOOL_DATA.axe[itemName]) { itemData = TOOL_DATA.axe[itemName]; matchesSlot = true; }
                    else if (slot === 'pickaxe' && TOOL_DATA.pickaxe[itemName]) { itemData = TOOL_DATA.pickaxe[itemName]; matchesSlot = true; }
                    else if (slot === 'chestplate' && ARMOR_DATA[itemName]) { itemData = ARMOR_DATA[itemName]; matchesSlot = true; }

                    if (matchesSlot && (playerData.inventory[itemName] > 0 || playerData.inventory[slot] === itemName)) { // Item is in inventory OR is the currently equipped one
                        // We only care about items that are *in the inventory stacks* for equipping, not the slot itself.
                        if (typeof playerData.inventory[itemName] === 'number' && playerData.inventory[itemName] > 0) {
                            foundItems = true;
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'inv-item-equip item';
                            itemDiv.innerHTML = `${itemData.emoji || ''} ${titleCase(itemName)}`;
                            itemDiv.onclick = () => equipItem(slot, itemName);
                            listDiv.appendChild(itemDiv);
                        }
                    }
                }
            }

            if (!foundItems) {
                listDiv.innerHTML = `<p>No ${slot}s in your inventory to equip.</p>`;
            }
            document.getElementById('item-selection-for-equip').classList.remove('hidden');
        }

        function hideEquipSelection() {
            document.getElementById('item-selection-for-equip').classList.add('hidden');
        }

        function equipItem(slot, itemName) {
            // Unequip old item (if any and it's not "none") and add to inventory
            const oldItem = playerData.inventory[slot];
            if (oldItem !== "none" && oldItem !== itemName) { // Don't add if it's the same item or "none"
                playerData.inventory[oldItem] = (playerData.inventory[oldItem] || 0) + 1;
            }

            playerData.inventory[slot] = itemName; // Equip new item
            if (typeof playerData.inventory[itemName] === 'number') { // If it was from a stack
                playerData.inventory[itemName]--; // Decrement from inventory stack
            }

            logMessage(`Equipped ${titleCase(itemName)} to ${slot} slot.`, "fore-green");
            savePlayerData();
            updateHud();
            populateEquipmentDisplay();
            populateInventoryDisplay(); // Refresh inventory list
            hideEquipSelection();
        }

        function showShopMenu() { 
            document.getElementById('shop-gold-display').textContent = `Your Gold: ${playerData.gold.toLocaleString()}`;
            showSection('shop-menu-section');
        }

        // --- Inventory & Equipment (Existing - no major changes needed for structures here) ---
        // ... (populateInventoryDisplay, populateEquipmentDisplay, showEquipSelection, hideEquipSelection, equipItem, unequipItem)

        // --- Shop Logic (Existing - modified for Castle perk) ---
        function showBuyMenu() {
            stopAllAutoActions();
            // Default to showing axes, or clear if no default desired
            populateShopItems('axe', 'Axes'); // Or clear #shop-items-list
            showSection('buy-menu-section');
        }

        function populateShopItems(categoryKey, categoryName) {
            const listDiv = document.getElementById('shop-items-list');
            listDiv.innerHTML = `<div class="section-title">Buying: ${categoryName}</div>`;
            const sourceData = TOOL_DATA[categoryKey] || ARMOR_DATA; // ARMOR_DATA is flat, TOOL_DATA is nested

            let itemsAvailable = false;
            for (const itemName in sourceData) {
                if (categoryKey === 'axe' && itemName === 'fists') continue; // Skip fists for axes
                if (categoryKey === 'chestplate' && !ARMOR_DATA[itemName]) continue; // Ensure we only list armor for chestplate
                if (categoryKey !== 'chestplate' && (!TOOL_DATA[categoryKey] || !TOOL_DATA[categoryKey][itemName])) continue;

                const item = sourceData[itemName];
                itemsAvailable = true;
                const itemDiv = document.createElement('div');
                itemDiv.id = `shop-item-buy-${categoryKey}-${itemName.replace(/\s+/g, '-')}`; // Add unique ID
                itemDiv.className = 'shop-item item';

                let actualPrice = item.price;
                if (playerData.built_structures.castle && STRUCTURE_DATA.castle.perk_effect.type === "shop_price_modifier") { // Check perk type
                    actualPrice *= (1 + STRUCTURE_DATA.castle.perk_effect.buy_mod);
                    actualPrice = Math.max(1, Math.floor(actualPrice));
                }


                const displayName = (categoryKey === 'axe' || categoryKey === 'pickaxe') ? titleCase(itemName + " " + categoryKey) : titleCase(itemName);
                const itemDisplayColorClass = item.color || 'fore-white'; // Get color from item data or default
                itemDiv.innerHTML = `${item.emoji || ''} <span class="${itemDisplayColorClass}">${displayName}</span> <span class="price">${actualPrice}g</span>
                                     <br><small class="req">Req Lvl: ${item.level_req} ${titleCase(item.skill_type || categoryKey)}</small>`;
                itemDiv.onclick = () => buyItem(categoryKey, itemName);
                listDiv.appendChild(itemDiv);
            }
            if (!itemsAvailable) listDiv.innerHTML += "<p>No items in this category.</p>";
        }

        // MODIFIED for Castle Perk
        function buyItem(categoryKey, itemName) { 
            const sourceData = TOOL_DATA[categoryKey]; 
            const itemToBuy = sourceData[itemName];

            const skillType = itemToBuy.skill_type;
            const playerSkillLevel = getLevelFromXp(playerData[`${skillType}_xp`] || 0);
            if (playerSkillLevel < itemToBuy.level_req) {
                logMessage(`Your ${titleCase(skillType)} Lvl (${playerSkillLevel}) is too low for ${titleCase(itemName)} (Req: ${itemToBuy.level_req}).`, "fore-red");
                return;
            }

            let actualPrice = itemToBuy.price;
            if (playerData.built_structures.castle && STRUCTURE_DATA.castle.perk_effect.type === "shop_price_modifier") { // Check perk type
                actualPrice *= (1 + STRUCTURE_DATA.castle.perk_effect.buy_mod);
                actualPrice = Math.max(1, Math.floor(actualPrice));
            }

            if (playerData.gold < actualPrice) {
                logMessage(`Not enough gold. Need ${actualPrice}g, have ${playerData.gold.toLocaleString()}g.`, "fore-red");
                return;
            }
            
            const currentlyEquippedInSlot = playerData.inventory[categoryKey];
            if (currentlyEquippedInSlot === itemName) {
                logMessage(`You already have ${titleCase(itemName)} equipped. Purchase not made.`, "fore-yellow");
                return;
            }

            playerData.gold -= actualPrice;
            
            const oldEquippedItemName = playerData.inventory[categoryKey]; 
            if (oldEquippedItemName && oldEquippedItemName !== "none") {
                if (sourceData[oldEquippedItemName]) { 
                    playerData.inventory[oldEquippedItemName] = (playerData.inventory[oldEquippedItemName] || 0) + 1;
                    logMessage(`Unequipped ${titleCase(oldEquippedItemName)} and moved to inventory.`, "fore-yellow");
                }
            }
            playerData.inventory[categoryKey] = itemName; 
            
            logMessage(`Bought and equipped ${titleCase(itemName)} for ${actualPrice}g!`, "fore-green");
            savePlayerData();
            updateHud();
            populateEquipmentDisplay(); 
            populateInventoryDisplay();
            document.getElementById('shop-gold-display').textContent = `Your Gold: ${playerData.gold.toLocaleString()}`; 
        }

        function showSellMenu() {
            stopAllAutoActions();
            populateSellableItemsList();
            showSection('sell-menu-section');
        }

        function populateSellableItemsList() {
            const listDiv = document.getElementById('sellable-items-list');
            listDiv.innerHTML = '<div class="section-title">Your Sellable Items</div>';
            let hasSellable = false;
            
            for (const inventoryKey in playerData.inventory) {
                const quantity = playerData.inventory[inventoryKey];
                const isEquippableSlot = ["weapon", "axe", "pickaxe", "chestplate"].includes(inventoryKey);

                // Skip equipped slots and items with 0 quantity or non-numeric quantity (like equipped item names)
                if (isEquippableSlot || typeof quantity !== 'number' || quantity <= 0) {
                    continue;
                }

                let emoji = "&nbsp;";
                let itemColorClass = "fore-white";
                let displayFullName = titleCase(inventoryKey); // Default display name
                let priceLookupKey = inventoryKey;          // Default key for ITEM_SELL_PRICES

                // Handle tools that are stored by material name in inventory (e.g., "bronze" for bronze axe)
                // These are typically unequipped tools.
                if (TOOL_DATA.axe[inventoryKey]) {
                    const toolData = TOOL_DATA.axe[inventoryKey];
                    displayFullName = titleCase(inventoryKey + " axe");
                    priceLookupKey = inventoryKey + " axe"; // ITEM_SELL_PRICES uses "bronze axe", etc.
                    emoji = toolData.emoji || "&nbsp;";
                    itemColorClass = toolData.color || "fore-white";
                } else if (TOOL_DATA.pickaxe[inventoryKey]) {
                    const toolData = TOOL_DATA.pickaxe[inventoryKey];
                    displayFullName = titleCase(inventoryKey + " pickaxe");
                    priceLookupKey = inventoryKey + " pickaxe";
                    emoji = toolData.emoji || "&nbsp;";
                    itemColorClass = toolData.color || "fore-white";
                }
                // Handle other item types by their direct inventoryKey
                else if (FOOD_DATA[inventoryKey]) {
                    emoji = FOOD_DATA[inventoryKey].emoji || "&nbsp;";
                    itemColorClass = FOOD_DATA[inventoryKey].color || "fore-green";
                } else if (COOKABLE_ITEMS[inventoryKey.replace(/s$/, '')]) { // Handle plural "raw meats" if needed
                    const cookableBase = inventoryKey.replace(/s$/, '');
                    emoji = COOKABLE_ITEMS[cookableBase].emoji || "&nbsp;";
                    itemColorClass = COOKABLE_ITEMS[cookableBase].color || "fore-white";
                } else if (BAR_DATA[inventoryKey]) {
                    emoji = BAR_DATA[inventoryKey].emoji || "&nbsp;";
                    itemColorClass = BAR_DATA[inventoryKey].color || "fore-white";
                } else if (SWORD_DATA[inventoryKey]) { // Swords are stored by full name, e.g., "bronze 2h sword"
                    emoji = SWORD_DATA[inventoryKey].emoji || "&nbsp;";
                    itemColorClass = SWORD_DATA[inventoryKey].color || "fore-white";
                } else if (ARMOR_DATA[inventoryKey]) { // Armor is stored by full name, e.g., "bronze chestplate"
                    emoji = ARMOR_DATA[inventoryKey].emoji || "&nbsp;";
                    itemColorClass = ARMOR_DATA[inventoryKey].color || "fore-white";
                } else { // Generic items like logs, ores, misc drops
                    const nameParts = inventoryKey.toLowerCase().split(" ");
                    const baseName = nameParts[0];

                    if (inventoryKey.endsWith(" ore") && ORE_DATA[baseName]) {
                        emoji = ORE_DATA[baseName].emoji || "&nbsp;";
                        itemColorClass = ORE_DATA[baseName].color || "fore-white";
                    } else if (inventoryKey.endsWith(" logs") && TREE_DATA[baseName]) {
                        emoji = TREE_DATA[baseName].emoji || "&nbsp;";
                        itemColorClass = TREE_DATA[baseName].color || "fore-green"; // Default for logs
                    }
                    else if (inventoryKey === "egg") {
                        emoji = "🥚";
                    } else if (inventoryKey === "goblin beads") {
                        emoji = "📿";
                    } else if (inventoryKey === "dragon gem") {
                        emoji = "<span class='fore-red'>💎</span>";
                    } else if (inventoryKey === "demon heart") {
                        emoji = "<span class='fore-magenta'>❤️‍🔥</span>";
                    } else if (inventoryKey === "burnt meat") { // Explicitly set emoji for burnt meat in shop
                        emoji = " ◍ ";
                        itemColorClass = "fore-dark-grey";
                    } else if (emoji === "&nbsp;") { // Default emoji if still not found for other generic items
                        emoji = `<span class='${itemColorClass}'>●</span>`;
                    }
                }

                // Determine sell price
                let baseSellPrice = ITEM_SELL_PRICES[priceLookupKey];
                if (typeof baseSellPrice === 'undefined') {
                    baseSellPrice = 1; // Default sell price for items not explicitly priced
                }

                let actualSellPrice = baseSellPrice;
                if (playerData.built_structures.castle && typeof actualSellPrice === 'number' && STRUCTURE_DATA.castle.perk_effect.type === "shop_price_modifier") {
                    actualSellPrice *= (1 + STRUCTURE_DATA.castle.perk_effect.sell_mod);
                    actualSellPrice = Math.floor(actualSellPrice);
                }

                if (actualSellPrice < 0) { // Don't list items that would sell for negative gold
                    continue;
                }

                hasSellable = true;
                const itemDiv = document.createElement('div');
                itemDiv.className = 'shop-item item'; // Using shop-item for consistency

                // Mimic inventory display structure for consistency
                itemDiv.innerHTML = `<span class="inv-item-emoji">${emoji}</span><span class="item-name ${itemColorClass}">${displayFullName}:</span> <span class="item-quantity">${quantity.toLocaleString()}</span> <span class="price">${actualSellPrice}g each</span>`;
                itemDiv.onclick = () => sellItem(inventoryKey, quantity, baseSellPrice); // Pass original inventoryKey and baseSellPrice
                listDiv.appendChild(itemDiv);
            }

            if (!hasSellable) listDiv.innerHTML += "<p>You have no items to sell (or they are worthless).</p>";
        }

        // MODIFIED for Castle Perk
        function sellItem(itemName, currentQuantity, pricePerItem) { // pricePerItem is base price
            const amountToSell = parseInt(prompt(`How many ${titleCase(itemName)} to sell? (Max ${currentQuantity})`, currentQuantity));
            if (isNaN(amountToSell) || amountToSell <= 0) {
                logMessage("Invalid amount.", "fore-red");
                return;
            }
            if (amountToSell > currentQuantity) {
                logMessage("You don't have that many to sell.", "fore-red");
                return;
            }

            let actualSellPricePerItem = pricePerItem;
            if (playerData.built_structures.castle && actualSellPricePerItem && STRUCTURE_DATA.castle.perk_effect.type === "shop_price_modifier") { // Check perk type
                actualSellPricePerItem *= (1 + STRUCTURE_DATA.castle.perk_effect.sell_mod);
                actualSellPricePerItem = Math.floor(actualSellPricePerItem);
            }

            playerData.inventory[itemName] -= amountToSell;
            const goldEarned = amountToSell * actualSellPricePerItem;
            playerData.gold += goldEarned;

            logMessage(`Sold ${amountToSell} ${titleCase(itemName)} for ${goldEarned} gold (${actualSellPricePerItem}g each).`, "fore-yellow");
            playSound(sellItemSound); 
            savePlayerData();
            updateHud();
            populateSellableItemsList(); // Just refresh the list, don't change section
            populateInventoryDisplay(); 
            document.getElementById('shop-gold-display').textContent = `Your Gold: ${playerData.gold.toLocaleString()}`;
        }


        // --- Action: Woodcutting (Modified for Camp Perk and new interaction) ---
        function showWoodcutting() {
            stopAllAutoActions(); 
            const treeListDiv = document.getElementById('available-trees');
            treeListDiv.innerHTML = '<div class="section-title">Available Trees</div>';
            currentWoodcuttingTarget = null; // Clear target when re-entering screen unless auto-action restarts

            const wcLvl = getLevelFromXp(playerData.woodcutting_xp);
            const equippedAxeName = playerData.inventory.axe;
            const equippedAxeData = TOOL_DATA.axe[equippedAxeName] || TOOL_DATA.axe.fists;
            const equippedAxeTierIndex = AXE_TIER_ORDER.indexOf(equippedAxeData.tier);

            let available = false;
            for (const treeName in TREE_DATA) {
                const tree = TREE_DATA[treeName];
                if (wcLvl >= tree.level) {
                    available = true;
                    const treeDiv = document.createElement('div');
                    treeDiv.className = 'skill-resource fore-green';
                    let treeDisplayText = `${tree.emoji} ${titleCase(treeName)} (Lvl: ${tree.level}, XP per log: ${tree.exp})`;
                    let canChopThisTree = true;

                    if (tree.required_axe_tier) {
                        const requiredTierIndex = AXE_TIER_ORDER.indexOf(tree.required_axe_tier);
                        if (equippedAxeTierIndex < requiredTierIndex) {
                            treeDisplayText += ` <span class="fore-red">(Req: ${titleCase(tree.required_axe_tier)} Axe)</span>`;
                            treeDiv.style.opacity = "0.6";
                            treeDiv.style.cursor = "not-allowed";
                            treeDiv.title = `Requires a ${titleCase(tree.required_axe_tier)} Axe or better.`;
                            canChopThisTree = false;
                        }
                    }
                    // Updated display to match mining style
                    treeDiv.innerHTML = `
                        <span class="resource-main-text">${treeDisplayText}</span>
                        <span class="resource-inventory-count" id="inv-count-wc-${treeName.replace(/\s+/g, '-')}">${playerData.inventory[tree.log] || 0}</span>`;
                    treeDiv.id = `tree-list-item-${treeName.replace(/\s+/g, '-')}`;
                    if (isAutoWoodcutting && currentWoodcuttingTarget === treeName) {
                        treeDiv.classList.add('active-woodcutting-item');
                    }
                    if (canChopThisTree) treeDiv.onclick = () => selectTreeForWoodcutting(treeName);
                    treeListDiv.appendChild(treeDiv);
                }
            }
            if (!available) treeListDiv.innerHTML += "<p>No trees available at your level.</p>";
            showSection('woodcutting-section');
        }
        
        function selectTreeForWoodcutting(treeName) {
            if (isAutoWoodcutting && currentWoodcuttingTarget === treeName) {
                stopAutoWoodcutting();
            } else {
                if (isAutoWoodcutting) { 
                    stopAutoWoodcutting();
                }
                startAutoWoodcutting(treeName);
            }
        }

        function startAutoWoodcutting(treeName) {
            if (!treeName) { logMessage("No tree selected.", "fore-red"); return false; }
            document.querySelectorAll('.active-woodcutting-item').forEach(el => el.classList.remove('active-woodcutting-item'));
            currentWoodcuttingTarget = treeName; 

            const equippedAxeName = playerData.inventory.axe;
            if (equippedAxeName === "none") { logMessage("You need an axe to chop wood.", "fore-red"); currentWoodcuttingTarget=null; return; }
            
            const axeProps = TOOL_DATA.axe[equippedAxeName];
            if (!axeProps) { logMessage("Error: Equipped axe data not found.", "fore-red"); stopAutoWoodcutting(); currentWoodcuttingTarget=null; return; }
            
            const currentWcLvl = getLevelFromXp(playerData.woodcutting_xp);
            if (currentWcLvl < axeProps.level_req) {
                logMessage(`Woodcutting Lvl (${currentWcLvl}) too low for ${titleCase(equippedAxeName)}. Req: ${axeProps.level_req}`, "fore-red");
                currentWoodcuttingTarget = null; 
                return false;
            }

            const treeData = TREE_DATA[treeName];
            if (treeData.required_axe_tier) {
                const equippedAxeTierIndex = AXE_TIER_ORDER.indexOf(axeProps.tier);
                const requiredTierIndex = AXE_TIER_ORDER.indexOf(treeData.required_axe_tier);
                if (equippedAxeTierIndex < requiredTierIndex) {
                    logMessage(`Your ${titleCase(equippedAxeName)} is not strong enough for ${titleCase(treeName)}. Requires a ${titleCase(treeData.required_axe_tier)} Axe or better.`, "fore-red");
                    currentWoodcuttingTarget = null;
                    return false;
                }
            }

            isAutoWoodcutting = true;
            const treeListItem = document.getElementById(`tree-list-item-${currentWoodcuttingTarget.replace(/\s+/g, '-')}`);
            if (treeListItem) treeListItem.classList.add('active-woodcutting-item');

            logMessage(`Auto-chopping ${titleCase(currentWoodcuttingTarget)}...`, "fore-cyan");

            let interval = BASE_GATHER_INTERVAL;
            if(isPerkActive("efficientGatherer1")) interval *= (1 - PERK_DATA.efficientGatherer1.value);
            if (playerData.built_structures.stronghold) {
                const speedPerk = STRUCTURE_DATA.stronghold.perks.find(p => p.type === "global_skill_speed_boost");
                if (speedPerk) interval *= (1 - speedPerk.value);
            }
            autoWoodcuttingInterval = setInterval(singleChopAction, interval);
            return true;
        }

        function stopAutoWoodcutting() {
            if (isAutoWoodcutting) {
                isAutoWoodcutting = false;
                clearInterval(autoWoodcuttingInterval);
                autoWoodcuttingInterval = null;
                if (currentWoodcuttingTarget) {
                    const treeListItem = document.getElementById(`tree-list-item-${currentWoodcuttingTarget.replace(/\s+/g, '-')}`);
                    if (treeListItem) treeListItem.classList.remove('active-woodcutting-item');
                }
                logMessage("Auto-chopping stopped.", "fore-yellow");
            }
        }
        
        function singleChopAction() {
            if (!isAutoWoodcutting || !currentWoodcuttingTarget) { stopAutoWoodcutting(); return; }
            const equippedAxeName = playerData.inventory.axe; 
            if (equippedAxeName === "none") { logMessage("No axe equipped. Stopping.", "fore-red"); stopAutoWoodcutting(); return; }
            
            const axeProps = TOOL_DATA.axe[equippedAxeName];
            if (!axeProps || !axeProps.yield_config) { logMessage("Error with axe data.", "fore-red"); stopAutoWoodcutting(); return; }

            const treeData = TREE_DATA[currentWoodcuttingTarget]; 
            const oldLevel = getLevelFromXp(playerData.woodcutting_xp);
            
            let baseYieldBonus = 0;
            if (playerData.built_structures.camp && STRUCTURE_DATA.camp.perk_effect.type === "base_gather_yield_bonus" && Math.random() < STRUCTURE_DATA.camp.perk_effect.value) {
                baseYieldBonus = 1; 
            }

            let logsGained = axeProps.yield_config.base + baseYieldBonus;
            // Use tree-specific bonuses
            const treeTypeKey = currentWoodcuttingTarget; // "normal", "oak", "willow"
            const treeSpecificBonuses = axeProps.yield_config.bonuses_by_tree ? axeProps.yield_config.bonuses_by_tree[treeTypeKey] || [] : [];

            if (treeSpecificBonuses.length > 0) {
                treeSpecificBonuses.forEach(bonus => {
                    if (Math.random() < bonus.chance) logsGained += bonus.amount;
                });
            }
            if (logsGained < 0) logsGained = 0;

            let xpPerLog = treeData.exp; 
            let totalXpGainedThisAction = 0;

            if (logsGained > 0) {
                playerData.inventory[treeData.log] = (playerData.inventory[treeData.log] || 0) + logsGained;
                totalXpGainedThisAction = logsGained * xpPerLog;

                let logMsg = `Got ${logsGained} ${titleCase(treeData.log)}.`;
                if (baseYieldBonus > 0) logMsg += " (Camp bonus!)";
                
                let displayXpGained = totalXpGainedThisAction;
                if (playerData.built_structures.house) {
                    const houseXpPerk = STRUCTURE_DATA.house.perks.find(p => p.type === "global_xp_boost");
                    if (houseXpPerk) {
                        displayXpGained *= (1 + houseXpPerk.value);
                    }
                }
                displayXpGained = Math.floor(displayXpGained);

                logMessage(`+${displayXpGained} WC XP. ${logMsg}`, "fore-green");
                
                playerData.woodcutting_xp += displayXpGained;
                grantUniversalXP(totalXpGainedThisAction); 
                
            } else {
                 logMessage(`Got no logs this time. (+0 WC XP)`, "fore-yellow");
            }
            
            playSound(skillRoundSound); 
            handleLevelUp("woodcutting_xp", oldLevel);
            savePlayerData();
            updateHud();
            // Update inventory count display for the current tree
            const countSpan = document.getElementById(`inv-count-wc-${currentWoodcuttingTarget.replace(/\s+/g, '-')}`);
            if (countSpan) {
                countSpan.textContent = playerData.inventory[treeData.log] || 0;
            }

        }


        // --- Action: Mining (Modified for Camp Perk and new interaction) ---
        function showMining() {
            stopAllAutoActions();
            const oreListDiv = document.getElementById('available-ores');
            oreListDiv.innerHTML = '<div class="section-title">Available Ores</div>';
            currentMiningTarget = null;

            const equippedPickaxeName = playerData.inventory.pickaxe;
            const equippedPickaxeData = TOOL_DATA.pickaxe[equippedPickaxeName] || null; // No "fists" for pickaxe
            const equippedPickaxeTierIndex = equippedPickaxeData ? PICKAXE_TIER_ORDER.indexOf(equippedPickaxeData.tier) : -1;

            const mnLvl = getLevelFromXp(playerData.mining_xp);
            let available = false;
            for (const oreName in ORE_DATA) {
                const ore = ORE_DATA[oreName];
                if (mnLvl >= ore.level_req) {
                    available = true;
                    let canMineThisOre = true;
                    let oreDisplayText = `${ore.emoji} ${titleCase(oreName)} (Lvl: ${ore.level_req}, XP per ore: ${ore.xp})`;

                    if (ore.required_pickaxe_tier) {
                        if (!equippedPickaxeData) { // No pickaxe equipped
                            oreDisplayText += ` <span class="fore-red">(Req: ${titleCase(ore.required_pickaxe_tier)} Pickaxe)</span>`;
                            canMineThisOre = false;
                        } else {
                            const requiredTierIndex = PICKAXE_TIER_ORDER.indexOf(ore.required_pickaxe_tier);
                            if (equippedPickaxeTierIndex < requiredTierIndex) {
                                oreDisplayText += ` <span class="fore-red">(Req: ${titleCase(ore.required_pickaxe_tier)} Pickaxe)</span>`;
                                canMineThisOre = false;
                            }
                        }
                    }

                    const oreDiv = document.createElement('div');
                    oreDiv.className = `skill-resource ${ore.color}`;
                    oreDiv.innerHTML = `
                        <span class="resource-main-text">${oreDisplayText}</span>
                        <span class="resource-inventory-count" id="inv-count-mn-${oreName.replace(/\s+/g, '-')}">${playerData.inventory[ore.item_name] || 0}</span>
                    `;
                    oreDiv.id = `ore-list-item-${oreName.replace(/\s+/g, '-')}`;
                     if (isAutoMining && currentMiningTarget === oreName) {
                        oreDiv.classList.add('active-mining-item');
                    }
                    if (canMineThisOre) {
                        oreDiv.onclick = () => selectOreForMining(oreName);
                    } else {
                        oreDiv.style.opacity = "0.6";
                        oreDiv.style.cursor = "not-allowed";
                        oreDiv.title = `Requires a ${titleCase(ore.required_pickaxe_tier || 'better')} Pickaxe.`;
                    }
                    oreListDiv.appendChild(oreDiv);
                }
            }
            if (!available) oreListDiv.innerHTML += "<p>No ores available at your level.</p>";
            showSection('mining-section');
        }

        function selectOreForMining(oreName) {
            if (isAutoMining && currentMiningTarget === oreName) {
                stopAutoMining();
            } else {
                if (isAutoMining) {
                    stopAutoMining();
                }
                startAutoMining(oreName);
            }
        }

        function startAutoMining(oreName) {
            if (!oreName) { logMessage("No ore selected.", "fore-red"); return false; }
            document.querySelectorAll('.active-mining-item').forEach(el => el.classList.remove('active-mining-item'));
            currentMiningTarget = oreName;

            const equippedPickaxeName = playerData.inventory.pickaxe;
            if (equippedPickaxeName === "none") { logMessage("You need a pickaxe to mine.", "fore-red"); currentMiningTarget = null; return; }
            
            const pickaxeProps = TOOL_DATA.pickaxe[equippedPickaxeName];
            if (!pickaxeProps) { logMessage("Error: Pickaxe data missing.", "fore-red"); stopAutoMining(); currentMiningTarget = null; return; }
            
            const currentMnLvl = getLevelFromXp(playerData.mining_xp);
            if (currentMnLvl < pickaxeProps.level_req) {
                logMessage(`Mining Lvl (${currentMnLvl}) too low for ${titleCase(equippedPickaxeName)}. Req: ${pickaxeProps.level_req}`, "fore-red");
                currentMiningTarget = null;
                return false;
            }

            const oreData = ORE_DATA[currentMiningTarget];
            if (oreData.required_pickaxe_tier) {
                const equippedPickaxeTierIndex = PICKAXE_TIER_ORDER.indexOf(pickaxeProps.tier);
                const requiredTierIndex = PICKAXE_TIER_ORDER.indexOf(oreData.required_pickaxe_tier);
                if (equippedPickaxeTierIndex < requiredTierIndex) {
                    logMessage(`Your ${titleCase(equippedPickaxeName)} is not strong enough for ${titleCase(currentMiningTarget)}. Requires a ${titleCase(oreData.required_pickaxe_tier)} Pickaxe or better.`, "fore-red");
                    // Also remove active class if it was somehow set
                    const oreListElementId = `ore-list-item-${currentMiningTarget.replace(/\s+/g, '-')}`; // Use currentMiningTarget before nulling
                    const oreListItem = document.getElementById(oreListElementId);
                    if (oreListItem) oreListItem.classList.remove('active-mining-item');
                    currentMiningTarget = null; // Null it after using it
                    return false;
                }
            }

            isAutoMining = true;
            const oreListItem = document.getElementById(`ore-list-item-${currentMiningTarget.replace(/\s+/g, '-')}`);
            if (oreListItem) oreListItem.classList.add('active-mining-item');
            logMessage(`Auto-mining ${titleCase(currentMiningTarget)}...`, "fore-cyan");
            
            let interval = BASE_GATHER_INTERVAL;
            if(isPerkActive("efficientGatherer1")) interval *= (1 - PERK_DATA.efficientGatherer1.value);
            if (playerData.built_structures.stronghold) {
                const speedPerk = STRUCTURE_DATA.stronghold.perks.find(p => p.type === "global_skill_speed_boost");
                if (speedPerk) interval *= (1 - speedPerk.value);
            }
            autoMiningInterval = setInterval(singleMineAction, interval);
            return true;
        }

        function stopAutoMining() {
            if (isAutoMining) {
                isAutoMining = false;
                clearInterval(autoMiningInterval);
                autoMiningInterval = null;
                if (currentMiningTarget) {
                    const oreListItem = document.getElementById(`ore-list-item-${currentMiningTarget.replace(/\s+/g, '-')}`);
                    if (oreListItem) oreListItem.classList.remove('active-mining-item');
                }
                logMessage("Auto-mining stopped.", "fore-yellow");
            }
        }

        function singleMineAction() {
            if (!isAutoMining || !currentMiningTarget) { stopAutoMining(); return; }
            const equippedPickaxeName = playerData.inventory.pickaxe;
            if (equippedPickaxeName === "none") { logMessage("No pickaxe. Stopping.", "fore-red"); stopAutoMining(); return; }
            
            const pickaxeProps = TOOL_DATA.pickaxe[equippedPickaxeName];
            if (!pickaxeProps || !pickaxeProps.yield_config) { logMessage("Error with pickaxe data.", "fore-red"); stopAutoMining(); return; }

            const oreData = ORE_DATA[currentMiningTarget];
            const oldLevel = getLevelFromXp(playerData.mining_xp);
            
            let baseYieldBonus = 0;
            if (playerData.built_structures.camp && STRUCTURE_DATA.camp.perk_effect.type === "base_gather_yield_bonus" && Math.random() < STRUCTURE_DATA.camp.perk_effect.value) {
                baseYieldBonus = 1;
            }

            let oreGained = pickaxeProps.yield_config.base + baseYieldBonus;
            if (pickaxeProps.yield_config.bonuses) {
                pickaxeProps.yield_config.bonuses.forEach(bonus => {
                    if (Math.random() < bonus.chance) oreGained += bonus.amount;
                });
            }
            if (oreGained < 0) oreGained = 0; 

            let xpPerOre = oreData.xp; 
            let totalXpGainedThisAction = 0;

            if (oreGained > 0) {
                playerData.inventory[oreData.item_name] = (playerData.inventory[oreData.item_name] || 0) + oreGained;
                totalXpGainedThisAction = oreGained * xpPerOre;

                let logMsg = `Got ${oreGained} ${titleCase(oreData.item_name)}.`;
                 if (baseYieldBonus > 0) logMsg += " (Camp bonus!)";
                
                let displayXpGained = totalXpGainedThisAction;
                if (playerData.built_structures.house) {
                     const houseXpPerk = STRUCTURE_DATA.house.perks.find(p => p.type === "global_xp_boost");
                    if (houseXpPerk) {
                        displayXpGained *= (1 + houseXpPerk.value);
                    }
                }
                displayXpGained = Math.floor(displayXpGained);
                
                logMessage(`+${displayXpGained} Mining XP. ${logMsg}`, oreData.color);

                playerData.mining_xp += displayXpGained;
                grantUniversalXP(totalXpGainedThisAction);

            } else {
                 logMessage(`Got no ore this time. (+0 Mining XP)`, "fore-yellow");
            }
            
            playSound(skillRoundSound); 
            handleLevelUp("mining_xp", oldLevel);
            savePlayerData();
            updateHud();
            // Update inventory count display for the current ore
            const countSpan = document.getElementById(`inv-count-mn-${currentMiningTarget.replace(/\s+/g, '-')}`);
            if (countSpan) {
                countSpan.textContent = playerData.inventory[oreData.item_name] || 0;
            }
        }

        // --- Action: Blacksmithing (Modified for Shed Perk & new interaction) ---
        function showBlacksmithingMenu() {
            stopAllAutoActions();
            showSection('blacksmithing-menu-section');
        }
        
        function calculateMaxCraftableForBar(barName) {
            const bar = BAR_DATA[barName];
            if (!bar) return 0;
            let maxSets = Infinity;
            for (const ore in bar.recipe) {
                const oreOnHand = playerData.inventory[ore] || 0;
                const oreNeededPerSet = bar.recipe[ore];
                if (oreNeededPerSet === 0) continue;
                maxSets = Math.min(maxSets, Math.floor(oreOnHand / oreNeededPerSet));
            }
            return maxSets === Infinity ? 0 : maxSets;
        }

        function showSmeltingMenu() {
            if (!isAutoSmelting) { 
                stopAllAutoActions();
                currentSmeltingTarget = null;
            }
            const listDiv = document.getElementById('available-bars-to-smelt');
            listDiv.innerHTML = '<div class="section-title">Available Bars to Smelt</div>';
            
            const bsLvl = getLevelFromXp(playerData.blacksmithing_xp);
            let canSmeltAnythingAtAll = false; 

            for (const barName in BAR_DATA) {
                const bar = BAR_DATA[barName];
                let recipeString = "";
                for(const ore in bar.recipe) {
                    recipeString += `${bar.recipe[ore]} ${titleCase(ore)} (${playerData.inventory[ore] || 0}), `;
                }
                recipeString = recipeString.slice(0, -2); 

                const maxCraftableNow = calculateMaxCraftableForBar(barName);
                const canMakeAtLeastOne = maxCraftableNow > 0;
                
                const levelReqColor = bsLvl >= bar.level_req ? 'fore-green' : 'fore-red';
                const currentStock = playerData.inventory[barName] || 0;
                const itemDiv = document.createElement('div');
                itemDiv.className = `smeltable-item-list item ${bar.color}`;
                itemDiv.id = `smeltable-item-div-${barName.replace(/\s+/g, '-')}`; 

                itemDiv.innerHTML = `
                    <span class="item-details-left">
                        ${bar.emoji} ${titleCase(barName)} (XP: ${bar.xp_gain})
                        <br><small>Requires: ${recipeString} - <span class="${levelReqColor}">Lvl: ${bar.level_req} BS</span> - Max: <span id="max-craftable-${barName.replace(/\s+/g, '-')}">${maxCraftableNow}</span></small>
                    </span>
                    <span class="resource-inventory-count">
                        <span id="inv-count-smelt-${barName.replace(/\s+/g, '-')}">${currentStock}</span>
                    </span>
                `;

                if (isAutoSmelting && currentSmeltingTarget === barName) {
                    itemDiv.classList.add('active-smelting-item');
                }
                if (bsLvl >= bar.level_req && canMakeAtLeastOne) {
                    itemDiv.onclick = () => selectBarForSmelting(barName);
                    canSmeltAnythingAtAll = true;
                } else {
                    itemDiv.style.cursor = 'not-allowed';
                    itemDiv.title = bsLvl < bar.level_req ? 'BS level too low' : 'Not enough materials';
                    itemDiv.style.opacity = "0.6";
                }
                listDiv.appendChild(itemDiv);
            }

            if (!canSmeltAnythingAtAll && Object.keys(BAR_DATA).length > 0) listDiv.innerHTML += "<p>No bars you can currently smelt (check level & materials).</p>";
            else if (Object.keys(BAR_DATA).length === 0) listDiv.innerHTML += "<p>No bar recipes known.</p>";
            
            showSection('smelting-section');
        }

        function selectBarForSmelting(barName) {
            if (isAutoSmelting && currentSmeltingTarget === barName) {
                stopAutoSmelting();
            } else {
                if (isAutoSmelting) {
                    stopAutoSmelting();
                }
                startAutoSmelting(barName);
            }
        }

        function startAutoSmelting(barName) {
            if(!barName) { logMessage("No bar selected to smelt.", "fore-red"); return false; }
            document.querySelectorAll('.active-smelting-item').forEach(el => el.classList.remove('active-smelting-item'));
            
            const barData = BAR_DATA[barName]; 
            if (!barData) { logMessage("Error: Bar data not found for " + barName, "fore-red"); currentSmeltingTarget = null; return false; }
            currentSmeltingTarget = barName; 

            const currentBsLvl = getLevelFromXp(playerData.blacksmithing_xp);
            if(currentBsLvl < barData.level_req) {
                logMessage(`BS Lvl (${currentBsLvl}) too low for ${titleCase(currentSmeltingTarget)}. Req: ${barData.level_req}`, "fore-red");
                currentSmeltingTarget = null; return false;
            }

            maxSmeltableForCurrentTarget = calculateMaxCraftableForBar(currentSmeltingTarget);
            if (maxSmeltableForCurrentTarget <= 0) {
                logMessage(`Not enough materials to smelt any ${titleCase(currentSmeltingTarget)}.`, "fore-red");
                currentSmeltingTarget = null; return false;
            }

            isAutoSmelting = true;
            const barListItem = document.getElementById(`smeltable-item-div-${currentSmeltingTarget.replace(/\s+/g, '-')}`);
            if (barListItem) barListItem.classList.add('active-smelting-item');
            logMessage(`Auto-smelting ${titleCase(currentSmeltingTarget)}... (Up to ${maxSmeltableForCurrentTarget} times)`, "fore-cyan");
            
            let interval = BASE_CRAFT_INTERVAL;
            if (playerData.built_structures.shed && STRUCTURE_DATA.shed.perk_effect.type === "crafting_speed_boost") { // Specific check for shed
                interval *= (1 - STRUCTURE_DATA.shed.perk_effect.value);
            }
            if (playerData.built_structures.stronghold) {
                const speedPerk = STRUCTURE_DATA.stronghold.perks.find(p => p.type === "global_skill_speed_boost");
                if (speedPerk) interval *= (1 - speedPerk.value);
            }
            if (autoSmeltingInterval) clearInterval(autoSmeltingInterval);
            autoSmeltingInterval = setInterval(singleSmeltAction, interval);
            return true;
        }

        function stopAutoSmelting() {
            if(isAutoSmelting) {
                isAutoSmelting = false;
                clearInterval(autoSmeltingInterval);
                autoSmeltingInterval = null;
                if (currentSmeltingTarget) {
                    const barListItem = document.getElementById(`smeltable-item-div-${currentSmeltingTarget.replace(/\s+/g, '-')}`);
                    if (barListItem) barListItem.classList.remove('active-smelting-item');
                }
                logMessage("Auto-smelting stopped.", "fore-yellow");
            }
        }

        function singleSmeltAction() {
            if(!isAutoSmelting || !currentSmeltingTarget) { stopAutoSmelting(); return; }

            const barData = BAR_DATA[currentSmeltingTarget];
            maxSmeltableForCurrentTarget = calculateMaxCraftableForBar(currentSmeltingTarget); 

            if (maxSmeltableForCurrentTarget <= 0) {
                logMessage(`Ran out of materials for ${titleCase(currentSmeltingTarget)}. Stopping.`, "fore-red");
                stopAutoSmelting();
                showSmeltingMenu(); 
                return;
            }

            for(const ore in barData.recipe) {
                playerData.inventory[ore] -= barData.recipe[ore];
            }

            let barsMade = 1;
            if(isPerkActive("advancedSmelting") && Math.random() < PERK_DATA.advancedSmelting.value) {
                barsMade++;
                logMessage("Bonus! Advanced Smelting produced an extra bar!", "fore-magenta");
            }

            playerData.inventory[currentSmeltingTarget] = (playerData.inventory[currentSmeltingTarget] || 0) + barsMade;
            const oldLevel = getLevelFromXp(playerData.blacksmithing_xp);
            
            let xpGainedRaw = barData.xp_gain; // Store raw XP before House perk
            let xpGainedDisplay = xpGainedRaw; 
            if (playerData.built_structures.house) {
                const houseXpPerk = STRUCTURE_DATA.house.perks.find(p => p.type === "global_xp_boost");
                if(houseXpPerk) xpGainedDisplay *= (1 + houseXpPerk.value);
            }
            xpGainedDisplay = Math.floor(xpGainedDisplay);

            playerData.blacksmithing_xp += xpGainedDisplay;
            grantUniversalXP(xpGainedRaw); // Pass raw XP to universal XP function

            logMessage(`Smelted ${barsMade} ${titleCase(currentSmeltingTarget)}! (+${xpGainedDisplay} BS XP)`, barData.color);
            
            playSound(skillRoundSound); 
            handleLevelUp("blacksmithing_xp", oldLevel);
            savePlayerData();
            updateHud();
            
            const itemDivToUpdate = document.getElementById(`smeltable-item-div-${currentSmeltingTarget.replace(/\s+/g, '-')}`);
            if (itemDivToUpdate) {
                let newRecipeString = "";
                 for(const ore in barData.recipe) {
                    newRecipeString += `${barData.recipe[ore]} ${titleCase(ore)} (${playerData.inventory[ore] || 0}), `;
                }
                newRecipeString = newRecipeString.slice(0, -2);
                const newMaxCraftableDisplay = calculateMaxCraftableForBar(currentSmeltingTarget);
                const bsLvl = getLevelFromXp(playerData.blacksmithing_xp);
                const levelReqColor = bsLvl >= barData.level_req ? 'fore-green' : 'fore-red';
                const newStockCount = playerData.inventory[currentSmeltingTarget] || 0;

                // Reconstruct innerHTML matching the new structure in showSmeltingMenu
                itemDivToUpdate.innerHTML = `
                    <span class="item-details-left">
                        ${barData.emoji} ${titleCase(currentSmeltingTarget)} (XP: ${barData.xp_gain})
                        <br><small>Requires: ${newRecipeString} - <span class="${levelReqColor}">Lvl: ${barData.level_req} BS</span> - Max: <span id="max-craftable-${currentSmeltingTarget.replace(/\s+/g, '-')}">${newMaxCraftableDisplay}</span></small>
                    </span>
                    <span class="resource-inventory-count">
                        <span id="inv-count-smelt-${currentSmeltingTarget.replace(/\s+/g, '-')}">${newStockCount}</span>
                    </span>
                `;
                 if (newMaxCraftableDisplay === 0 || bsLvl < barData.level_req) {
                    itemDivToUpdate.style.cursor = 'not-allowed';
                    itemDivToUpdate.title = bsLvl < barData.level_req ? 'BS level too low' : 'Not enough materials';
                    itemDivToUpdate.style.opacity = "0.6";
                    itemDivToUpdate.onclick = null; 
                } else { 
                    itemDivToUpdate.style.cursor = 'pointer';
                    itemDivToUpdate.title = '';
                    itemDivToUpdate.style.opacity = "1";
                    itemDivToUpdate.onclick = () => selectBarForSmelting(currentSmeltingTarget);
                }
            }

            if (calculateMaxCraftableForBar(currentSmeltingTarget) <= 0) { 
                 logMessage(`No more materials for ${titleCase(currentSmeltingTarget)}. Auto-smelting stopped.`, "fore-yellow");
                 stopAutoSmelting();
            }
        }


        // Smithing (Modified for Shed Perk & new interaction)
        function calculateMaxCraftableForSword(swordName) {
            const sword = SWORD_DATA[swordName];
            if (!sword) return 0;
            let maxSets = Infinity;
            for (const bar in sword.recipe) {
                const barsOnHand = playerData.inventory[bar] || 0;
                const barsNeededPerSet = isPerkActive("masterSmith") && sword.recipe[bar] > 1 ?
                                          Math.max(1, sword.recipe[bar] - PERK_DATA.masterSmith.value) :
                                          sword.recipe[bar];
                if (barsNeededPerSet === 0) continue;
                maxSets = Math.min(maxSets, Math.floor(barsOnHand / barsNeededPerSet));
            }
            return maxSets === Infinity ? 0 : maxSets;
        }
        function showSmithingMenu() {
            if (!isAutoSmithing) { // Only stop if not currently auto-smithing (i.e., user navigated here)
                stopAllAutoActions();
                currentSmithingTarget = null;
            }
            const listDiv = document.getElementById('available-items-to-smith');
            listDiv.innerHTML = '<div class="section-title">Available Items to Smith</div>';

            const bsLvl = getLevelFromXp(playerData.blacksmithing_xp);
            let canSmithAnything = false;

            for (const itemName in SWORD_DATA) {
                const itemData = SWORD_DATA[itemName];
                let recipeString = "";
                const maxCraftableNow = calculateMaxCraftableForSword(itemName);
                const canMakeAtLeastOne = maxCraftableNow > 0;
                
                for(const bar in itemData.recipe) {
                    const requiredAmount = isPerkActive("masterSmith") && itemData.recipe[bar] > 1 ?
                                          Math.max(1, itemData.recipe[bar] - PERK_DATA.masterSmith.value) :
                                          itemData.recipe[bar];
                    recipeString += `${requiredAmount} ${titleCase(bar)} (${playerData.inventory[bar] || 0}), `;
                }
                recipeString = recipeString.slice(0, -2);

                const levelReqColor = bsLvl >= itemData.smith_level_req ? 'fore-green' : 'fore-red';
                const itemDiv = document.createElement('div');
                let lifestealInfo = "";
                if (itemData.lifesteal_chance && itemData.lifesteal_amount) {
                    const lsChanceDisplay = itemData.lifesteal_chance * 100;
                    const lsAmountDisplay = Array.isArray(itemData.lifesteal_amount) ? `${itemData.lifesteal_amount[0]}-${itemData.lifesteal_amount[1]}` : itemData.lifesteal_amount;
                    lifestealInfo = `<br><small class="fore-magenta">Lifesteal: ${lsChanceDisplay.toFixed(0)}% for ${lsAmountDisplay} HP</small>`;
                }
                itemDiv.className = `smithable-item-list item ${itemData.color}`;
                const currentStock = playerData.inventory[itemName] || 0;
                itemDiv.innerHTML = `
                    <span class="item-details-left"> <!-- Details on the left -->
                        ${itemData.emoji} ${titleCase(itemName)} (XP: ${itemData.smith_level_req * 5}) 
                        <br><small>Requires: ${recipeString} - <span class="${levelReqColor}">Lvl: ${itemData.smith_level_req} BS</span> - Max: <span id="max-craftable-smith-${itemName.replace(/\s+/g, '-')}">${maxCraftableNow}</span></small>${lifestealInfo}
                    </span>
                    <span class="resource-inventory-count"> <!-- Count on the right -->
                        <span id="inv-count-smith-${itemName.replace(/\s+/g, '-')}">${currentStock}</span>
                    </span>
                `;
                itemDiv.id = `smithable-item-div-${itemName.replace(/\s+/g, '-')}`;
                if (isAutoSmithing && currentSmithingTarget === itemName) {
                    itemDiv.classList.add('active-smithing-item');
                }
                if (bsLvl >= itemData.smith_level_req && canMakeAtLeastOne) {
                    itemDiv.onclick = () => selectItemForSmithing(itemName);
                    canSmithAnything = true;
                } else {
                    itemDiv.style.cursor = 'not-allowed';
                    itemDiv.title = bsLvl < itemData.smith_level_req ? 'BS level too low' : 'Not enough materials';
                    itemDiv.style.opacity = "0.6";
                }
                listDiv.appendChild(itemDiv);
            }
             if (!canSmithAnything && Object.keys(SWORD_DATA).length > 0) listDiv.innerHTML += "<p>No items you can currently smith (check level & materials).</p>";
            else if (Object.keys(SWORD_DATA).length === 0) listDiv.innerHTML += "<p>No item recipes known for smithing.</p>";
            
            showSection('smithing-section');
        }
        
        function selectItemForSmithing(itemName) {
            if (isAutoSmithing && currentSmithingTarget === itemName) {
                stopAutoSmithing(); // If clicking the currently auto-smithing item, stop it.
            } else {
                if (isAutoSmithing) { // If auto-smithing something else, stop that first.
                    stopAutoSmithing();
                }
                startAutoSmithing(itemName); // Start (or restart) auto-smithing for the selected item.
            }
        }

        function startAutoSmithing(itemName) {
            if(!itemName) { logMessage("No item selected to smith.", "fore-red"); return false; }
            document.querySelectorAll('.active-smithing-item').forEach(el => el.classList.remove('active-smithing-item'));
            currentSmithingTarget = itemName; 
            
            const itemData = SWORD_DATA[currentSmithingTarget]; 
            const currentBsLvl = getLevelFromXp(playerData.blacksmithing_xp);
            if(currentBsLvl < itemData.smith_level_req) {
                logMessage(`BS Lvl (${currentBsLvl}) too low for ${titleCase(currentSmithingTarget)}. Req: ${itemData.smith_level_req}`, "fore-red");
                currentSmithingTarget = null; return false;
            }

            if (calculateMaxCraftableForSword(currentSmithingTarget) <= 0) {
                logMessage(`Not enough materials to smith any ${titleCase(currentSmithingTarget)}.`, "fore-red");
                currentSmithingTarget = null; return false;
            }

            isAutoSmithing = true;
            const smithListItem = document.getElementById(`smithable-item-div-${currentSmithingTarget.replace(/\s+/g, '-')}`);
            if (smithListItem) smithListItem.classList.add('active-smithing-item');
            logMessage(`Auto-smithing ${titleCase(currentSmithingTarget)}...`, "fore-cyan");

            let interval = BASE_CRAFT_INTERVAL;
            if (playerData.built_structures.shed && STRUCTURE_DATA.shed.perk_effect.type === "crafting_speed_boost") { // Specific check for shed
                interval *= (1 - STRUCTURE_DATA.shed.perk_effect.value);
            }
            if (playerData.built_structures.stronghold) {
                const speedPerk = STRUCTURE_DATA.stronghold.perks.find(p => p.type === "global_skill_speed_boost");
                if (speedPerk) interval *= (1 - speedPerk.value);
            }
            if(autoSmithingInterval) clearInterval(autoSmithingInterval);
            autoSmithingInterval = setInterval(singleSmithAction, interval);
            return true;
        }

        function stopAutoSmithing() {
            if(isAutoSmithing) {
                isAutoSmithing = false;
                clearInterval(autoSmithingInterval);
                autoSmithingInterval = null;
                if(currentSmithingTarget) {
                    const smithListItem = document.getElementById(`smithable-item-div-${currentSmithingTarget.replace(/\s+/g, '-')}`);
                    if (smithListItem) smithListItem.classList.remove('active-smithing-item');
                }
                logMessage("Auto-smithing stopped.", "fore-yellow");
            }
        }

        function singleSmithAction() {
            if(!isAutoSmithing || !currentSmithingTarget) { stopAutoSmithing(); return; }
            
            const itemData = SWORD_DATA[currentSmithingTarget]; 
            if (calculateMaxCraftableForSword(currentSmithingTarget) <= 0) {
                logMessage(`Ran out of materials for ${titleCase(currentSmithingTarget)}. Stopping.`, "fore-red");
                stopAutoSmithing();
                showSmithingMenu(); // Refresh the menu to show updated counts and disable if needed
                return;
            }

            for(const bar in itemData.recipe) {
                const requiredAmount = isPerkActive("masterSmith") && itemData.recipe[bar] > 1 ? 
                                      Math.max(1, itemData.recipe[bar] - PERK_DATA.masterSmith.value) : 
                                      itemData.recipe[bar];
                playerData.inventory[bar] -= requiredAmount;
            }
            
            playerData.inventory[currentSmithingTarget] = (playerData.inventory[currentSmithingTarget] || 0) + 1;
            
            let xpGainRaw = itemData.smith_level_req * 5; 
            let xpGainedDisplay = xpGainRaw; 
            if (playerData.built_structures.house) {
                const houseXpPerk = STRUCTURE_DATA.house.perks.find(p => p.type === "global_xp_boost");
                if(houseXpPerk) xpGainedDisplay *= (1 + houseXpPerk.value);
            }
            xpGainedDisplay = Math.floor(xpGainedDisplay);

            const oldLevel = getLevelFromXp(playerData.blacksmithing_xp);
            playerData.blacksmithing_xp += xpGainedDisplay;
            grantUniversalXP(xpGainRaw); 

            logMessage(`Smithed 1 ${titleCase(currentSmithingTarget)}! (+${xpGainedDisplay} BS XP)`, itemData.color);
            
            playSound(skillRoundSound); 
            handleLevelUp("blacksmithing_xp", oldLevel);
            savePlayerData();
            updateHud();
            // Instead of full refresh, update the specific item in the list
            updateSmithableItemDisplay(currentSmithingTarget);
            if (!checkCanStillSmith(currentSmithingTarget)) { // If materials run out
                stopAutoSmithing();
            }
        }

        // --- Action: Combat (Modified for Monster Gold Drop & Mansion Perk) --- 
        function showCombat() {
            stopAllAutoActions();
            const monsterListDiv = document.getElementById('available-monsters');
            monsterListDiv.innerHTML = '<div class="section-title">Attackable Monsters</div>';
            document.getElementById('combat-arena').classList.add('hidden');

            const atkLvl = getLevelFromXp(playerData.attack_xp);
            let available = false;
            ALL_MONSTER_NAMES.forEach(monsterName => {
                const monster = MONSTER_DATA[monsterName];
                if (atkLvl >= monster.level_req) {
                    available = true;
                    const monsterDiv = document.createElement('div');
                    monsterDiv.className = `item ${monster.color}`; 
                    monsterDiv.id = `monster-list-item-${monsterName.replace(/\s+/g, '-').toLowerCase()}`;
                    monsterDiv.innerHTML = `${monster.emoji} ${titleCase(monsterName)} (Lvl: ${monster.level_req}, HP: ${monster.hp})`;
                    monsterDiv.onclick = () => selectMonsterForCombat(monsterName);
                    monsterListDiv.appendChild(monsterDiv);
                }
            });
            if (!available) monsterListDiv.innerHTML += "<p>No monsters available at your level.</p>";
            showSection('combat-section');
        }

        function selectMonsterForCombat(monsterName) {
            if (isAutoAttacking && currentMonsterTarget === monsterName) {
                stopAutoAttack(); 
            } else {
                if (isAutoAttacking) {
                    stopAutoAttack(); 
                }
                // currentMonsterTarget = monsterName; // This is set inside startAutoAttack
                startAutoAttack(monsterName); 
            }
        }
        
        function stopCombatAndReturn() {
            stopAutoAttack(); 
            showActionsMenu();
        }
        
        function startAutoAttack(monsterName) { 
            if (playerData.hp <= 0) { logMessage("You are too weak to fight.", "fore-red"); return; }
            if (!monsterName) { logMessage("No monster target specified for auto-attack.", "fore-red"); return; }
            currentMonsterTarget = monsterName; // Set target here

            isAutoAttacking = true;
            logMessage(`Auto-attacking ${titleCase(currentMonsterTarget)}...`, "fore-red");
            
            const monsterListContainer = document.getElementById('available-monsters');
            const monsterItems = monsterListContainer.querySelectorAll('.item');
            const targetMonsterId = `monster-list-item-${currentMonsterTarget.replace(/\s+/g, '-').toLowerCase()}`;

            for (let item of monsterItems) {
                if (item.id === targetMonsterId) {
                    item.classList.remove('hidden');
                    item.classList.add('attacking-monster-list-item');
                } else {
                    item.classList.add('hidden');
                    item.classList.remove('attacking-monster-list-item'); 
                }
            }
            prepareCombatArena(currentMonsterTarget); 
            if(autoAttackInterval) clearInterval(autoAttackInterval);
            autoAttackInterval = setInterval(singleCombatRound, BASE_COMBAT_INTERVAL); 
        }

        function stopAutoAttack() {
            if (isAutoAttacking) {
                isAutoAttacking = false;
                clearInterval(autoAttackInterval);
                autoAttackInterval = null;
                
                if (currentMonsterTarget) { 
                    const monsterListItem = document.getElementById(`monster-list-item-${currentMonsterTarget.replace(/\s+/g, '-').toLowerCase()}`);
                    if (monsterListItem) monsterListItem.classList.remove('attacking-monster-list-item');
                    logMessage("Auto-attack stopped.", "fore-yellow");
                }
                const monsterListContainer = document.getElementById('available-monsters');
                const monsterItems = monsterListContainer.querySelectorAll('.item');
                for (let item of monsterItems) {
                    item.classList.remove('hidden');
                }
            }
        }
        
        function prepareCombatArena(monsterName, isRespawn = false, originalColorIfRespawn = null) {
            const monster = MONSTER_DATA[monsterName];
            currentMonsterHP = monster.hp;
            const monsterDisplayEl = document.getElementById('monster-display-combat');
            const monsterHpDisplayEl = document.getElementById('monster-hp-combat');

            if (isRespawn) {
                monsterDisplayEl.innerHTML = `<span class="emoji">✨</span> Spawning ${titleCase(monsterName)}...`;
                monsterDisplayEl.className = `monster-display ${originalColorIfRespawn || monster.color} fore-yellow`; 
                monsterHpDisplayEl.textContent = `---/${monster.hp}`; 

                setTimeout(() => {
                    monsterDisplayEl.innerHTML = `<span class="emoji">${monster.emoji}</span> ${titleCase(monsterName)}`;
                    monsterDisplayEl.className = `monster-display ${monster.color}`; 
                    monsterHpDisplayEl.textContent = `${currentMonsterHP}/${monster.hp}`;
                }, 750); 
            } else {
                monsterDisplayEl.innerHTML = `<span class="emoji">${monster.emoji}</span> ${titleCase(monsterName)}`;
                monsterDisplayEl.className = `monster-display ${monster.color}`;
                monsterHpDisplayEl.textContent = `${currentMonsterHP}/${monster.hp}`;
            }
            
            document.getElementById('player-hp-combat').textContent = `${playerData.hp}/${getMaxHp(getLevelFromXp(playerData.attack_xp))}`;
            document.getElementById('combat-arena').classList.remove('hidden');
        }
        
        function singleCombatRound() {
            if (!currentMonsterTarget || playerData.hp <= 0) {
                stopAutoAttack();
                if (playerData.hp <= 0 && currentMonsterTarget) {
                    logMessage("Player defeated. Combat ended.", "fore-red");
                    playSound(playerDieSound); 
                }
                else if (!currentMonsterTarget && isAutoAttacking) logMessage("Auto-attack stopped: No target.", "fore-yellow");
                return;
            }

            const monster = MONSTER_DATA[currentMonsterTarget];
            let playerAtkLvl = getLevelFromXp(playerData.attack_xp); // Use let for oldAtkLvl later
            const playerMaxHp = getMaxHp(playerAtkLvl);

            let weaponName = "fists";
            let weaponStats = TOOL_DATA.axe.fists; 
            
            const equippedWeapon = playerData.inventory.weapon;
            const equippedAxe = playerData.inventory.axe;
            const equippedPickaxe = playerData.inventory.pickaxe;

            if (equippedWeapon !== "none" && SWORD_DATA[equippedWeapon]) {
                weaponName = equippedWeapon;
                weaponStats = SWORD_DATA[equippedWeapon];
            } else if (equippedAxe !== "none" && TOOL_DATA.axe[equippedAxe]) {
                weaponName = equippedAxe;
                weaponStats = TOOL_DATA.axe[equippedAxe];
            } else if (equippedPickaxe !== "none" && TOOL_DATA.pickaxe[equippedPickaxe]) {
                weaponName = equippedPickaxe;
                weaponStats = TOOL_DATA.pickaxe[equippedPickaxe];
            }
            
            let playerDmg = Math.floor(Math.random() * (weaponStats.max_dmg - weaponStats.min_dmg + 1)) + weaponStats.min_dmg;
            
            let finalPlayerDmg = playerDmg;
            if (weaponName.includes("2h sword")) { 
                if(isPerkActive("weaponMaster1")) {
                    finalPlayerDmg *= (1 + PERK_DATA.weaponMaster1.value);
                }
            }
            // Apply Stronghold global damage boost
            if (playerData.built_structures.stronghold) {
                const damagePerk = STRUCTURE_DATA.stronghold.perks.find(p => p.type === "global_damage_boost");
                if (damagePerk) finalPlayerDmg *= (1 + damagePerk.value);
            }

            let critMultiplier = 1.0;
            if(isPerkActive("preciseStrikes1") && Math.random() < PERK_DATA.preciseStrikes1.value) {
                critMultiplier = PERK_DATA.preciseStrikes1.crit_multiplier;
                logMessage("CRITICAL HIT!", "fore-lightred_ex");
            }
            playerDmg = Math.floor(finalPlayerDmg * critMultiplier);


            let hitChance = 0.80 + Math.max(0, (playerAtkLvl - monster.level_req) * 0.001);
            hitChance = Math.min(0.95, hitChance);

            if (Math.random() < hitChance) {
                currentMonsterHP -= playerDmg;
                logMessage(`You hit ${titleCase(currentMonsterTarget)} with ${titleCase(weaponName)} for ${playerDmg} damage!`, "fore-yellow");
                
                let effectiveLifestealChance = weaponStats.lifesteal_chance || 0;
                let effectiveLifestealAmount = weaponStats.lifesteal_amount || 0;

                if (weaponName.includes("2h sword")) { 
                    if(isPerkActive("vampiricEdge1")) {
                        effectiveLifestealChance += PERK_DATA.vampiricEdge1.value;
                    }
                }

                if (effectiveLifestealChance > 0 && Math.random() < effectiveLifestealChance) {
                    let stolenHp = 0;
                    if (Array.isArray(effectiveLifestealAmount)) {
                        stolenHp = Math.floor(Math.random() * (effectiveLifestealAmount[1] - effectiveLifestealAmount[0] + 1)) + effectiveLifestealAmount[0];
                    } else {
                        stolenHp = effectiveLifestealAmount;
                    }
                    const oldHp = playerData.hp;
                    playerData.hp = Math.min(playerMaxHp, playerData.hp + stolenHp);
                    if (playerData.hp > oldHp) {
                        logMessage(`Lifesteal! +${playerData.hp - oldHp} HP.`, "fore-green");
                    }
                }

            } else {
                logMessage(`You missed ${titleCase(currentMonsterTarget)}!`, "fore-blue");
            }
            document.getElementById('monster-hp-combat').textContent = `${Math.max(0,currentMonsterHP)}/${monster.hp}`;

            if (currentMonsterHP <= 0) {
                logMessage(`${titleCase(currentMonsterTarget)} defeated!`, monster.color);
                playSound(monsterKillSound);

                const monsterDisplayEl = document.getElementById('monster-display-combat');
                const originalMonsterNameColor = monster.color; 
                monsterDisplayEl.innerHTML = `<span class="emoji">💀</span> ${titleCase(currentMonsterTarget)} Defeated!`;
                monsterDisplayEl.className = `monster-display fore-lightred_ex`; 
                document.getElementById('monster-hp-combat').textContent = `0/${monster.hp}`;

                const oldAtkLvl = playerAtkLvl;
                let xpGainedRaw = monster.attack_xp;
                let xpGainedDisplay = xpGainedRaw; 

                if (playerData.built_structures.house) {
                    const houseXpPerk = STRUCTURE_DATA.house.perks.find(p => p.type === "global_xp_boost");
                    if (houseXpPerk) {
                        xpGainedDisplay *= (1 + houseXpPerk.value);
                    }
                }
                playerData.attack_xp += Math.floor(xpGainedDisplay);
                grantUniversalXP(xpGainedRaw); 

                logMessage(`Gained ${Math.floor(xpGainedDisplay)} Attack XP!`, "fore-green");
                
                handleLevelUp("attack_xp", oldAtkLvl);
                playerAtkLvl = getLevelFromXp(playerData.attack_xp); 

                // --- GOLD DROP LOGIC ---
                if (monster.gold_drop && monster.gold_drop[1] > 0) { 
                    let goldDropped = Math.floor(Math.random() * (monster.gold_drop[1] - monster.gold_drop[0] + 1)) + monster.gold_drop[0];
                    
                    if (playerData.built_structures.mansion) {
                        const mansionGoldPerk = STRUCTURE_DATA.mansion.perks.find(p => p.type === "monster_gold_drop_multiplier_chance");
                        if (mansionGoldPerk && Math.random() < mansionGoldPerk.value) {
                            goldDropped *= mansionGoldPerk.multiplier;
                            logMessage("Lavish Lifestyle proc! Gold drop doubled!", "fore-magenta");
                        }
                    }

                    if (goldDropped > 0) {
                        playerData.gold += goldDropped;
                        logMessage(`The ${titleCase(currentMonsterTarget)} dropped ${goldDropped} gold!`, "fore-yellow");
                    }
                }

                if (playerData.built_structures.house && currentMonsterTarget !== "chicken") {
                    const houseScaledGoldPerk = STRUCTURE_DATA.house.perks.find(p => p.type === "scaled_bonus_mob_gold_drop_chance");
                    if (houseScaledGoldPerk && monster.gold_drop && monster.gold_drop[1] > 0 && Math.random() < houseScaledGoldPerk.value) {
                        const baseGoldForScaling = Math.floor(Math.random() * (monster.gold_drop[1] - monster.gold_drop[0] + 1)) + monster.gold_drop[0];
                        const bonusScaledGold = Math.floor(baseGoldForScaling * houseScaledGoldPerk.bonus_gold_percentage_of_base);
                        if (bonusScaledGold > 0) {
                            playerData.gold += bonusScaledGold;
                            logMessage(`House bonus! +${bonusScaledGold} extra gold from ${titleCase(currentMonsterTarget)}!`, "fore-yellow");
                        }
                    }
                }

                monster.drops.forEach(drop => {
                    const isRare = drop.item_name.includes("gem") || drop.item_name.includes("heart") || ARMOR_DATA[drop.item_name];
                    const bonus = (playerAtkLvl * (isRare ? 0.001 : 0.005));
                    const capBonus = isRare ? 0.05 : 0.20;
                    const effBonus = Math.min(bonus, capBonus);
                    const dropChance = Math.min(0.95, drop.base_chance + effBonus);

                    if (Math.random() < dropChance || drop.always_drop_one) {
                        const quantity = Math.floor(Math.random() * (drop.quantity[1] - drop.quantity[0] + 1)) + drop.quantity[0];
                        if ( ARMOR_DATA[drop.item_name] && (playerData.inventory[drop.item_name] > 0 || playerData.inventory.chestplate === drop.item_name) ) {
                             return; 
                        }
                        playerData.inventory[drop.item_name] = (playerData.inventory[drop.item_name] || 0) + quantity;
                        logMessage(`Received ${quantity} ${titleCase(drop.item_name)}!`, "fore-magenta");
                    }
                });

                if (playerData.built_structures.stronghold) {
                    const healPerk = STRUCTURE_DATA.stronghold.perks.find(p => p.type === "heal_on_kill_percent");
                    if (healPerk) {
                        const healAmount = Math.floor(playerMaxHp * healPerk.value);
                        if(playerData.hp < playerMaxHp && healAmount > 0) { // Only heal if not full and healAmount > 0
                            const oldPlayerHpForHeal = playerData.hp;
                            playerData.hp = Math.min(playerMaxHp, playerData.hp + healAmount);
                            if (playerData.hp > oldPlayerHpForHeal) { // Check if actual healing occurred
                                logMessage(`Stronghold's Blessing! Healed ${playerData.hp - oldPlayerHpForHeal} HP.`, "fore-green");
                            }
                        }
                    }
                }

                savePlayerData();
                updateHud();

                if (!isAutoAttacking) { 
                    currentMonsterTarget = null; 
                    const monsterNameForID = monster.name ? monster.name : currentMonsterTarget; // Fallback if monster.name isn't defined for some reason
                    const defeatedMonsterListItem = document.getElementById(`monster-list-item-${monsterNameForID.replace(/\s+/g, '-').toLowerCase()}`);
                    if (defeatedMonsterListItem) defeatedMonsterListItem.classList.remove('attacking-monster-list-item');
                    setTimeout(() => {
                        document.getElementById('combat-arena').classList.add('hidden'); 
                        showCombat(); 
                    }, 1200); 
                } else {
                    setTimeout(() => {
                         prepareCombatArena(currentMonsterTarget, true, originalMonsterNameColor); 
                    }, 1200); 
                }
                return; 
            }

            let monsterDmg;
            if (currentMonsterTarget === "chicken") { 
                monsterDmg = (Math.random() < 0.125) ? 2 : 1; 
            } else {
                const monsterMinDmg = Math.max(1, Math.floor(monster.level_req / 4));
                const monsterMaxDmg = Math.max(monsterMinDmg + 1, Math.floor(monster.level_req / 2));
                monsterDmg = Math.floor(Math.random() * (monsterMaxDmg - monsterMinDmg + 1)) + monsterMinDmg;
            }

            let monsterHitChance = 0.70 + Math.max(0, (monster.level_req - playerAtkLvl) * 0.01);
            const equippedChestplate = playerData.inventory.chestplate;
            if (equippedChestplate !== "none" && ARMOR_DATA[equippedChestplate]) {
                monsterHitChance -= ARMOR_DATA[equippedChestplate].defense;
            }
            monsterHitChance = Math.max(0.05, Math.min(0.95, monsterHitChance));
            
            if (Math.random() < monsterHitChance) {
                playerData.hp -= monsterDmg;
                logMessage(`${titleCase(currentMonsterTarget)} hits you for ${monsterDmg} damage!`, "fore-red");
            } else {
                logMessage(`${titleCase(currentMonsterTarget)} missed!`, "fore-blue");
            }
            document.getElementById('player-hp-combat').textContent = `${Math.max(0,playerData.hp)}/${playerMaxHp}`;

            if (playerData.hp <= 0) {
                logMessage("YOU DIED!", "fore-red");
                playSound(playerDieSound); 
                playerData.hp = Math.floor(playerMaxHp / 2); 
                playerData.gold = Math.max(0, playerData.gold - Math.floor(playerData.gold / 10) - 10); 
                logMessage("Respawned with penalty.", "fore-yellow");
                stopAutoAttack();
                savePlayerData();
                updateHud();
                currentMonsterTarget = null; 
                showCombat(); 
                return;
            }
            
            savePlayerData();
            updateHud();
        }
        
        
        function attemptAutoEat() {
            const playerMaxHp = getMaxHp(getLevelFromXp(playerData.attack_xp));
            if (playerData.hp >= playerMaxHp) return false; 

            let bestFood = null;
            let bestHealAmount = 0;

            for (const itemName in playerData.inventory) {
                if (FOOD_DATA[itemName] && playerData.inventory[itemName] > 0) {
                    if (FOOD_DATA[itemName].heal_amount > bestHealAmount) {
                        bestHealAmount = FOOD_DATA[itemName].heal_amount;
                        bestFood = itemName;
                    }
                }
            }

            if (bestFood) {
                logMessage(`HP critical! Auto-eating ${titleCase(bestFood)}...`, "fore-magenta");
                eatFoodItem(bestFood); 
                return true;
            }
            logMessage("HP critical, but no food to auto-eat!", "fore-red");
            return false;
        }

        // --- Action: Eat Food ---
        function showEatFood() {
            const foodListDiv = document.getElementById('available-food-list');
            foodListDiv.innerHTML = '<div class="section-title">Your Food</div>';
            const playerMaxHp = getMaxHp(getLevelFromXp(playerData.attack_xp));

            if (playerData.hp >= playerMaxHp) {
                foodListDiv.innerHTML += "<p class='fore-green'>HP is full!</p>";
                showSection('eat-food-section');
                return;
            }
            
            let hasFood = false;
            for (const itemName in playerData.inventory) {
                if (FOOD_DATA[itemName] && playerData.inventory[itemName] > 0) {
                    hasFood = true;
                    const food = FOOD_DATA[itemName];
                    const foodDiv = document.createElement('div');
                    foodDiv.className = 'food-item-list item'; 
                    foodDiv.innerHTML = `${food.emoji || ''} ${titleCase(itemName)} (x${playerData.inventory[itemName]}) - Heals: ${food.heal_amount}HP`;
                    foodDiv.onclick = () => eatFoodItem(itemName);
                    foodListDiv.appendChild(foodDiv);
                }
            }
            if (!hasFood) foodListDiv.innerHTML += "<p>You have no food.</p>";
            showSection('eat-food-section');
        }

        function eatFoodItem(itemName) {
            const food = FOOD_DATA[itemName];
            const playerMaxHp = getMaxHp(getLevelFromXp(playerData.attack_xp));
            
            if (playerData.hp >= playerMaxHp) {
                logMessage("HP is already full.", "fore-green");
                return;
            }
            if (playerData.inventory[itemName] > 0) {
                const oldHp = playerData.hp;
                playerData.hp = Math.min(playerMaxHp, playerData.hp + food.heal_amount);
                const actualHealed = playerData.hp - oldHp;
                playerData.inventory[itemName]--;
                
                logMessage(`Ate ${titleCase(itemName)}, +${actualHealed}HP. Current HP: ${playerData.hp}/${playerMaxHp}`, "fore-green");
                savePlayerData();
                updateHud();
                showEatFood(); 
            }
        }
        
        // --- Action: Cook Food (Modified for Shed Perk & new interaction) ---
        function showCookFood() {
            stopAllAutoActions();
            const cookListDiv = document.getElementById('cookable-items-list');
            cookListDiv.innerHTML = '<div class="section-title">Cookable Items</div>';
            currentCookingTarget = null;

            const ckLvl = getLevelFromXp(playerData.cooking_xp);
            let hasCookable = false;
            for (const rawItemName in COOKABLE_ITEMS) {
                if (playerData.inventory[rawItemName] > 0) {
                    hasCookable = true;
                    const cookDetails = COOKABLE_ITEMS[rawItemName];
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'cookable-item-list item'; 
                    const canCook = ckLvl >= cookDetails.level_req;
                    const reqColor = canCook ? 'fore-green' : 'fore-red';

                    itemDiv.innerHTML = `${cookDetails.emoji || ''} ${titleCase(rawItemName)} (x${playerData.inventory[rawItemName]}) 
                                         - <span class="${reqColor}">Req Lvl: ${cookDetails.level_req}</span>`;
                    itemDiv.id = `cookable-list-item-${rawItemName.replace(/\s+/g, '-')}`;
                    if (isAutoCooking && currentCookingTarget === rawItemName) {
                        itemDiv.classList.add('active-cooking-item');
                    }
                    if (canCook) {
                        itemDiv.onclick = () => selectRawItemForCooking(rawItemName);
                    } else {
                        itemDiv.style.cursor = 'not-allowed';
                        itemDiv.title = 'Cooking level too low';
                    }
                    cookListDiv.appendChild(itemDiv);
                }
            }
            if (!hasCookable) cookListDiv.innerHTML += "<p>You have nothing to cook.</p>";
            showSection('cook-food-section');
        }
        
        function selectRawItemForCooking(rawItemName) {
             if (isAutoCooking && currentCookingTarget === rawItemName) {
                stopAutoCooking();
            } else {
                if (isAutoCooking) {
                    stopAutoCooking();
                }
                startAutoCooking(rawItemName);
            }
        }
        
        function startAutoCooking(rawItemName) {
            if (!rawItemName) { logMessage("No item selected for cooking.", "fore-red"); return false; }
            document.querySelectorAll('.active-cooking-item').forEach(el => el.classList.remove('active-cooking-item'));
            currentCookingTarget = rawItemName; 

            if (playerData.inventory[currentCookingTarget] <= 0) {
                logMessage(`No ${titleCase(currentCookingTarget)} to cook.`, "fore-red");
                stopAutoCooking(); currentCookingTarget = null; return false;
            }
            const cookDetails = COOKABLE_ITEMS[currentCookingTarget];
            const currentCookLvl = getLevelFromXp(playerData.cooking_xp);
            if (currentCookLvl < cookDetails.level_req) {
                 logMessage(`Cooking Lvl (${currentCookLvl}) too low for ${titleCase(currentCookingTarget)}. Req: ${cookDetails.level_req}`, "fore-red");
                currentCookingTarget = null; return false;
            }

            isAutoCooking = true;
            const cookListItem = document.getElementById(`cookable-list-item-${currentCookingTarget.replace(/\s+/g, '-')}`);
            if (cookListItem) cookListItem.classList.add('active-cooking-item');
            logMessage(`Auto-cooking ${titleCase(currentCookingTarget)}...`, "fore-cyan");
            
            let interval = BASE_CRAFT_INTERVAL;
            if (playerData.built_structures.shed && STRUCTURE_DATA.shed.perk_effect.type === "crafting_speed_boost") {
                interval *= (1 - STRUCTURE_DATA.shed.perk_effect.value);
            }
            if (playerData.built_structures.stronghold) {
                const speedPerk = STRUCTURE_DATA.stronghold.perks.find(p => p.type === "global_skill_speed_boost");
                if (speedPerk) interval *= (1 - speedPerk.value);
            }
            if(autoCookingInterval) clearInterval(autoCookingInterval);
            autoCookingInterval = setInterval(singleCookAction, interval);
            return true;
        }

        function stopAutoCooking() {
            if (isAutoCooking) {
                isAutoCooking = false;
                clearInterval(autoCookingInterval);
                autoCookingInterval = null;
                if (currentCookingTarget) {
                    const cookListItem = document.getElementById(`cookable-list-item-${currentCookingTarget.replace(/\s+/g, '-')}`);
                    if (cookListItem) cookListItem.classList.remove('active-cooking-item');
                }
                logMessage("Auto-cooking stopped.", "fore-yellow");
            }
        }

        function singleCookAction() {
            if (!isAutoCooking || !currentCookingTarget) { stopAutoCooking(); return; }
            if (playerData.inventory[currentCookingTarget] <= 0) {
                logMessage(`Ran out of ${titleCase(currentCookingTarget)} to cook. Stopping.`, "fore-yellow");
                stopAutoCooking();
                showCookFood(); 
                return;
            }

            const cookDetails = COOKABLE_ITEMS[currentCookingTarget];
            playerData.inventory[currentCookingTarget]--;
            const oldLevel = getLevelFromXp(playerData.cooking_xp);
            
            const currentCookLvlForThisItem = getLevelFromXp(playerData.cooking_xp); 
            let successChance = 0.60 + (currentCookLvlForThisItem - cookDetails.difficulty_level) * 0.02;
            successChance = Math.max(0.10, Math.min(0.98, successChance));

            if (Math.random() < successChance) {
                playerData.inventory[cookDetails.cooked_item] = (playerData.inventory[cookDetails.cooked_item] || 0) + 1;
                
                let xpGainedRaw = cookDetails.xp_gain;
                let xpGainedDisplay = xpGainedRaw; 
                if (playerData.built_structures.house) {
                    const houseXpPerk = STRUCTURE_DATA.house.perks.find(p => p.type === "global_xp_boost");
                    if(houseXpPerk) xpGainedDisplay *= (1 + houseXpPerk.value);
                }
                xpGainedDisplay = Math.floor(xpGainedDisplay);

                playerData.cooking_xp += xpGainedDisplay; 
                grantUniversalXP(xpGainedRaw);
                logMessage(`Cooked 1 ${titleCase(cookDetails.cooked_item)}! (+${xpGainedDisplay} Cook XP)`, "fore-green");
                if (currentCookLvlForThisItem >= cookDetails.difficulty_level + 15 && Math.random() < 0.10) {
                    playerData.inventory[cookDetails.cooked_item]++;
                    logMessage(`Bonus! Extra ${titleCase(cookDetails.cooked_item)}!`, "fore-yellow");
                }
            } else {
                playerData.inventory[cookDetails.burnt_item] = (playerData.inventory[cookDetails.burnt_item] || 0) + 1;
                logMessage(`Burnt the ${titleCase(currentCookingTarget)}.`, "fore-red");
            }
            
            playSound(skillRoundSound); 
            handleLevelUp("cooking_xp", oldLevel); 
            savePlayerData();
            updateHud();
            
            // Update UI for the cooked item count in its list
            if (currentCookingTarget) { 
                 const cookListDiv = document.getElementById('cookable-items-list');
                 const items = cookListDiv.getElementsByClassName('cookable-item-list');
                 for(let itemDiv of items) {
                     if (itemDiv.id === `cookable-list-item-${currentCookingTarget.replace(/\s+/g, '-')}`) {
                         const newQuantity = playerData.inventory[currentCookingTarget] || 0;
                         const canCook = getLevelFromXp(playerData.cooking_xp) >= cookDetails.level_req;
                         const reqColor = canCook ? 'fore-green' : 'fore-red';
                         itemDiv.innerHTML = `${cookDetails.emoji || ''} ${titleCase(currentCookingTarget)} (x${newQuantity}) 
                                         - <span class="${reqColor}">Req Lvl: ${cookDetails.level_req}</span>`;
                         if (newQuantity === 0 || !canCook) {
                            itemDiv.onclick = null; 
                            itemDiv.style.cursor = 'not-allowed';
                            itemDiv.style.opacity = "0.6";
                         } else { 
                            itemDiv.onclick = () => selectRawItemForCooking(currentCookingTarget);
                            itemDiv.style.cursor = 'pointer';
                            itemDiv.style.opacity = "1";
                         }
                         break;
                     }
                 }
            }
             if (playerData.inventory[currentCookingTarget] <= 0) {
                logMessage(`Ran out of ${titleCase(currentCookingTarget)} to cook. Auto-cooking stopped.`, "fore-yellow");
                stopAutoCooking();
            }
        }
        
        // --- NEW: Build Structures ---
        function showBuildStructuresMenu() {
            stopAllAutoActions();
            const listDiv = document.getElementById('available-structures-list');
            listDiv.innerHTML = ''; 

            let canBuildSomething = false;
            let allBuilt = true; 
            for (const structureId in STRUCTURE_DATA) {
                const structure = STRUCTURE_DATA[structureId];
                const div = document.createElement('div');
                div.className = 'item'; 

                let costString = "Cost: ";
                let resourcesMet = true;
                for (const resourceName in structure.cost) {
                    const needed = structure.cost[resourceName];
                    const possessed = playerData.inventory[resourceName] || 0;
                    costString += `${needed} ${titleCase(resourceName)} (${possessed.toLocaleString()}), `;
                    if (possessed < needed) {
                        resourcesMet = false;
                    }
                }
                costString = costString.slice(0, -2); 

                const requirementsMet = !structure.requires_structure || playerData.built_structures[structure.requires_structure];
                const isAlreadyBuilt = playerData.built_structures[structureId];

                if (!isAlreadyBuilt) allBuilt = false;

                div.innerHTML = `
                    <h3>${structure.emoji} ${structure.name} ${isAlreadyBuilt ? "<span class='fore-green'>(Built)</span>" : ""}</h3>
                    <p><em>${structure.perk_desc}</em></p>
                    <p>${costString}</p>
                    ${structure.requires_structure ? `<p>Requires: ${STRUCTURE_DATA[structure.requires_structure].name} Built</p>` : ""}
                `;

                if (!isAlreadyBuilt && requirementsMet) {
                    const buildButton = document.createElement('button');
                    buildButton.textContent = `Build ${structure.name}`;
                    if (resourcesMet) {
                        buildButton.onclick = () => buildStructure(structureId);
                    } else {
                        buildButton.disabled = true;
                        buildButton.title = "Not enough resources.";
                    }
                    div.appendChild(buildButton);
                    canBuildSomething = true;
                } else if (!isAlreadyBuilt && !requirementsMet) {
                    const lockedText = document.createElement('p');
                    lockedText.className = 'fore-red';
                    lockedText.textContent = `Locked. Build ${STRUCTURE_DATA[structure.requires_structure].name} first.`;
                    div.appendChild(lockedText);
                }
                listDiv.appendChild(div);
            }
            if (!canBuildSomething && !allBuilt) {
                listDiv.innerHTML += "<p>No new structures available to build at this time (check resources and requirements).</p>";
            } else if (allBuilt) {
                listDiv.innerHTML += "<p class='fore-green'>Congratulations! You've built all available structures!</p>";
            }
            showSection('build-structures-section');
        }

        function buildStructure(structureId) {
            const structure = STRUCTURE_DATA[structureId];
            if (playerData.built_structures[structureId]) {
                logMessage(`${structure.name} is already built.`, "fore-yellow");
                return;
            }
            if (structure.requires_structure && !playerData.built_structures[structure.requires_structure]) {
                logMessage(`You must build ${STRUCTURE_DATA[structure.requires_structure].name} first.`, "fore-red");
                return;
            }
            for (const resourceName in structure.cost) {
                if ((playerData.inventory[resourceName] || 0) < structure.cost[resourceName]) {
                    logMessage(`Not enough ${titleCase(resourceName)} to build ${structure.name}.`, "fore-red");
                    return;
                }
            }
            for (const resourceName in structure.cost) {
                playerData.inventory[resourceName] -= structure.cost[resourceName];
            }

            playerData.built_structures[structureId] = true;
            logMessage(`Successfully built ${structure.emoji} ${structure.name}! Perk activated.`, "fore-green");
            // playSound(buildStructureSound); // Add a sound effect if you have one

            // Special handling for Cabin HP bonus
            if (structure.perk_effect && structure.perk_effect.type === "max_hp_bonus") {
                playerData.hp += structure.perk_effect.value; // Give the HP
                playerData.hp = Math.min(playerData.hp, getMaxHp(getLevelFromXp(playerData.attack_xp))); // Cap it
            }
            // Special handling for Stronghold HP bonus
            if (structureId === "stronghold" && structure.perks) {
                const hpPerk = structure.perks.find(p => p.type === "max_hp_bonus_flat");
                if (hpPerk) playerData.hp += hpPerk.value;
                playerData.hp = Math.min(playerData.hp, getMaxHp(getLevelFromXp(playerData.attack_xp)));
            }
            
            startRentCollection(); // Check if rent system needs to start/update

            savePlayerData();
            updateHud();
            showBuildStructuresMenu(); 
            if (currentSection === 'inventory-section') populateEquipmentDisplay(); // If Max HP changes, equipment display might too
        }

        // --- Rent Collection System ---
        function startRentCollection() {
            if (rentInterval) clearInterval(rentInterval); 
            
            // Start collecting rent if the Shed is built (as Camp becomes rentable then)
            // Or if any structure that *causes* rent is built.
            // A simpler check: if any structure is built that itself offers rent for a previous one.
            let shouldCollectRent = false;
            for (const structId in STRUCTURE_DATA) {
                if (playerData.built_structures[structId] && STRUCTURE_DATA[structId].rent_value > 0 && STRUCTURE_DATA[structId].requires_structure && playerData.built_structures[STRUCTURE_DATA[structId].requires_structure]) {
                    shouldCollectRent = true;
                    break;
                }
                 // Special case for shed: if shed is built, camp is rentable
                if (structId === "shed" && playerData.built_structures.shed && playerData.built_structures.camp) {
                    shouldCollectRent = true;
                    break;
                }
            }


            if (shouldCollectRent) {
                 logMessage("Rent collection system active.", "fore-blue");
                rentInterval = setInterval(collectRent, RENT_COLLECTION_INTERVAL);
                // Optional: collect rent immediately if enough time has passed since last load
                const timeSinceLastCollection = Date.now() - (playerData.last_rent_collection_time || 0);
                if (playerData.last_rent_collection_time > 0 && timeSinceLastCollection >= RENT_COLLECTION_INTERVAL) {
                    collectRent(); 
                } else if (playerData.last_rent_collection_time === 0) { // First time after building shed
                    playerData.last_rent_collection_time = Date.now(); // Set baseline
                }
            }
        }

        function collectRent() {
            if (!playerData || !playerData.built_structures) return; 

            let totalRentCollected = 0;
            let rentMessages = [];

            // Rent logic: The PREVIOUS structure provides rent once the CURRENT one is built
            // The rent_value in STRUCTURE_DATA[current_structure] is for STRUCTURE_DATA[previous_structure]
            if (playerData.built_structures.shed && playerData.built_structures.camp) { 
                totalRentCollected += STRUCTURE_DATA.shed.rent_value; 
                if (STRUCTURE_DATA.shed.rent_value > 0) rentMessages.push(`${STRUCTURE_DATA.camp.name}: ${STRUCTURE_DATA.shed.rent_value}g`);
            }
            if (playerData.built_structures.cabin && playerData.built_structures.shed) { 
                totalRentCollected += STRUCTURE_DATA.cabin.rent_value;
                if (STRUCTURE_DATA.cabin.rent_value > 0) rentMessages.push(`${STRUCTURE_DATA.shed.name}: ${STRUCTURE_DATA.cabin.rent_value}g`);
            }
            if (playerData.built_structures.house && playerData.built_structures.cabin) { 
                totalRentCollected += STRUCTURE_DATA.house.rent_value;
                if (STRUCTURE_DATA.house.rent_value > 0) rentMessages.push(`${STRUCTURE_DATA.cabin.name}: ${STRUCTURE_DATA.house.rent_value}g`);
            }
            if (playerData.built_structures.mansion && playerData.built_structures.house) { 
                totalRentCollected += STRUCTURE_DATA.mansion.rent_value;
                if (STRUCTURE_DATA.mansion.rent_value > 0) rentMessages.push(`${STRUCTURE_DATA.house.name}: ${STRUCTURE_DATA.mansion.rent_value}g`);
            }
            if (playerData.built_structures.castle && playerData.built_structures.mansion) { 
                totalRentCollected += STRUCTURE_DATA.castle.rent_value;
                if (STRUCTURE_DATA.castle.rent_value > 0) rentMessages.push(`${STRUCTURE_DATA.mansion.name}: ${STRUCTURE_DATA.castle.rent_value}g`);
            }
            if (playerData.built_structures.stronghold && playerData.built_structures.castle) { 
                totalRentCollected += STRUCTURE_DATA.stronghold.rent_value;
                if (STRUCTURE_DATA.stronghold.rent_value > 0) rentMessages.push(`${STRUCTURE_DATA.castle.name}: ${STRUCTURE_DATA.stronghold.rent_value}g`);
            }

            if (totalRentCollected > 0) {
                playerData.gold += totalRentCollected;
                logMessage(`Collected ${totalRentCollected} gold from rent! (${rentMessages.join(', ')})`, "fore-yellow");
                updateHud();
                savePlayerData(); 
            }
            playerData.last_rent_collection_time = Date.now();
        }


        // --- Perk Tree ---
        function showPerkTreeMenu() {
            stopAllAutoActions();
            const perkListDiv = document.getElementById('perk-list');
            perkListDiv.innerHTML = "";
            const availablePoints = (playerData.perk_points_earned || 0) - (playerData.perk_points_spent || 0);
            document.getElementById('available-perk-points').textContent = availablePoints;

            for (const perkId in PERK_DATA) {
                const perk = PERK_DATA[perkId];
                const perkDiv = document.createElement('div');
                perkDiv.className = 'perk-entry';
                
                const isUnlocked = playerData.active_perks[perkId];
                const canAfford = availablePoints >= perk.cost;
                const reqsMet = perk.requires.every(reqId => playerData.active_perks[reqId]);

                let statusText = "";
                if (isUnlocked) {
                    perkDiv.classList.add('activated-perk');
                    statusText = " (Activated)";
                } else if (!reqsMet) {
                    perkDiv.classList.add('disabled-perk');
                    statusText = " (Locked - Requires: " + perk.requires.map(r => PERK_DATA[r] ? PERK_DATA[r].name : r).join(', ') + ")";
                } else if (!canAfford) {
                    perkDiv.classList.add('disabled-perk');
                    statusText = " (Locked - Not enough points)";
                } else {
                    perkDiv.onclick = () => activatePerk(perkId);
                }

                perkDiv.innerHTML = `
                    <span class="perk-name">${perk.name}</span>
                    <span class="perk-cost">Cost: ${perk.cost} PP</span>
                    <div class="perk-desc">${perk.description}${statusText}</div>
                `;
                perkListDiv.appendChild(perkDiv);
            }
            showSection('perk-tree-section');
        }

        function activatePerk(perkId) {
            const perk = PERK_DATA[perkId];
            const availablePoints = (playerData.perk_points_earned || 0) - (playerData.perk_points_spent || 0);

            if (playerData.active_perks[perkId]) {
                logMessage("Perk already activated.", "fore-yellow");
                return;
            }
            if (availablePoints < perk.cost) {
                logMessage("Not enough perk points.", "fore-red");
                return;
            }
            if (!perk.requires.every(reqId => playerData.active_perks[reqId])) {
                logMessage("Prerequisites not met for this perk.", "fore-red");
                return;
            }

            playerData.active_perks[perkId] = true;
            playerData.perk_points_spent += perk.cost;
            logMessage(`Activated Perk: ${perk.name}!`, "fore-magenta");
            playSound(levelUpSound); 
            savePlayerData();
            updateHud();
            showPerkTreeMenu(); 
            populateEquipmentDisplay(); 
        }

        function checkCanStillSmith(itemName) {
            if (!itemName || !SWORD_DATA[itemName]) return false;
            const itemData = SWORD_DATA[itemName];
            for (const bar in itemData.recipe) {
                const requiredAmount = isPerkActive("masterSmith") && itemData.recipe[bar] > 1 ?
                                      Math.max(1, itemData.recipe[bar] - PERK_DATA.masterSmith.value) :
                                      itemData.recipe[bar];
                if ((playerData.inventory[bar] || 0) < requiredAmount) {
                    return false;
                }
            }
            return true;
        }

        function updateSmithableItemDisplay(itemName) {
            const itemDiv = document.getElementById(`smithable-item-div-${itemName.replace(/\s+/g, '-')}`);
            if (!itemDiv || !SWORD_DATA[itemName]) return;

            const itemData = SWORD_DATA[itemName];
            let recipeString = "";
            for (const bar in itemData.recipe) {
                const requiredAmount = isPerkActive("masterSmith") && itemData.recipe[bar] > 1 ?
                                      Math.max(1, itemData.recipe[bar] - PERK_DATA.masterSmith.value) :
                                      itemData.recipe[bar];
                recipeString += `${requiredAmount} ${titleCase(bar)} (${playerData.inventory[bar] || 0}), `;
            }
            recipeString = recipeString.slice(0, -2);
            const bsLvl = getLevelFromXp(playerData.blacksmithing_xp);
            const levelReqColor = bsLvl >= itemData.smith_level_req ? 'fore-green' : 'fore-red';
            const newMaxCraftableDisplay = calculateMaxCraftableForSword(itemName);
            
            // Update the "Requires" part within the left details span
            const detailsSpan = itemDiv.querySelector('.item-details-left');
            if (detailsSpan) {
                const smallReqSpan = detailsSpan.querySelector('small'); // Assuming the "Requires" is the first/primary small tag
                if (smallReqSpan) {
                    // Find existing lifesteal info to preserve it
                    let lifestealInfoHTML = "";
                    const lifestealSpans = detailsSpan.querySelectorAll('small.fore-magenta'); // More specific selector if needed
                    lifestealSpans.forEach(lsSpan => {
                        if (lsSpan.textContent.includes("Lifesteal")) {
                            lifestealInfoHTML = `<br>${lsSpan.outerHTML}`; // Keep the <br> if it was there
                        }
                    });
                    smallReqSpan.innerHTML = `Requires: ${recipeString} - <span class="${levelReqColor}">Lvl: ${itemData.smith_level_req} BS</span> - Max: <span id="max-craftable-smith-${itemName.replace(/\s+/g, '-')}">${newMaxCraftableDisplay}</span>`;
                    // Re-append lifesteal info if it existed
                    if (lifestealInfoHTML) {
                        detailsSpan.innerHTML = detailsSpan.innerHTML.replace(/<\/small>(<br><small class="fore-magenta">Lifesteal:.*?<\/small>)?/, `</small>${lifestealInfoHTML}`);
                    }
                }
            }
            // Update the "In Stock" count
            const stockCountSpan = itemDiv.querySelector(`#inv-count-smith-${itemName.replace(/\s+/g, '-')}`);
            if (stockCountSpan) {
                stockCountSpan.textContent = playerData.inventory[itemName] || 0;
            }
        }

        function updateSmithableItemDisplay(itemName) {
            const itemDiv = document.getElementById(`smithable-item-div-${itemName.replace(/\s+/g, '-')}`);
            if (!itemDiv || !SWORD_DATA[itemName]) return;

            // For simplicity and to ensure all parts (recipe, max craftable, stock) are updated correctly,
            // we can just call showSmithingMenu() which rebuilds the whole list.
            // This is less efficient if the list is very long, but safer for now.
            // If performance becomes an issue, a more targeted update like in singleSmeltAction can be implemented.
            showSmithingMenu();
        }

        // --- Level Up ---
        function handleLevelUp(skillXpField, oldLevel) {
            const newLevel = getLevelFromXp(playerData[skillXpField]);
            if (newLevel > oldLevel) {
                const skillName = titleCase(skillXpField.replace('_xp', ''));
                logMessage(`Congrats! ${skillName} Level ${newLevel}!`, "fore-yellow");
                playSound(levelUpSound); 
                if (skillName === "Attack") {
                    const oldMaxHpVal = getMaxHp(oldLevel); // Max HP before level up
                    const newMaxHpVal = getMaxHp(newLevel); // Max HP after level up (considers Cabin)
                    playerData.hp += (newMaxHpVal - oldMaxHpVal); // Add the difference
                    playerData.hp = Math.min(playerData.hp, newMaxHpVal); // Cap at new max
                    logMessage("HP increased and restored!", "fore-green");
                }
                updateHud(); 
                
                // Refresh current screen if it displays level-gated content
                if (currentSection === 'woodcutting-section') showWoodcutting();
                else if (currentSection === 'mining-section') showMining();
                else if (currentSection === 'cook-food-section') showCookFood();
                else if (currentSection === 'smelting-section') showSmeltingMenu();
                else if (currentSection === 'smithing-section') showSmithingMenu();
                else if (currentSection === 'combat-section') showCombat();
                else if (currentSection === 'build-structures-section') showBuildStructuresMenu(); 
                
                return true;
            }
            return false;
        }


        // --- Cheats ---
        function applyCheat() {
            const cheatInput = document.getElementById('cheat-input');
            const cheatCode = cheatInput.value.trim();
            cheatInput.value = ''; 

            if (cheatCode === "rosebud") {
                playerData.gold += 50000;
                logMessage("+50,000 Gold! Shhh...", "fore-magenta");
            } else if (cheatCode === "xpboost") {
                const xpToAdd = 10000; 
                const skillsToBoost = ["attack_xp", "woodcutting_xp", "mining_xp", "cooking_xp", "blacksmithing_xp"];
                
                skillsToBoost.forEach(skillField => {
                    const oldLevel = getLevelFromXp(playerData[skillField]);
                    playerData[skillField] += xpToAdd;
                    grantUniversalXP(xpToAdd); 
                    handleLevelUp(skillField, oldLevel); 
                });
                logMessage("XP Boost applied to all skills!", "fore-magenta");

            } else if (cheatCode === "perkmeup") {
                playerData.perk_points_earned += 5;
                 logMessage("+5 Perk Points! Total XP may not reflect this.", "fore-magenta"); 
            }
             else if (cheatCode === "buildall") { // Cheat to build all structures
                for (const structId in STRUCTURE_DATA) {
                    playerData.built_structures[structId] = true;
                }
                logMessage("All structures magically built! Perks activated.", "fore-magenta");
                if (playerData.built_structures.cabin) { // Adjust HP for cabin
                     playerData.hp = getMaxHp(getLevelFromXp(playerData.attack_xp));
                }
                if (playerData.built_structures.stronghold) { // Adjust HP for stronghold
                     playerData.hp = getMaxHp(getLevelFromXp(playerData.attack_xp));
                }
                startRentCollection(); // Ensure rent starts
            }
            else {
                logMessage("Invalid cheat code.", "fore-red");
                return; 
            }
            savePlayerData();
            updateHud();
        }

        // --- Game Control ---
        function quitGame() { // Not explicitly called by a button, but good practice to have
            stopAllAutoActions(); 
            if (rentInterval) clearInterval(rentInterval);
            savePlayerData();
            logMessage("Game saved. Thanks for playing!", "fore-blue");
        }
        window.addEventListener('beforeunload', quitGame); // Auto-save on closing tab/browser

        // --- Initialization ---
        function initGame() {
            loadPlayerData(); // playerData is now global

            const isFirstTime = !localStorage.getItem('textAdventurePlayerData');
            if (isFirstTime || Object.keys(playerData).length < 5) { 
                playerData = JSON.parse(JSON.stringify(DEFAULT_PLAYER)); 
                savePlayerData(); 
                logMessage("Welcome to the Adventure! New game started.", "fore-blue");
            } else {
                logMessage("Game loaded. Welcome back, " + (playerData.name || "Adventurer") + "!", "fore-blue");
            }
            
            // Ensure getMaxHp is called AFTER playerData (and its built_structures) is loaded
            playerData.hp = Math.min(playerData.hp, getMaxHp(getLevelFromXp(playerData.attack_xp)));


            const savedMuteState = localStorage.getItem('textAdventureSoundsMuted');
            if (savedMuteState !== null) {
                soundsMuted = savedMuteState === 'true';
            }
            const muteButton = document.getElementById('mute-toggle-btn');
            muteButton.textContent = soundsMuted ? "Unmute Sounds" : "Mute Sounds";
            muteButton.onclick = toggleMute;
            
            updatePerkPoints(); // Call this to calculate initial perk points from total_skill_xp
            updateHud(); // Now updateHud can use fully initialized playerData including perk points and maxHP
            startRentCollection(); // Start rent timer if applicable based on loaded save
            showMainMenu();
        }

        document.addEventListener('DOMContentLoaded', initGame);

    </script>
</body>
</html>